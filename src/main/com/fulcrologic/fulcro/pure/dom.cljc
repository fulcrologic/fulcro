(ns com.fulcrologic.fulcro.pure.dom
  "Pure DOM element creation for NPM-free rendering.

   This namespace provides DOM element factories that produce Element records
   compatible with both CLJ and CLJS. These elements can be converted to hiccup
   for rendering by libraries like Replicant, or used for headless testing.

   Usage is identical to com.fulcrologic.fulcro.dom:

   ```clojure
   (require '[com.fulcrologic.fulcro.pure.dom :as dom])

   (dom/div {:id \"my-div\" :className \"container\"}
     (dom/h1 {} \"Hello\")
     (dom/p {:style {:color \"red\"}} \"World\"))
   ```

   The Element records preserve all attributes including event handlers,
   making them suitable for interactive testing and Replicant integration."
  (:refer-clojure :exclude [filter map mask meta select set symbol time use])
  #?(:cljs (:require-macros com.fulcrologic.fulcro.pure.dom))
  (:require
    [clojure.string :as str]
    [com.fulcrologic.fulcro.dom-common :as cdom]
    [com.fulcrologic.fulcro.raw.components :as rc :refer [component-instance?]]))

;; =============================================================================
;; Element Records
;; =============================================================================

(defrecord Element [tag attrs react-key children])
(defrecord Text [s])
(defrecord ReactText [text])
(defrecord ReactEmpty [])
(defrecord ReactFragment [elements])

(defn element?
  "Returns true if the given arg is a pure DOM element."
  [x]
  (instance? Element x))

(defn text?
  "Returns true if x is a Text node."
  [x]
  (instance? Text x))

(defn react-text?
  "Returns true if x is a ReactText node."
  [x]
  (instance? ReactText x))

(defn react-empty?
  "Returns true if x is a ReactEmpty node."
  [x]
  (instance? ReactEmpty x))

(defn react-fragment?
  "Returns true if x is a ReactFragment node."
  [x]
  (instance? ReactFragment x))

;; Forward declarations for all HTML/SVG tags (generated by gen-all-tags macro)
(declare a abbr address altGlyph altGlyphDef altGlyphItem animate animateColor animateMotion animateTransform area
  article aside audio b base bdi bdo big blockquote body br button canvas caption circle cite clipPath code
  col colgroup color-profile cursor data datalist dd defs del desc details dfn dialog discard div dl dt
  ellipse em embed feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting
  feDisplacementMap feDistantLight feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur
  feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence
  fieldset figcaption figure filter font font-face font-face-format font-face-name font-face-src font-face-uri
  footer foreignObject form g glyph glyphRef h1 h2 h3 h4 h5 h6 hatch hatchpath head header hkern hr html
  i iframe image img input ins kbd keygen label legend li line linearGradient link main map mark marker mask
  menu menuitem mesh meshgradient meshpatch meshrow meta metadata meter missing-glyph
  mpath nav noscript object ol optgroup option output p param path pattern picture polygon polyline pre progress q radialGradient
  rect rp rt ruby s samp script section select set small solidcolor source span stop strong style sub summary
  sup svg switch symbol table tbody td text textPath textarea tfoot th thead time title tr track tref tspan
  u ul unknown use var video view vkern wbr)

(defn text-node
  "Create a text node element."
  [s]
  (->Text (str s)))

(defn react-text-node
  "Create a React-style text node (with comment markers for SSR compatibility)."
  [s]
  (->ReactText (str s)))

(defn react-empty-node
  "Create an empty React element placeholder."
  []
  (->ReactEmpty))

(defn react-fragment-node
  "Create a React fragment containing multiple elements."
  [elements]
  (->ReactFragment elements))

;; =============================================================================
;; Argument Parsing (matches dom-server behavior)
;; =============================================================================

(defn- child->typed-child
  "Converts a child to a tagged tuple for consistent handling."
  [child]
  (cond
    (string? child) [:string child]
    (number? child) [:number child]
    (or (vector? child) (seq? child)) [:collection child]
    (nil? child) [:nil child]
    (component-instance? child) [:component child]
    (element? child) [:element child]
    :else [:unknown child]))

(defn parse-args
  "Runtime parsing of DOM tag arguments. Returns a map with keys :css, :attrs, and :children.
   This matches the dom-server implementation for consistent behavior."
  [args]
  (letfn [(parse-css [[args result :as pair]]
            (let [arg (first args)]
              (if (keyword? arg)
                [(next args) (assoc result :css arg)]
                pair)))
          (parse-attrs [[args result :as pair]]
            (let [has-arg? (seq args)
                  arg      (first args)]
              (cond
                ;; nil is valid attrs
                (and has-arg? (nil? arg))
                [(next args) (assoc result :attrs [:nil nil])]
                ;; Map that is NOT a component instance or element is attrs
                (and (map? arg)
                  (not (component-instance? arg))
                  (not (element? arg)))
                [(next args) (assoc result :attrs [:map arg])]
                ;; Otherwise, no attrs - leave for children
                :else pair)))
          (parse-children [[args result]]
            [nil (cond-> result
                   (seq args) (assoc :children (mapv child->typed-child args)))])]
    (-> [args {}]
      (parse-css)
      (parse-attrs)
      (parse-children)
      second)))

;; =============================================================================
;; Attribute Handling
;; =============================================================================

(def no-suffix
  "CSS properties that don't need 'px' suffix for numeric values."
  #{"animationIterationCount" "boxFlex" "boxFlexGroup" "boxOrdinalGroup"
    "columnCount" "fillOpacity" "flex" "flexGrow" "flexPositive" "flexShrink"
    "flexNegative" "flexOrder" "fontWeight" "lineClamp" "lineHeight" "opacity"
    "order" "orphans" "stopOpacity" "strokeDashoffset" "strokeOpacity"
    "strokeWidth" "tabSize" "widows" "zIndex" "zoom"})

(def lower-case-attrs
  "Attributes that should be lowercased for HTML."
  #{"accessKey" "allowFullScreen" "allowTransparency" "as" "autoComplete"
    "autoFocus" "autoPlay" "contentEditable" "contextMenu" "crossOrigin"
    "cellPadding" "cellSpacing" "charSet" "classID" "colSpan" "dateTime"
    "encType" "formAction" "formEncType" "formMethod" "formNoValidate"
    "formTarget" "frameBorder" "hrefLang" "inputMode" "keyParams"
    "keyType" "marginHeight" "marginWidth" "maxLength" "mediaGroup"
    "minLength" "noValidate" "playsInline" "radioGroup" "readOnly" "rowSpan"
    "spellCheck" "srcDoc" "srcLang" "srcSet" "tabIndex" "useMap"
    "autoCapitalize" "autoCorrect" "autoSave" "itemProp" "itemScope"
    "itemType" "itemID" "itemRef"})

(def kebab-case-attrs
  "Attributes that should be converted to kebab-case for HTML."
  #{"acceptCharset" "httpEquiv" "accentHeight" "alignmentBaseline" "arabicForm"
    "baselineShift" "capHeight" "clipPath" "clipRule" "colorInterpolation"
    "colorInterpolationFilters" "colorProfile" "colorRendering" "dominantBaseline"
    "enableBackground" "fillOpacity" "fillRule" "floodColor" "floodOpacity"
    "fontFamily" "fontSize" "fontSizeAdjust" "fontStretch" "fontStyle"
    "fontVariant" "fontWeight" "glyphName" "glyphOrientationHorizontal"
    "glyphOrientationVertical" "horizAdvX" "horizOriginX" "imageRendering"
    "letterSpacing" "lightingColor" "markerEnd" "markerMid" "markerStart"
    "overlinePosition" "overlineThickness" "paintOrder" "panose1" "pointerEvents"
    "renderingIntent" "shapeRendering" "stopColor" "stopOpacity" "strikethroughPosition"
    "strikethroughThickness" "strokeDasharray" "strokeDashoffset" "strokeLinecap"
    "strokeLinejoin" "strokeMiterlimit" "strokeOpacity" "strokeWidth" "textAnchor"
    "textDecoration" "textRendering" "underlinePosition" "underlineThickness"
    "unicodeBidi" "unicodeRange" "unitsPerEm" "vAlphabetic" "vHanging" "vIdeographic"
    "vMathematical" "vectorEffect" "vertAdvY" "vertOriginX" "vertOriginY" "wordSpacing"
    "writingMode" "xHeight"})

(def colon-between-attrs
  "Attributes that use colon separator (xlink:href, etc.)."
  #{"xlinkActuate" "xlinkArcrole" "xlinkHref" "xlinkRole" "xlinkShow" "xlinkTitle"
    "xlinkType" "xmlBase" "xmlnsXlink" "xmlLang" "xmlSpace"})

(defn- camel->other-case
  "Convert camelCase to other-case using the given separator."
  [^String sep]
  (fn [^String s]
    (-> s
      (str/replace #"([A-Z0-9])" (str sep "$1"))
      str/lower-case)))

(def camel->kebab-case
  "Convert camelCase to kebab-case."
  (camel->other-case "-"))

(def camel->colon-between
  "Convert camelCase to colon:between."
  (camel->other-case ":"))

(defn coerce-attr-key
  "Convert a React-style attribute key to its HTML equivalent."
  [^String k]
  (cond
    (contains? lower-case-attrs k) (str/lower-case k)
    (contains? kebab-case-attrs k) (camel->kebab-case k)
    ;; special cases
    (= k "className") "class"
    (= k "htmlFor") "for"
    (contains? colon-between-attrs k) (camel->colon-between k)
    :else k))

;; =============================================================================
;; Element Creation
;; =============================================================================

(defn- process-child
  "Process a single child, converting it to an appropriate element type."
  [child child-node-count]
  (cond
    ;; Check primitives FIRST - before component-instance? which uses gobj/get in CLJS
    (nil? child) nil
    (string? child) (if (> child-node-count 1)
                      (react-text-node child)
                      (text-node child))
    (number? child) (let [c (str child)]
                      (if (> child-node-count 1)
                        (react-text-node c)
                        (text-node c)))

    ;; Then check our record types
    (element? child) child
    (instance? Element child) child
    (instance? Text child) child
    (instance? ReactText child) child
    (instance? ReactEmpty child) child
    (instance? ReactFragment child) child

    ;; Now safe to check component-instance? (requires object in CLJS)
    (component-instance? child)
    ;; Component instances are preserved for later rendering
    child

    :else
    (throw (ex-info "Invalid child element" {:child child :type (type child)}))))

(defn element
  "Create a DOM element. This is the core element creation function."
  [{:keys [tag attrs react-key children] :as elem}]
  (assert (name tag) "Tag name is required")
  (assert (or (nil? attrs) (map? attrs)) (str "elem " elem " attrs invalid"))
  (let [children         (flatten children)
        child-node-count (count children)
        children         (reduce
                           (fn [res c]
                             (let [c' (process-child c child-node-count)]
                               (cond-> res
                                 (some? c') (conj c'))))
                           [] children)]
    (->Element (name tag) attrs react-key children)))

(defn create-element
  "Create a DOM element for which there exists no corresponding function.
   Useful to create DOM elements not included in the standard set.

   ```clojure
   (create-element \"custom-element\" {:id \"my-custom\"} \"content\")
   ```"
  ([tag]
   (create-element tag nil))
  ([tag opts & children]
   (element {:tag       tag
             :attrs     (dissoc opts :ref :key)
             :react-key (:key opts)
             :children  children})))

;; =============================================================================
;; Tag Generation
;; =============================================================================

(defn gen-tag-fn
  "Generate a tag function form for use in macros."
  [tag]
  `(defn ~tag ~(cdom/gen-docstring tag false)
     [& ~'args]
     (let [parsed#      (parse-args ~'args)
           {attrs#    :attrs
            children# :children
            css#      :css} parsed#
           children#    (mapv second children#)
           attrs-value# (or (second attrs#) {})]
       (element {:tag       '~tag
                 :attrs     (-> (cdom/interpret-classes attrs-value#)
                              (dissoc :ref :key)
                              (cdom/add-kwprops-to-props css#))
                 :react-key (:key attrs-value#)
                 :children  children#}))))

;; The gen-all-tags macro generates defn forms for all HTML/SVG tags.
;; It must be in CLJ-only section because macros are only expanded from CLJ.
;; The macro is invoked from both CLJ (directly) and CLJS (via require-macros).
#?(:clj
   (defmacro gen-all-tags
     "Generate all standard HTML/SVG tag functions."
     []
     `(do
        ~@(clojure.core/map gen-tag-fn cdom/tags))))

;; Invoke the macro to generate all tag functions
;; This single call works for both CLJ and CLJS because:
;; - In CLJ: macro is defined and invoked directly
;; - In CLJS: macro comes from require-macros and is invoked at compile time
(com.fulcrologic.fulcro.pure.dom/gen-all-tags)

;; =============================================================================
;; Fragment Support
;; =============================================================================

(defn fragment
  "Create a React-style fragment containing multiple children without a wrapper element.

   ```clojure
   (dom/fragment
     (dom/div {} \"First\")
     (dom/div {} \"Second\"))
   ```"
  [& children]
  (react-fragment-node (vec children)))

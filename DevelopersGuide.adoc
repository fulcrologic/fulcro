= Fulcro Developers Guide
:author: Tony Kay
:revdate: Feb 15, 2018
:revnumber: 1.1
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 2
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: assets/img
:scriptsdir: js
:imagesoutdir: docs/assets/img

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

= Prologue

== About This Book

This is a stand-alone book for Fulcro developers that can be used by beginners and experienced
developers and covers most of the library in detail. Fulcro has a
pretty extensive set of resources on the web tailored to fit your learning style.
There is http://book.fulcrologic.com[this book],
https://youtu.be/pLFOVhWsxMM?list=PLVi9lDx-4C_Rwb8LUwW4AdjAu-39PHgEE[YouTube videos], 
an http://fulcro.fulcrologic.com/tutorial.html[interactive tutorial], 
and full-blown https://github.com/fulcrologic[sample applications].

A lot of time and energy went into creating these libraries and materials and providing them free of 
charge. If you find them useful please consider 
http://fulcro.fulcrologic.com/fund.html[contributing to the project].

This book includes quite a bit of live code. Live code demos with their source
look like this:

++++
<div id="server-controls"> </div>
<div class="example" id="example-1"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.example-1').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="example-1 source"]
----
include::src/book/book/example_1.cljc[]
----

All of the full stack examples use a mock server embedded in the browser to
simulate the interaction, but the source that you'll read for the application is
identical to what you'd write for a real server.

WARNING: If you're viewing this directly from the GitHub Fulcro repository then you
won't see the live code! Use http://book.fulcrologic.com instead.

The mock server has a built-in latency to
simulate a moderately slow network so you can observe behaviors over time. You can
control the length of this latency in milliseconds using the "Server Controls" in the upper-right
corner of this document (if you're reading the HTML version with live examples).

=== Common Prefixes and Namespaces

Many of the code examples assume you've required the proper namespaces in your
code. This book adopts the following general set of requires and aliases:

[source,clojure]
----
(ns your-ns
  (:require [fulcro.client.primitives :as prim :refer [defsc defui]]
            [fulcro.client.dom :as dom]
            [fulcro.util :as util]
            [fulcro.client.util :as cutil]
            [fulcro.client.mutations :as m :refer [defmutation]]
            [fulcro.server :as server :refer [defquery-root defquery-entity]]
            [fulcro.client :as fc]])
----

others will be identified as they are used.

The next chapter, "Getting Started", is an exception. The code you see in that chapter is meant to be added to
a template that you create and run on your own machine. A complete running version of it is available on GitHub
as described at the end of the chapter.

= Getting Started

This chapter is meant to be a whirlwind introduction. It takes you through a step-by-step guide of how to go
from nothing to a full-stack basic application using the Fulcro leiningen template. Concepts are introduced as we
go, and given a very cursory definition in the interest of concision. Once you've got the general idea you
can use other materials to refine your understanding.

The Leiningen template is the very quickest way to get started. It gives you a number of useful
things like devcards, production builds, CI integration and more while also giving you the minimal
amount of actual code. This can save you hours of setup.

== Project setup

You can get a basic app with no prewritten demo code using:

[source,bash]
----
$ lein new fulcro app nodemo
----

The `nodemo` option tells the template not to include demonstration full-stack code. It gives you a
shell of a project that still contains everything you'd want to set up (cards, testing, a development
web server, figwheel, etc.) without much actual code to understand or delete.

You should stop here for a moment and read the README in your generated project to see how that
is laid out.

=== Figwheel Startup Script

Figwheel is a hot-reload development tool. We recommend using figwheel sidecar so
you can easily start the project from the command line or use it from the REPL
support built into IntelliJ. The template already has the code for doing this. Part of
it is in `user.clj`, and the other part is a simple script `script/figwheel.clj` to invoke it:

[source]
----
(require '[user :refer [start-figwheel]])

(start-figwheel)
----

The `README` of your project describes how to start the various builds of your cljs code.

== The Code Client Files

A complete Fulcro front-end client can be created in about two lines of code. Hot-load
concerns require just a few more lines.

Your project should have a `src/main/app/client.cljs` file that looks something like this:

```
(ns app.client
  (:require [fulcro.client :as fc]))

(defonce app (atom (fc/new-fulcro-client)))
```

This creates a client and stores it in an atom. The client isn't active until you mount it. In
order to do *that*, you need a UI. The file `src/main/ui/root.cljc` contains something like
this:

```
(ns app.ui.root
  (:require
    translations.es
    [fulcro.client.dom :as dom]
    [fulcro.client.primitives :as prim :refer [defsc]]))

(defsc Root [this {:keys [ui/react-key]}]
  (dom/div #js {:key react-key} "TODO"))
```

The actual mount is done by code that figwheel is configured to load/run in
`src/dev/user.cljs`:

```
(ns cljs.user
  (:require
    [fulcro.client :as fc]
    [app.client :as core]
    [app.ui.root :as root]
    [cljs.pprint :refer [pprint]]
    [fulcro.logging :as log]))

(enable-console-print!)

(log/set-level! :all)

(defn mount []
  (reset! core/app (fc/mount @core/app root/Root "app")))

(mount)
```

If you look at your `project.clj` file you'll see it is configured to re-call `mount` on every hot load.
Mounting an already mounted app is the same as asking for a forced UI refresh.

This is all the real code you need to get started with a hot-code reload capable application! However, the
browser needs instructions to load this stuff up, and the target `div` of the mount needs to exist.

=== HTML

The most basic HTML file you can start with (and it won't get much bigger) is:

[source,html]
----
<!DOCTYPE html>
<html>
    <body>
        <div id="app"></div>
        <script src="js/app.js" type="text/javascript"></script>
    </body>
</html>
----

Save this in `resources/public/index.html`.

=== Running Figwheel

You can now run this project in various ways.

From the command line:

[source,bash]
----
$ lein run -m clojure.main script/figwheel.clj
----

Within IntelliJ:

* Run -> Edit Configurations...
* Press the '+' button, and choose Clojure REPL -> Local
** Give it a name (like `dev`)
** Choose "Use clojure.main in normal JVM process" (important: it defaults to nREPL which won't work right)
** In `JVM Args` specify `-Ddev`. This is a trick of the template's figwheel script that lets you pick
one or more build from your build config easily. This selects just the `dev` build.
** In `Parameters` add `script/figwheel.clj`

Now you should be able to start it from the Run menu.

For Emacs + Cider:

* Make sure a piggieback dev-time dependency and repl-option are in `project.clj`:
```
  :profiles {:dev {:source-paths ["src/dev" "src/main"]
                   :repl-options {:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]}
                   :dependencies [[binaryage/devtools "0.9.4"]
                                  [com.cemerick/piggieback "0.2.1"]
                                  [org.clojure/tools.namespace "0.3.0-alpha4"]
                                  [figwheel-sidecar "0.5.13"]
                                  [org.clojure/tools.nrepl "0.2.13"]]}})
```
* With `src/dev/user.clj` open in a buffer, choose `M-x cider-jack-in`. In the clojure repl, run `(start-figwheel)`, which will launch a cljs repl.

You should see the application printing "Hello World" at: http://localhost:3449[]

Now that you have a basic project working, let's understand how to add some
content!

IMPORTANT: When developing it is a good idea to: Use Chrome (the devtools only work there),
have the developer's console open, and in the developer console settings: "Network, Disable cache (while
DevTools is open)", and "Console, Enable custom formatters".

Cached files can, as everywhere else, cause you lots of headaches. Fortunately they only really affect you poorly
on the initial load in Fulcro. Hot reloads typically work very well.

=== Fixing Things

One of the most maddening things that can happen during development is mystery around build errors. Nothing is
more frustrating than not understanding what is wrong.

As you work on your code your compiler errors and warnings will show in the browser. DO NOT RELOAD THE PAGE! If
you reload the page you'll lose the warning or error, and that makes it harder to figure out what is wrong!

Instead, edit your code and re-save.

If you are having problems and you've lost your way, it is sometimes useful to ask figwheel to clean and recompile
everything:

----
cljs.user=> (reset-autobuild)
----

will typically get you back on track.

==== Fixing Stubborn Things

Sometimes stuff just fails for reasons we fail to understand. There are times when
you may want to completely kill your REPL, clean the project with `lein clean`, and start again. Make sure all
of the generated Javascript is removed when you clean, or things might not clear up.

It is also true that problems in your project configuration may cause problems that are very difficult to
understand. If this happens to you (especially if you've never run a project with the current project setup) then
it is good to look at things like dependency problems with `lein deps :tree` and fix those.

In general, if you see a conflict on versions it will work to place the newest version of the conflicted dependency into
your own dependency list. This can cause problems as well, but is less likely to fail than using an older version
of a library that doesn't have some needed feature of bug fix.

== Basic UI Components

Fulcro supplies `defsc` to build React components. This macro emits React components that work as 100% raw React
components (i.e. once you compile them to Javascript they could be used from other native React code).

There are also factory functions for generating all standard HTML5 DOM elements in React in the `fulcro.client.dom` namespace.

=== The `defsc` Macro

The basic code to build a simple component has the following form:

```
(defsc ComponentName
  ; optional: "docstring"
  [this props] ; parameters. Available in body, and in *some* of the options
  ; optional:  { ...options... }
  (dom/div #js {:className "a"}
    (dom/p nil "Hello")))
```

For our purposes we won't be saying much about the React lifecycle methods, though they can be added. The basic
intention of this macro's syntax is to declare a component that can render UI and participate in our
data-driven story.

This macro emits the equivalent of a React component with a `render` method.

=== The `render` method.

The body of `defsc` is the render for the component and can do whatever work you need, but it should return
a react element (see https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html[React Components, Elements, and Instances]).

Luckily, there are factory methods for all of HTML5 in `fulcro.client.dom`. These functions generally take a Javascript map
as their first argument (for things like classname and event handlers) and any children. There are two ways to
generate the Javascript map: with the reader tag `#js` or with `clj->js`. Thus the following two are functionally
equivalent:

```
(dom/div #js {:className "a"} "Hi")
(dom/div (clj->js {:className "a"}) "Hi")
```

However, the former happens in the reader (before compile) and generates more efficient runtime code, but the
latter is useful when you've computed attributes in regular clj data structures and need to convert it at runtime.

=== Props

React components receive their data through props and state (which is local mutable state on the component).
In Fulcro we highly recommend using props for most things. This
ensures that various other features work well. The data passed to a component can be accessed (as a cljs map) by
calling `prim/props` on `this`, or by destructuring in the second argument of `defsc`.

So, let's define a `Person` component to display details about
a person. We'll assume that we're going to pass in name and age as properties:

```
(defsc Person [this {:keys [person/name person/age]}]
  (dom/div nil
    (dom/p nil "Name: " name)
    (dom/p nil "Age: " age)))
```

Now, in order to use this component we need an element factory. An element factory lets
us use the component within our React UI tree. Name confusion can become an
issue (Person the component vs. person the factory?) we recommend prefixing the factory with `ui-`:

```
(def ui-person (prim/factory Person))
```

Now we can compose people into our root:

```
(defsc Root [this {:keys [ui/react-key]}]
  (dom/div #js {:key react-key }
    (ui-person {:person/name "Joe" :person/age 22})))
```

=== Hot Code Reload

Part of our quick development story is getting hot code reload to update the UI whenever we change the source.
If you were to omit the outer `div` in the above example it would look broken. Actually, hot code
reload is working, but the UI refresh isn't.

You can force React to re-render the entire UI (Fulcro optimizes away refresh when the app state hasn't changed).
The trick here is to change the React key on the root element (which forces React to throw away the prior tree
and generate a whole new one). Fulcro helps by sending your root component a property named `:ui/react-key` that
only changes on (re)mount and forced refresh.

Try editing the UI of `Person` and save. You should see the UI update even though the person's data didn't change.

=== Composing

You should already be getting the picture that your UI is going to be a tree composed from a root element. The
method of data passing (via props) should also be giving you the picture that supplying data to your UI (through root)
means you need to supply an equivalently structured tree of data. This is true of basic React.
However, just to drive the point home let's make a slightly more complex UI and see it in detail:

Replace your content with this:

```
(defsc Person [this {:keys [person/name person/age]}]
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")"))))

(def ui-person (prim/factory Person {:keyfn :person/name}))

(defsc PersonList [this {:keys [person-list/label person-list/people]}]
  (dom/div nil
    (dom/h4 nil label)
    (dom/ul nil
      (map ui-person people))))

(def ui-person-list (prim/factory PersonList))

(defsc Root [this {:keys [ui/react-key]}]
  (let [ui-data {:friends {:person-list/label "Friends" :person-list/people
                                              [{:person/name "Sally" :person/age 32}
                                               {:person/name "Joe" :person/age 22}]}
                 :enemies {:person-list/label "Enemies" :person-list/people
                                              [{:person/name "Fred" :person/age 11}
                                               {:person/name "Bobby" :person/age 55}]}}]
    (dom/div #js {:key react-key}
      (ui-person-list (:friends ui-data))
      (ui-person-list (:enemies ui-data)))))
```

So that the UI graph looks like this:

[ditaa,target=ui-graph]
----
      +--------+
      |  Root  |
      ++-----+-+
       |     |
 +-----+--+ ++-------+
 |  List  | |  List  |
 +---+----+ +----+---+
     |           |
 +---+----+ +----+---+
 | Person | | Person |
 |--------| |--------|
 | Person | | Person |
 +--------+ +--------+
----

and the data graph matches the same structure, with map keys acting as the graph "edges":

```
{ :friends           { :person-list/people [PERSON ...]
;  ==to-one list=>      ==to-many people==>
  :enemies           { :person-list/people [PERSON ...] }
```

[ditaa,target=data-tree]
----
      +--------+
      |  Root  |
      ++-----+-+
enemies|     |friends
 +-----+--+ ++-------+
 |  List  | |  List  |
 +---+----+ +----+---+
     |people     |people
 +---+----+ +----+---+
 | Person | | Person | 0
 |--------| |--------|
 | Person | | Person | 1
 +--------+ +--------+
----

== Feeding the Data Tree

Obviously it isn't going to be desirable to hand-manage this very well for anything
but the most trivial application (which is the crux of the problems with most UI libraries).

At best it does give us a persistent data structure that represents the
current "view" of the application (which has many benefits), but at worst it requires us to "think globally"
about our application. We want local reasoning. We also want to be able to easily re-compose our UI as needed,
and a static data graph like this would have to be updated every time we made a change! Almost equally as bad: if
two different parts of our UI want to show the same data then we'd have to find and update a bunch of copies
spread all over the data tree.

So, how do we solve this?

=== Why not have components just "grab" their data (sideband)?

This is certainly a possibility; however, it leads to other complications. What is the data model? How do you
interact with remotes to fill your data needs? Fulcro has a very nice cohesive story for these questions,
while other systems end up with complications like event handler middleware, coeffect accretion,
and signal graphs...not to mention that the sideband solution says nothing definitive about how you actually
*accomplish* the server interactions with said data model.

Fulcro has a model for all of this, and it is surprising how simple it makes your application once you
put your appliation together.  Let's look at the steps and parts:

=== Step 1 -- The Initial State

All applications have some starting initial state. Since our UI is a tree, our starting state needs to
somehow establish what goes to the initial nodes.

In Fulcro, there is a way to construct the initial tree of data in a way that allows for local reasoning and
easy refactoring: co-locate the initial desired part of the tree with the component that uses it. This allows
you to compose the state tree in exactly the same way as the UI tree.

The `defsc` macro makes short work of this with the `initial-state` option. Simply give it a
lambda that gets parameters (optionally from the parent) and returns a map representing the state of the component.
You can retrieve this data using `(prim/get-initial-state Component)`.

It looks like this:

```
(ns app.ui.root
  (:require
    translations.es
    [fulcro.client.dom :as dom]
    [fulcro.client.primitives :as prim :refer [defsc]]))

(defsc Person [this {:keys [person/name person/age]}]
  { :initial-state (fn [{:keys [name age] :as params}] {:person/name name :person/age age}) }
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")"))))

(def ui-person (prim/factory Person {:keyfn :person/name}))

(defsc PersonList [this {:keys [person-list/label person-list/people]}]
  {:initial-state
   (fn [{:keys [label]}]
     {:person-list/label  label
      :person-list/people (if (= label "Friends")
                            [(prim/get-initial-state Person {:name "Sally" :age 32})
                             (prim/get-initial-state Person {:name "Joe" :age 22})]
                            [(prim/get-initial-state Person {:name "Fred" :age 11})
                             (prim/get-initial-state Person {:name "Bobby" :age 55})])})}
   (dom/div nil
     (dom/h4 nil label)
     (dom/ul nil
       (map ui-person people))))

(def ui-person-list (prim/factory PersonList))

; Root's initial state becomes the entire app's initial state!
(defsc Root [this {:keys [ui/react-key friends enemies]}]
  {:initial-state (fn [params] {:friends (prim/get-initial-state PersonList {:label "Friends"})
                                :enemies (prim/get-initial-state PersonList {:label "Enemies"})}) }
  (dom/div #js {:key react-key}
    (ui-person-list friends)
    (ui-person-list enemies)))
```

NOTE: You *must* reload your browser for this to show up. Fulcro pulls this data into the database when the
application *first mounts*, not on hot code reload (because that would change your app state, and hot
code reload is more useful without state changes).

Now a lot of the specific data here is just for demonstration purposes. Data like this (people) would almost
certainly come from a server, but it serves to illustrate that we can localize the initial data needs of a
component to the component, and then compose that into the parent in an abstract way
(by calling `get-initial-state` against that child).

There are several benefits of this so far:

. It generates the exact tree of data needed to feed the initial UI.
. That initial state becomes your initial application database.
. It restores local reasoning (and easy refactoring). Moving a component just means local reasoning about the
component being moved and the component it is being moved from/to: You remove the `get-initial-state` from one
parent and add it to a different one.

You can see that there is no magic if you just pull the initial tree at the REPL:

----
dev:cljs.user=> (fulcro.client.primitives/get-initial-state app.ui.root/Root {})
{:friends
 {:person-list/label "Friends",
  :person-list/people
  [{:person/name "Sally", :person/age 32}
   {:person/name "Joe", :person/age 22}]},
 :enemies
 {:person-list/label "Enemies",
  :person-list/people
  [{:person/name "Fred", :person/age 11}
   {:person/name "Bobby", :person/age 55}]}}
----

It's nothing more than function composition. The initial state option on `defsc` encodes your initial state
into a function that can be accessed via `get-initial-state` on a class.

So behind the scenes Fulcro detects the initial state on the first mount and automatically uses it to initialize your
application state.

By default, the entire initial state database is passed into your root node on render, so it is
available for destructuring in Root's props.

If you even want to see your current application state, you can do so through the atom that is holding
your mounted application:

[source]
----
dev:cljs.user=> @(fulcro.client.primitives/app-state (get @app.client/app :reconciler))
----

Let's see how we program our UI to access the data in the application state!

=== Step 2 -- Establishing a Query

Fulcro unifies the data access story using a co-located query on each component. This sets up data access
for both the client and server, and also continues our story of local reasoning and composition.

Queries go on a component in the same way as initial state: as `static` implementations of a protocol.

The query notation is relatively light, and we'll just concentrate on two bits of query syntax: props and joins.

Queries form a tree just like the UI and data. Obtaining a value at the current node in the tree traversal is done
using the keyword for that value. Walking down the graph (a join) is represented as a map with a single entry whose
key is the keyword for that nested bit of state.

So, a data tree like this:

```
{:friends
 {:person-list/label "Friends",
  :person-list/people
  [{:person/name "Sally", :person/age 32}
   {:person/name "Joe", :person/age 22}]},
 :enemies
 {:person-list/label "Enemies",
  :person-list/people
  [{:person/name "Fred", :person/age 11}
   {:person/name "Bobby", :person/age 55}]}}
```

would have a query that looks like this:

```
[{:friends  ; JOIN
    [ :person-list/label
      {:person-list/people ; JOIN
         [:person/name :person/age]}]}]
```

This query reads "At the root you'll find `:friends`, which joins to a nested entity that has a label and people,
which in turn has nested properties name and age.

- A vector always means "get this stuff at the current node"
- `:friends` is a key in a map, so at the root of the application state the query engine would expect to find that
key, and would expect the value to be nested state (because maps mean joins on the tree)
- The value in the `:friends` join must be a vector, because we have to indicate what we want out of the nested data.

Joins are automatically `to-one` if the data found in the state is a map, and `to-many` if the data found is a
vector. In the example above the `:friends` field from root pointed to a single `PersonList`, whereas the `PersonList`
field `:person-list/people` pointed to a vector of `Person`.  Be care that you don't confuse yourself with
naming (e.g. friends is plural, but points to a single list).

The namespacing of keywords in your data (and therefore your query) is highly encouraged, as it makes it clear to the
reader what kind of entity you're working against (it also ensures that over-rendering doesn't happen on
refreshes later).

You can try this query stuff out in your REPL. Let's say you just want the friends list label. The function
`db->tree` can take an application database (which we can generate from initial state) and run a query
against it:

[source]
----
dev:cljs.user=> (fulcro.client.primitives/db->tree [{:friends [:person-list/label]}] (fulcro.client.primitives/get-initial-state app.ui.root/Root {}) {})
{:friends {:person-list/label "Friends"}}
----

HINT: The mirror of initial state with query is a great way to error-check your work (and `defsc` does some of that
for you): For each scalar property in
initial state, there should be an identical simple property in your query. For each join of initial state to a child via
`get-initial-state` there should be a query join via `get-query` to that same child.

==== Adding Queries to Our Example

We want our queries to have the same nice local-reasoning as our initial data tree. The `get-query` function
works just like the `get-initial-state` function, and can pull the query from a component. In this case, you
should *not* ever call `query` directly. The `get-query` function augments the subqueries with metadata that is
important at a later stage.

So, the `Person` component queries for just the properties it needs:

```
(defsc Person [this {:keys [person/name person/age]}]
  {:query         [:person/name :person/age]
   :initial-state (fn [{:keys [name age] :as params}] {:person/name name :person/age age})}
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")"))))
```

Notice that the entire rest of the component *did not* change.

Next up the chain, we compose the `Person` query into `PersonList` (notice how the composition of state and query
are mirrored):

```
(defsc PersonList [this {:keys [person-list/label person-list/people]}]
  {:query [:person-list/label {:person-list/people (prim/get-query Person)}]
   :initial-state
          (fn [{:keys [label]}]
            {:person-list/label  label
             :person-list/people (if (= label "Friends")
                                   [(prim/get-initial-state Person {:name "Sally" :age 32})
                                    (prim/get-initial-state Person {:name "Joe" :age 22})]
                                   [(prim/get-initial-state Person {:name "Fred" :age 11})
                                    (prim/get-initial-state Person {:name "Bobby" :age 55})])})}
  (dom/div nil
    (dom/h4 nil label)
    (dom/ul nil
      (map ui-person people))))
```

again, nothing else changes.

=== Step 3 -- Receive the Data Feed as Props in Root

Finally, we compose to `Root`:

```
(defsc Root [this {:keys [ui/react-key friends enemies]}]
  {:query         [:ui/react-key {:friends (prim/get-query PersonList)}
                   {:enemies (prim/get-query PersonList)}]
   :initial-state (fn [params] {:friends (prim/get-initial-state PersonList {:label "Friends"})
                                :enemies (prim/get-initial-state PersonList {:label "Enemies"})})}
  (dom/div #js {:key react-key}
    (ui-person-list friends)
    (ui-person-list enemies)))
```

This all looks like a minor (and useless) change. The operation is the same; however, we're getting close to
the magic, so stick with us. The major difference in this code is that even though the database *starts
out* with the initial state, there is nothing to say we have to query for everything that is in there,
or that the state has to start out with everything we might query for in the future. We're getting
close to having a dynamic data-driven application.

Notice that everything we've done so far has *global client database* implications, but that each component
codes only the portion it is concerned with. Local reasoning is maintained. All software evolution in
this model preserves this critical aspect.

Also, you now have application state that can evolve (the query is running against the active application
database stored in an atom)!

IMPORTANT: You should always think of the query as "running from root". You'll
notice that `Root` still expects to receive the *entire* data tree for the UI (even though it doesn't have to
know much about what is in it, other than the names of direct children), and it still picks out those sub-trees
of data and passes them on. In this way an arbitrary component in the UI tree is not querying
for it's data directly in a side-band sort of way, but is instead being composed in from parent to parent all the
way to the root. Later, we'll learn how Fulcro can optimize this and pull the data from the database for
a specific component, but the reasoning will remain the same.

== Passing Callbacks and Other Parent-computed Data

The queries on component describe what data the component wants from the database; however, you're not allowed
to put code in the database, and sometimes a parent might compute something it needs to pass to a child like
a callback function.

It turns out that we *can* optimize away the refresh of components (if their data has not changed). This
means that we can use a component's query to directly re-supply data for refresh; however, since doing so
skips the rendering of the parent, if we are not careful this can lead to "losing" these extra bits of
computationally generated data passed *from* the parent, like callbacks.

Let's say we want to render a delete button on our individual people in our UI. This button will mean
"remove the person from this list"...but the person itself has no idea which list it is in. Thus,
the parent will need to pass in a function that the child can call to affect the delete properly:

=== The Incorrect Way:

```
(defsc Person [this {:keys [person/name person/age onDelete]}] ; <3>
  {:query         (fn [] [:person/name :person/age])
   :initial-state (fn [{:keys [name age] :as params}] {:person/name name :person/age age})}
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")") (dom/button #js {:onClick #(onDelete name)} "X")))) ; <4>

(def ui-person (prim/factory Person {:keyfn :person/name}))

(defsc PersonList [this {:keys [person-list/label person-list/people]}]
  {:query [:person-list/label {:person-list/people (prim/get-query Person)}]
   :initial-state
          (fn [{:keys [label]}]
            {:person-list/label  label
             :person-list/people (if (= label "Friends")
                                   [(prim/get-initial-state Person {:name "Sally" :age 32})
                                    (prim/get-initial-state Person {:name "Joe" :age 22})]
                                   [(prim/get-initial-state Person {:name "Fred" :age 11})
                                    (prim/get-initial-state Person {:name "Bobby" :age 55})])})}
  (let [delete-person (fn [name] (println label "asked to delete" name))]  ; <1>
    (dom/div nil
      (dom/h4 nil label)
      (dom/ul nil
        (map (fn [p] (ui-person (assoc p :onDelete delete-person))) people))))) ;; <2>
```

<1> A function acting in as a stand-in for our real delete
<2> Adding the callback into the props (WRONG)
<3> Pulling the onDelete from the passed props (WRONG). The query has to be changed to a lambda to turn off error checking to even try this method.
<4> Invoking the callback when delete is pressed.

This method of passing a callback will work initially, but not consistently. The problem is that we can optimize away a
re-render of a parent when it can figure out how to pull just the data of the child on a refresh, and in that case the
callback will get lost because only the database data will get supplied to the child! Your delete button will work
on the initial render (from root), but may stop working at a later time after a UI refresh.

=== The Correct Way:

There is a special helper function that can record the computed data like callbacks onto the child that receives them
such that an optimized refresh will still know them. There is also an additional (optional) component parameter to `defsc`
that you can use to deconstruct them:

```
(defsc Person [this {:keys [person/name person/age]} {:keys [onDelete]}]
  {:query         [:person/name :person/age]
   :initial-state (fn [{:keys [name age] :as params}] {:person/name name :person/age age})}
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")") (dom/button #js {:onClick #(onDelete name)} "X")))) ; <4>

(def ui-person (prim/factory Person {:keyfn :person/name}))

(defsc PersonList [this {:keys [person-list/label person-list/people]}] ; <2>
  {:query [:person-list/label {:person-list/people (prim/get-query Person)}]
   :initial-state
          (fn [{:keys [label]}]
            {:person-list/label  label
             :person-list/people (if (= label "Friends")
                                   [(prim/get-initial-state Person {:name "Sally" :age 32})
                                    (prim/get-initial-state Person {:name "Joe" :age 22})]
                                   [(prim/get-initial-state Person {:name "Fred" :age 11})
                                    (prim/get-initial-state Person {:name "Bobby" :age 55})])})}
  (let [delete-person (fn [name] (println label "asked to delete" name))] ; <1>
    (dom/div nil
      (dom/h4 nil label)
      (dom/ul nil
        (map (fn [p] (ui-person (prim/computed p {:onDelete delete-person}))) people))))) ; <1>
```

<1> The `prim/computed` function is used to add the computed data to the props being passed.
<2> The child adds an additional parameter, and pulls the computed data from there. You can also
use `(prim/get-computed this)` to pull all of the computed props in the body.

Now you can be sure that your callbacks (or other parent-computed data) won't be lost to render optimizations.

==  Updating the Data Tree

Now the real fun begins: Making things dynamic.

In general you don't have to think about how the UI updates, because most changes are run within the
context that needs refreshed. But for general knowledge UI Refresh is triggered in two ways:

- Running a data modification transaction on a component (which will re-render the subtree of that component), and
refresh only the DOM for those bits that had actual changes.
- Telling Fulcro that some specific data changed (e.g. `:person/name`).

The former is most common, but the latter is often needed when a change executed in one part of the application
modifies data that some UI component elsewhere in the tree needs to respond to.

So, if we run the code that affects changes from the component that will need to refresh (a very common case) we're
covered. If a child needs to make a change that will affect a parent (as in our earlier example), then the
modification should run from the parent via a callback so that refresh will not require further interaction. Later we'll
show you how to deal with refreshes that could be in far-flung parts of the UI. First, let's get some data
changing.

=== Transactions [[Transactions]]

Every change to the application database must go through a transaction processing system. This has two
goals:

- Abstract the operation (like a function)
- Treat the operation like data (which allows us to generalize it to remote interactions)

The operations are written as quoted data structures. Specifically as a vector of mutation
invocations. The entire transaction is just data. It is *not* something run in the UI, but instead
passed into the underlying system for processing.

You essentially just "make up" names for the operations you'd like to do to your database, just like
function names. Namespacing is encouraged, and of course syntax quoting honors namespace aliases.

```
(prim/transact! this `[(ops/delete-person {:list-name "Friends" :person "Fred"})])
```

is asking the underlying system to run the mutation `ops/delete-person` (where ops can be an alias established
in the `ns`). Of course, you'll typically use unquote to embed data from local variables:

```
(prim/transact! this `[(ops/delete-person {:list-name ~name :person ~person})])
```

=== Handling Mutations

When a transaction runs in Fulcro it passes things off to a multimethod. The multi-method is described in more
detail in the section on <<MutationMultimethod,the mutation multimethod>>, but Fulcro provides a macro that makes
building (and using) mutations easier: `defmutation`.

The template application comes with a pre-built namespace for these `src/main/app/api/mutations.cljs`, but you can put them anywhere as long
as the namespace in question is required by your application at runtime. Note there is also a `mutations.clj`, which is
for the server-side handling of these same mutations.

A mutation looks a bit like a method. It can have a docstring, and the argument list will always receive a
single argument (params) that will be a map (which then allows destructuring).

The body looks a bit like a `letfn`, but the names we use for these methods are pre-established. The one
we're interested in at the moment is `action`, which is what to do *locally*. The `action` method will be
passed the application database's app-state atom, and it should change the data in that atom to reflect
the new "state of the world" indicated by the mutation.

For example, `delete-person` must find the list of people on the list in question, and filter out the one
that we're deleting:

```
(ns app.api.mutations
  (:require [fulcro.client.mutations :as m :refer [defmutation]]))

(defmutation delete-person
  "Mutation: Delete the person with name from the list with list-name"
  [{:keys [list-name name]}] ; <1>
  (action [{:keys [state]}] ; <2>
    (let [path     (if (= "Friends" list-name)
                     [:friends :person-list/people]
                     [:enemies :person-list/people])
          old-list (get-in @state path)
          new-list (vec (filter #(not= (:person/name %) name) old-list))]
      (swap! state assoc-in path new-list))))
```

<1> The argument list for the mutation itself
<2> The thing to do, which receives the app-state atom as an argument.

Then all that remains is to change `basic-ui` in the following ways:

1. Add a require and alias for app.operations to the ns
2. Change the callback to run the transaction

```
(ns app.basic-ui
  (:require [fulcro.client :as fc]
            [fulcro.client.dom :as dom]
            ; ADD THIS:
            [app.api.mutations :as api] ; <1>
            [fulcro.client.primitives :as prim :refer [defui defsc]]))

...

(defsc PersonList [this {:keys [person-list/label person-list/people]}]
  ...
  (let [delete-person (fn [name] (prim/transact! this `[(api/delete-person {:list-name ~label :name ~name})]))] ; <2>
  ...
```

<1> The require ensures that the mutations are loaded, and also gives us an alias to the namespace of the mutation's symbol.
<2> Running the transaction in the callback.

Note that our mutation's symbol is actually `app.api.mutations/delete-person`, but the syntax quoting will fix it.
Also realize that the mutation is *not* running in the UI, it is instead being handled "behind the scenes". This
allows a snapshot of the state history to be kept, and also a more seamless integration to full-stack operation
over a network to a server (in fact, the UI code here is *already* full-stack capable *without any changes*!).

This is where the power starts to show: all of the minutiae above is leading us to some grand unifications when
it comes to writing full-stack applications.

=== Hold on – This Sucks!

But first, we should address a problem that many of you may have already noticed: The mutation code is tied to
the shape of the UI tree!!!

This breaks our lovely model in several ways:

1. We can't refactor our UI without also rewriting the mutations (since the data tree would change shape)
2. We can't locally reason about any data. Our mutations have to understand things globally!
3. Our mutations could get rather large and ugly as our UI gets big
4. If a fact appears in more than one place in the UI and data tree, then we'll have to update *all* of them
in order for things to be correct. Data duplication is never your friend.

== The Secret Sauce – Normalizing the Database

Fortunately, we have a very good solution to the mutation problem above, and it is one that has been around for decades:
database normalization!

Here's what we're going to do:

Each UI component represents some conceptual entity with data (assuming it has state and a query). In a fully
normalized database, each such concept would have its own table, and related things would refer to it
through some kind of foreign key. In SQL land this looks like:

[ditaa, target=sql-norm]
----
                                 +-------------------------------------+
                                 |                                     |
PersonList                       |     Person                          |
+---------------------------+    |     +----------------------------+  |
| ID  | Label               |    |     |ID | Name         | List ID |  |
|---------------------------|    |     |----------------------------|  |
| 1   | Friends             |<---+     |1  | Joe          |    1    |--+
+---------------------------+          |----------------------------|  |
                                       |2  | Sally        |    1    |--+
                                       +----------------------------+
----

In a graph database (like Datomic) a reference can have a to-many arity, so the direction can be more natural:

[ditaa, target=datomic-norm]
----
PersonList                             Person
+---------------------------+          +------------------+
| ID  | Label   | People    |          |ID | Name         |
|---------------------------|          |------------------|
| 1   | Friends | #{1,2}    |----+---->|1  | Joe          |
+---------------------------+    |     |------------------|
                                 +---->|2  | Sally        |
                                       +------------------+
----

Since we're storing things in a map, we can represent "tables" as an entry in the map where the key is the
table name, and the value is a map from ID to entity value. So, the last diagram could be represented as:

```
{ :PersonList { 1  { :label "Friends"
                     :people #{1, 2} }}
  :Person { 1 {:id 1 :name "Joe" }
            2 {:id 2 :name "Sally"}}}
```

This is close, but not quite good enough. The set in `:person-list/people` is a problem. There is no schema, so there is no
way to know what kind of thing "1" and "2" are!

The solution is rather easy: code the foreign reference to *include* the name of the table (is a single such
"pointer", and to-many relations
store many such "pointers" in a vector (so you end up with a doubly-nested vector)):

```
{ :PersonList { 1  { :label "Friends"
                     :people [ [:Person 1] [:Person 2] ] }}
  :Person { 1 {:id 1 :name "Joe" }
            2 {:id 2 :name "Sally"}}}
```

A foreign key as a vector pair of `[TABLE ID]` is known as an `Ident`.

So, now that we have the concept and implementation, let's talk about conventions:

1. Properties are usually namespaced (as shown in earlier examples)
2. Table names are usually namespaced with the entity type, and given a name that indicates how it is indexed.
For example: `:person/by-id`, `:person-list/by-name`, etc. If you use Clojure spec, you may choose to
alter this a bit for convenience in namespace-aliasing keywords (e.g. `::my-db-schema/person-by-id`).

=== Automatic Normalization

Fortunately, you don't have to hand-normalize your data. The components have almost everything they need to
do it for you, other than the actual value of the `Ident`. So, we'll add one more option to your components
(and we'll add IDs to the data at this point, for easier implementation):

The program will now look like this:

```
(ns app.ui.root
  (:require
    translations.es
    [fulcro.client.dom :as dom]
    [app.api.mutations :as api]
    [fulcro.client.primitives :as prim :refer [defsc]]))

(defsc Person [this {:keys [db/id person/name person/age]} {:keys [onDelete]}]
  {:query         [:db/id :person/name :person/age] ; <2>
   :ident         [:person/by-id :db/id] ; <1>
   :initial-state (fn [{:keys [id name age]}] {:db/id id :person/name name :person/age age})} ; <3>
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")") (dom/button #js {:onClick #(onDelete id)} "X")))) ; <4>

(def ui-person (prim/factory Person {:keyfn :person/name}))

(defsc PersonList [this {:keys [db/id person-list/label person-list/people]}]
  {:query [:db/id :person-list/label {:person-list/people (prim/get-query Person)}]
   :ident [:person-list/by-id :db/id] ; <5>
   :initial-state
          (fn [{:keys [id label]}]
            {:db/id              id
             :person-list/label  label
             :person-list/people (if (= label "Friends")
                                   [(prim/get-initial-state Person {:id 1 :name "Sally" :age 32})
                                    (prim/get-initial-state Person {:id 2 :name "Joe" :age 22})]
                                   [(prim/get-initial-state Person {:id 3 :name "Fred" :age 11})
                                    (prim/get-initial-state Person {:id 4 :name "Bobby" :age 55})])})}
  (let [delete-person (fn [person-id] (prim/transact! this `[(api/delete-person {:list-id ~id :person-id ~person-id})]))] ; <4>
    (dom/div nil
      (dom/h4 nil label)
      (dom/ul nil
        (map (fn [p] (ui-person (prim/computed p {:onDelete delete-person}))) people)))))

(def ui-person-list (prim/factory PersonList))

(defsc Root [this {:keys [ui/react-key friends enemies]}]
  {:query         [:ui/react-key {:friends (prim/get-query PersonList)}
                   {:enemies (prim/get-query PersonList)}]
   :initial-state (fn [params] {:friends (prim/get-initial-state PersonList {:id :friends :label "Friends"})
                                :enemies (prim/get-initial-state PersonList {:id :enemies :label "Enemies"})})}
  (dom/div #js {:key react-key}
    (ui-person-list friends)
    (ui-person-list enemies)))
```

<1> Adding an ident allows Fulcro to know how to build a FK reference to a person (given its props). The first element is the table name, the second is the name of the property that
contains the ID of the entity.
<2> We will be using IDs now, so we need to add `:db/id` to the query (and props destructuring). This is just a convention for the ID attribute
<3> The state of the entity will also need the ID
<4> The callback can now delete people by their ID, which is more reliable.
<5> The list will have an ID, and an Ident as well

If you reload the web page (needed to reinitialize the database state), then you can look at the newly normalized
database at the REPL:

----
dev:cljs.user=> @(fulcro.client.primitives/app-state (-> app.client/app deref :reconciler))
{:friends [:person-list/by-id :friends],
 :enemies [:person-list/by-id :enemies],
 :person/by-id
 {1 {:db/id 1, :person/name "Sally", :person/age 32},
  2 {:db/id 2, :person/name "Joe", :person/age 22},
  3 {:db/id 3, :person/name "Fred", :person/age 11},
  4 {:db/id 4, :person/name "Bobby", :person/age 55}},
 :person-list/by-id
 {:friends
  {:db/id :friends,
   :person-list/label "Friends",
   :person-list/people [[:person/by-id 1] [:person/by-id 2]]},
  :enemies
  {:db/id :enemies,
   :person-list/label "Enemies",
   :person-list/people [[:person/by-id 3] [:person/by-id 4]]}}}
----

Note that `db->tree` understands this normalized form, and can convert it (via a query)
to the proper data tree. `db->tree` (for legacy reasons) requires a way to resolve references (idents) and the
database. In Fulcro these are the same. So, try this at the REPL:

[source]
----
dev:cljs.user=> (def current-db @(fulcro.client.primitives/app-state (-> app.client/app deref :reconciler)))
dev:cljs.user=> (def root-query (fulcro.client.primitives/get-query app.ui.root/Root))
#'cljs.user/current-db
dev:cljs.user=> (fulcro.client.primitives/db->tree root-query current-db current-db)
{:friends
 {:db/id :friends,
  :person-list/label "Friends",
  :person-list/people
  [{:db/id 1, :person/name "Sally", :person/age 32}
   {:db/id 2, :person/name "Joe", :person/age 22}]},
 :enemies
 {:db/id :enemies,
  :person-list/label "Enemies",
  :person-list/people
  [{:db/id 3, :person/name "Fred", :person/age 11}
   {:db/id 4, :person/name "Bobby", :person/age 55}]}}
----

=== Mutations on a Normalized Database

We have now made it possible to fix the problems with our mutation. Now, instead of removing
a person from a tree, we can remove a FK from a TABLE entry!

This is not only much easier to code, but it is completely independent of the shape of the UI tree:

```
(ns app.api.mutations
  (:require [fulcro.client.mutations :as m :refer [defmutation]]))

(defmutation delete-person
  "Mutation: Delete the person with name from the list with list-name"
  [{:keys [list-id person-id]}]
  (action [{:keys [state]}]
    (let [ident-to-remove [:person/by-id person-id] ; <1>
          strip-fk (fn [old-fks]
                     (vec (filter #(not= ident-to-remove %) old-fks)))] ; <2>
      (swap! state update-in [:person-list/by-id list-id :person-list/people] strip-fk)))) ; <3>
```

<1> References are always idents, meaning we know the value to remove from the FK list
<2> By defining a function that can filter the ident from (1), we can use update-in on the person list table's people.
<3> This is a very typical operation in a mutation: swap on the application state, and update a particular thing
in a table (in this case the people to-many ref in a specific person list).

If we were to now wrap the person list in any amount of additional UI (e.g. a nav bar, sub-pane, modal dialog, etc) this
mutation will still work perfectly, since the list itself will only have one place it ever lives in the
database.

=== How Automatic Normalization Works (optional)

It is good to know how an arbitrary tree of data (the one in InitialAppState) can be converted to the normalized form.
Understanding how this is accomplished can help you avoid some mistakes later.

When you compose your query (via `prim/get-query`), the `get-query` function adds metadata to the query fragment that
names which component that query fragment came from.

For example, try this at the REPL:

----
dev:cljs.user=> (meta (fulcro.client.primitives/get-query app.basic-ui/PersonList))
{:component app.basic-ui/PersonList}
----

The `get-query` function adds the component itself to the metadata for that query fragment. We already know that
we can call the static methods on a component (in this case we're interested in `ident`).

So, Fulcro includes a function called `tree->db` that can simultaneously walk a data tree (in this case initial-state) and a
component-annotated query. When it reaches a data node whose query metadata names a component with an `Ident`, it
places that data into the approprite table (by calling your `ident` function on it to obtain the table/id), and
replaces the data in the tree with its FK ident.

Once you realize that the query *and* the ident work together to do normalization, you can more easily
figure out what mistakes you might make that could cause auto-normalization to fail (e.g. stealing a query from
one component and placing it on another, writing the query of a sub-component by-hand instead of pulling it
with `get-query`, etc.).

== Review So Far

* An Initial app state sets up a tree of data for startup to match the UI tree
* Component query and ident are used to normalize this initial data into the database
* The query is used to pull data from the normalized db into the props of the active Root UI
* Transactions invoke abstract mutations
** Mutations modify the (normalized) db
** The transaction's subtree of components re-renders

== Using Better Tools

So far we've been hacking things in place and using the REPL to watch what we're doing. There are better ways to work
on Fulcro applications, and now that we've got one basically working, let's take a look at them both.

=== Fulcro Inspect

A relatively recent (late 2017) addition to the ecosystem is Fucro Inspect. A set of tools you can load into your
environment during development. In fact, the template already has them (for the `dev` build)! On OSX or Linux, simply hit
`CTRL-F`.  See Fulcro Inspect's documentation for how to set the keyboard shortcut in Windows.

The DB tab of this tool shows you your application's database *and* has a time slider to see the history of states! It also
has tabs for showing you transactions that have run, and network interactions. See the tool's documentation for more
information. In fact, by the time you read this it will probably have even more exciting features!

=== Dev Cards

There is a build in the template project called `cards`. This starts up a development environment where you can
code entire applications (or portions of them) in an environment that can show you live state and is quite handy, particularly
for working with small parts of your program (remember, we can actually split off chunks of the application because they
are all relative to their parent).

You can start this build just as we did near the start of this guide, and load it via `http://localhost:3449/cards.html`.

In fact, you don't even have to start a new REPL! You can run `switch-to-build`:

```
dev:cljs.user=> (switch-to-build "cards" "dev")
Figwheel: Watching build - cards
Figwheel: Cleaning build - cards
Compiling "resources/public/js/cards.js" from ["src/main" "src/cards"]...
```

Then you can embed a full-funcional Fulcro application into a card environment with very little code. Replace the
content of `src/cards/app/intro.cljs` with:

```
(ns app.intro
  (:require [fulcro.client.cards :refer [defcard-fulcro]]
            [app.ui.root :as root]))

(defcard-fulcro sample-app
  root/Root
  {}
  {:inspect-data true})
```

save and go to http://localhost:3449/cards.html#!/app.intro. You should see your app running in a card, and
you should be able to see the live database (which will change as you interact)!.

== Going Remote!

OK, back to the main story!

Believe it or not, there's not much to add/change on the client to get it talking
to a server, and there is also a relatively painless way to get a server up and
running.

Your template already has one :)

=== Setting up a Server

There are two server namespaces in Fulcro: `fulcro.server` and
`fulcro.easy-server`. The former has composable bits for making a server that
has a lot of your own extensions, while the latter is a pre-baked server that covers
many of the common bases and is less work to get started with. You can always get started with the easy one, and upgrade
to a more enhanced one later.

The template generates the easy one for you in `src/main/app/server.clj`.

==== Using the Easy Server

The easy server is based upon the component system. It is set up so that it can be stopped, code refreshed,
and restarted very quickly. The management functions are already written in `src/dev/user.clj` underneath
the Figwheel startup code.

The server code itself is very light:

```
(ns app.server
  (:require
    [fulcro.easy-server :refer [make-fulcro-server]]
    ; MUST require these, or you won't get them installed.
    [app.api.read]
    [app.api.mutations]))

(defn build-server
  [{:keys [config] :or {config "config/dev.edn"}}]
  (make-fulcro-server
    :parser-injections #{:config}
    :config-path config))
```

The `make-fulcro-server` function needs to know where to find the server config file. You can tell it a number
of other things, including which components you'd like to be available when parsing the incoming
client requests. In the template, the only component available is the one that reads the application
config (which contains the port on which to run the web server).

The configuration is meant for production environments, and requires a default file that spells out
defaults in case the main config does not have values for them, and a primary config file that can
override any defaults.

Your template already has these in `src/main/config` (the config component looks for `defaults.edn` on the
CLASSPATH at relative location `config/`):

`defaults.edn`:

[source]
----
{:port 3000}
----

`dev.edn`:

[source]
----
{}
----

The first file is always looked for by the server, and should contain all of the default settings you think you
want independent of where the server is started.

The server (for safety reasons in production) will not start if there isn't a user-specified file containing potential
overrides.

Basically, it will deep-merge the two and have the latter override things in the former. This makes mistakes in
production harder to make. If you read the source of the `go` function in the `user.clj` file you'll see that
we supply this development config file as an argument. In production systems you'll typically want this file to be
on the filesystem when an admin can tweak it.

===== Starting the Server

If you now start a local Clojure REPL (with *no special options*), it should start in the `user` namespace.
You can kick off your own application's easy web server with:

[source]
----
user=> (go)
----

The console should tell you the URL, and if you browse there you should see your `index.html` file.

===== Server Refresh

When you add/change code on the server you will want to see those changes in the live server without having to restart
your REPL.

[source]
----
user=> (restart)
----

will do this.

If there are compiler errors, then the `user` namespace might not reload properly. In that case, you should be able
to recover using:

[source]
----
user=> (tools-ns/refresh)
user=> (go)
----

WARNING: Don't call refresh while the server is running. It will refresh the code, *but it will lose* the reference to
the running server, meaning you won't be able to stop it and free up the network port. If you do this, you'll have to
restart your REPL.

===== Serving your App

Figwheel comes with a server that we've been using to serve our client. When you want to build a full-stack app
*you must* serve your client from your own server. Thus, if you load your page with the figwheel server (which is still
available on an alternate port) you'll see your app, but the server interactions won't succeed.

One might ask: "If I don't use figwheel's server, do I lose hot code reload on the client?"

The answer is no. When figwheel compiles your application it embeds it's own websocket code in your application for
hot code reload. When you load that compiled code (in any way) it will try to connect to the figwheel websocket.

So your network topology was:

[ditaa,target=client-network-topo]
----
+----------+
| Browser  |                  +-------------------+
|  app     +-----+            |                   |
|          |     |            |  port 3449        |
+----------+     | http load  |  +-------------+  |
                 +----------->|  | Figwheel    |  |
                 |            |  |             |  |
                 +----------->|  |             |  |
                ws hot code   |  +-------------+  |
                              +-------------------+
----

where both the HTML/CSS/JS resources and the hot code were coming from different connections to the same server.

The networking picture during full-stack development just splits these like this:

[ditaa,target=network-topo]
----
                           localhost
                           +-------------------+
                           |                   |
                           |  port 3000        |
              app requests |  +-------------+  |
+----------+     +-------->|  |Your Server  |  |
| Browser  |     |         |  +-------------+  |
|  app     +-----+         |                   |
|          |     |         |  port 3449        |
+----------+     |         |  +-------------+  |
                 +-------->|  | Figwheel    |  |
             ws hot code   |  +-------------+  |
                           |                   |
                           +-------------------+
----

Fulcro's client will automatically route requests to the `/api` URI of the source URL that was used to load the page,
and Fulcro's server is built to watch for communications at this endpoint.

=== Setup for Playing with Loads

It is very handy to be able to look at your application's state to see what might be wrong. We've been manually
dumping application state at the REPL using a rather long expression. So, at this point make sure
you are either running your application in a devcard, or you know how to look at things with Fulcro
Inspect. The output in the devcards is typically easier for beginners to read.

=== Loading Data [[Loading]]

Now we will start to see more of the payoff of our UI co-located queries and auto-normalization. Our application
so far is quite unrealistic: the people we're showing should be coming from a server-side database, they
should not be embedded in the code of the client. Let's remedy that.

Fulcro provides a few mechanisms for loading data, but every possible load scenario can be done using
the `fulcro.client.data-fetch/load` function.

It is very important to remember that our application database is completely normalized, so anything we'd want to put
in that application state will be *at most* 3 levels deep (the table name, the ID of the thing in the table, and the
field within that thing). We've also seen that Fulcro can also auto-normalize complete trees of data,
and has graph queries that can be used to ask for those trees.

Thus, there really are not very many scenarios!

The three basic scenarios are:

* Load something into the root of the application state
* Load something into a particular field of an existing thing
* Load some pile of data, and shape it into the database (e.g. load all of the people, and then separate them into
a list of friends and enemies).

Let's try out these different scenarios with our application.

First, let's correct our application's initial state so that no people are there:

```
(defsc PersonList [this {:keys [db/id person-list/label person-list/people]}]
  {:query [:db/id :person-list/label {:person-list/people (prim/get-query Person)}]
   :ident [:person-list/by-id :db/id]
   :initial-state
          (fn [{:keys [id label]}]
            {:db/id              id
             :person-list/label  label
             :person-list/people []})} ; REMOVE THE INITIAL PEOPLE
  ...
```

If you now reload your page you should see two empty lists.

==== Normalization

When you load something you will use a query from something on your UI (it is rare to load something you don't want to
show). Since those components (should) have a query and ident, the result of a load can be sent from the server as a
tree, and the client can auto-normalize that tree just like it did for our initial state!

==== Loading something into the DB root

This case is less common, but it is a simple starting point. It is typically used to obtain something that you'd want
to access globally (e.g. the user info about the current session). Let's assume that our Person component represents
the same kind of data as the "logged in" user. Let's write a load that can ask the server for the "current user" and
store that in the root of our database under the key `:current-user`.

Loads, of course, can be triggered at any time (startup, event, timeout). Loading is just a function call.

For this example, let's trigger the load just after the application has started.

===== Triggering the Load

To do this, we can add an option to our client. In `app.client` change `app`:

```
(ns app.client
  (:require [fulcro.client :as fc]
            [fulcro.client.data-fetch :as df] ; <1>
            [app.ui.root :as root]))

(defonce app (atom (fc/new-fulcro-client
                     :started-callback
                     (fn [app]  ; <2>
                       (df/load app :current-user root/Person)))))
```

<1> Require the `data-fetch` namespace
<2> Issue the load in the application's `started-callback`

NOTE: *If you are using devcards* you will need to place the option for the application in the devcard's options
under the `:fulcro` key:

```
(ns app.intro
  (:require [fulcro.client.cards :refer [defcard-fulcro]]
            [app.ui.root :as root]
            [fulcro.client.data-fetch :as df]))

(defcard-fulcro sample-app
  root/Root
  {}
  {:inspect-data true
   :fulcro       {:started-callback
                  (fn [app] (df/load app :current-user root/Person))}})
```

Of course hot code reload does not restart the app (it just hot patches the code), so to see this load trigger we must
reload the browser page.

If you do that at the moment, you should see an error in the various consoles related to the failure of the load.

IMPORTANT: Make sure your application (or dev card) is running from *your* server (port 3000) and not the figwheel one!

Technically, `load` is just writing a query for you (in this case `[{:current-user (prim/get-query Person)}]`) and sending it to the
server. The server will receive *exactly* that query as a CLJ data structure.

===== Implementing the Server Handler

You now need to converting the raw CLJ query into a response. You can read more
about the gory details of that in the developer's guide; however, Fulcro's has some
helpers that make our job much easier.

The template has a spot to put your query handlers in `src/main/app/api/read.clj`.
Since we're on the server and we're going to be supplying and manipulating people, we'll just make a single atom-based
in-memory database. This could easily be stored in a database of any kind.
To handle the incoming "current user" request, we can use a macro to write the handler for us.
Change the file to look like this:

```
(ns app.api.read
  (:require
    [fulcro.server :refer [defquery-root defquery-entity defmutation]]))

(def people-db (atom {1  {:db/id 1 :person/name "Bert" :person/age 55 :person/relation :friend}
                      2  {:db/id 2 :person/name "Sally" :person/age 22 :person/relation :friend}
                      3  {:db/id 3 :person/name "Allie" :person/age 76 :person/relation :enemy}
                      4  {:db/id 4 :person/name "Zoe" :person/age 32 :person/relation :friend}
                      99 {:db/id 99 :person/name "Me" :person/role "admin"}}))

(defquery-root :current-user
  "Queries for the current user and returns it to the client"
  (value [env params]
    (get @people-db 99)))
```

This actually augments a multimethod, which means we need to make sure this namespace is loaded by our server. The
`user` namespace already does this. So, you should be able to simply restart/refresh the server at the SERVER REPL:

----
user=> (restart)
----

If you've done everything correctly, then reloading your application should successfully load your current user. You
can verify this by examining the network data, but it will be even more convincing if you look at your client database
via the dev card visualization on Fulcro Inspect. It should look something like this:

```
{:current-user         [:person/by-id 99]
 :person/by-id         {99 {:db/id 99 :person/name "Me" :person/role "admin"}}
 ...}
```

Notice that the top-level key is a normalized FK reference to the person, which has been placed into the correct database
table.

===== Using Data from Root

Of course, the question is now "how do I use that in some arbitrary component?" We won't completely
explore that right now, but the answer is easy: The query syntax has a notation for "query something at the root". It looks like this:
`[ {[:current-user '_] (prim/get-query Person)} ]`. You should recognize this as a query join, but on something that
looks like an ident without an ID (implying there is only one, at root).

We'll just use it on the Root UI node, where we don't need to "jump to the top":

```
(defsc Root [this {:keys [ui/react-key friends enemies current-user]}] ; <2>
  {:query         [:ui/react-key
                   {:current-user (prim/get-query Person)} ; <1>
                   {:friends (prim/get-query PersonList)}
                   {:enemies (prim/get-query PersonList)}]
   :initial-state (fn [params] {:friends (prim/get-initial-state PersonList {:id :friends :label "Friends"})
                                :enemies (prim/get-initial-state PersonList {:id :enemies :label "Enemies"})})}
  (dom/div #js {:key react-key}
    (dom/h4 nil (str "Current User: " (:person/name current-user))) ; <3>
    (ui-person-list friends)
    (ui-person-list enemies)))
```

<1> Add the current user to the query
<2> Pull of from the props
<3> Show something about it in the UI

==== Loading something that gets "added in" to an existing entity

The next common scenario is loading something into some other existing entity in your database. Remember that since
the database is normalized this will cover all of the other loading cases (except for the one where you want to convert
what the server tells you into a different shape (e.g. paginate, sort, etc.)).

Fulcro's load method accomplishes this by loading the data into the root of the database, normalizing it, then
(optionally) allowing you to re-target the top-level FK to different location(s) in the database.

===== Targeting the Load

The load looks very much like what we just did, but with one addition:

```
(df/load app :my-friends Person {:target [:person-list/by-id :friends :person-list/people]})
```

The `:target` option indicates that once the data is loaded and normalized (which will leave the FK reference
at the root as we saw in the last section) this top-level reference (or vector of references) will be moved into the key-path provided.
Since our database is normalized, this means a 3-tuple (table, id, target field).

WARNING: It is important to choose a keyword for this load that won't stomp on real data in your database's root.
We already have the top-level keys `:friends` and `:enemies` as part of our UI graph from root. So, we're making up
`:my-friends`  as the load key. One could also namespace the keyword with something like `:server/friends`.

Since friend and enemies are the same kind of query, let's add both into the startup code (in the card/client):

```
...
     :started-callback
     (fn [app]
       (df/load app :current-user root/Person)
       (df/load app :my-enemies root/Person {:target [:person-list/by-id :enemies :person-list/people]})
       (df/load app :my-friends root/Person {:target [:person-list/by-id :friends :person-list/people]}))
...
```

===== Handling the Load Request on the Server

The server query processing is what you would expect from the last example (in `read.clj`):

```
(def people-db ...) ; as before

(defn get-people [kind keys]
  (->> @people-db
    vals
    (filter #(= kind (:person/relation %)))
    vec))

(defquery-root :my-friends
  "Queries for friends and returns them to the client"
  (value [{:keys [query]} params]
    (get-people :friend query)))

(defquery-root :my-enemies
  "Queries for enemies and returns them to the client"
  (value [{:keys [query]} params]
    (get-people :enemy query)))
```

A refresh of the server and reload of the page should now populate your lists from the server!

----
user=> (restart)
----

==== Morphing the Loaded Data

It is somewhat common for a server to return data that isn't quite what we want in our UI. So far we've just been placing
the data returned from the server directly in our UI. Fulcro's load mechanism allows a post mutation of the loaded
data once it arrives, allowing you to re-shape it into whatever form you might desire.

For example, you may want the people in your lists to be sorted by name. You've already seen how to write client
mutations that modify the database, and that is really all you need. The client mutation for sorting the people
in the friends list could be (in `mutations.cljs`):


```
(defn sort-friends-by*
  "Sort the idents in the friends person list by the indicated field. Returns the new app-state."
  [state-map field]
  (let [friend-idents  (get-in state-map [:person-list/by-id :friends :person-list/people] [])
        friends        (map (fn [friend-ident] (get-in state-map friend-ident)) friend-idents)
        sorted-friends (sort-by field friends)
        new-idents     (mapv (fn [friend] [:person/by-id (:db/id friend)]) sorted-friends)]
    (assoc-in state-map [:person-list/by-id :friends :person-list/people] new-idents)))

(defmutation sort-friends [no-params]
  (action [{:keys [state]}]
    (swap! state sort-friends-by* :person/name)))
```

Of course this mutation could be triggered anywhere you could run a `transact!`, but since we're interested in morphing
just-loaded data, we'll add it there. Our dev card would now look like this:

```
(ns app.intro
  (:require [fulcro.client.cards :refer [defcard-fulcro]]
            [app.ui.root :as root]
            [fulcro.client.data-fetch :as df]
            [app.api.mutations :as api]))

(defcard-fulcro sample-app
  root/Root
  {}
  {:inspect-data true
   :fulcro       {:started-callback
                  (fn [app] (df/load app :current-user root/Person)
                    (df/load app :my-friends root/Person {:target        [:person-list/by-id :friends :person-list/people]
                                                          :post-mutation `api/sort-friends})
                    (df/load app :my-enemies root/Person {:target [:person-list/by-id :enemies :person-list/people]}))}})
```

Notice the syntax quoting. The post mutation has to be the *symbol* of the mutation. Remember that
our require has `app.api.mutations` aliased to `api`, and syntax quoting will expand that for us.

If you reload your UI you should now see the people sorted by name. Hopefully you can see how easy it is to change
this sort order to something like "by age". Try it!

==== Loading a specific entity and it's subgraph (by ident)

Once things are loaded from the server they are immediately growing stale (unless you're pushing updates with
websockets). It is very common to want to re-load a particular thing in your database. Of course, you can trigger
a load just like we've been doing, but in that case we reloading a whole bunch of things. What if we just wanted to
refresh a particular person (e.g. in preparation for editing it).

The `load` function can be used for that as well. Just replace the keyword with an ident, and you're there!

Load can take the `app` or any component's `this` as the first argument, so from within the UI we can trigger a load
using `this`:

```
(df/load this [:person/by-id 3] Person)
```

===== Trigger the Load via a User Event

Let's embed that into our UI at the root:

```
(defsc Root [this {:keys [ui/react-key friends enemies current-user]}]
  {:query         [:ui/react-key
                   {:current-user (prim/get-query Person)}
                   {:friends (prim/get-query PersonList)}
                   {:enemies (prim/get-query PersonList)}]
   :initial-state (fn [params] {:friends (prim/get-initial-state PersonList {:id :friends :label "Friends"})
                                :enemies (prim/get-initial-state PersonList {:id :enemies :label "Enemies"})})}
  (dom/div #js {:key react-key}
    (dom/h4 nil (str "Current User: " (:person/name current-user)))
    ; NEW BUTTON HERE:
    (dom/button #js {:onClick (fn [] (df/load this [:person/by-id 3] Person))} "Refresh Person with ID 3")
    (ui-person-list friends)
    (ui-person-list enemies)))
```

===== Handling an Entity Query on the Server

The incoming query will have a slightly different form, so there is an alternate macro for making a handler for entity
loading. Let's add this in our server's `read.clj`:

```
(defquery-entity :person/by-id
  "Server query for allowing the client to pull an individual person from the database"
  (value [env id params]
    ; the update is just so we can see it change in the UI
    (update (get @people-db id) :person/name str " (refreshed)")))
```

The `defquery-entity` takes the "table name" as the dispatch key. The `value` method of the query handler will receive
the server environment, the ID of the entity to load, and any parameters passed with the query (see the `:params` option
of `load`).

In the implementation above we're augmenting the person's name with "(refreshed)" so that you can see it happen in the UI.

Remember to `(restart)` your server to load this code.

Your UI should now have a button, and when you press it you should see one person update!

===== Refreshing "This"

There is a special case that is somewhat common: you want to trigger a refresh from an event on the item that needs
the refresh. The code for that is identical to what we've just presented (a load with an ident and component); however,
the `data-fetch` namespace includes a convenience function for it.

So, say we wanted a refresh button on each person. We could leverage `df/refresh` for that:

```
(defsc Person [this {:keys [db/id person/name person/age]} {:keys [onDelete]}]
  {:query         [:db/id :person/name :person/age]
   :ident         [:person/by-id :db/id]
   :initial-state (fn [{:keys [id name age]}] {:db/id id :person/name name :person/age age})}
  (dom/li nil
    (dom/h5 nil name (str "(age: " age ")")
      (dom/button #js {:onClick #(onDelete id)} "X")
      (dom/button #js {:onClick #(df/refresh! this)} "Refresh")))) ; ADD THIS
```

This should already work with your server, so once the browser hot code reload has happened this button should just work!

==== Additional Permutations

Fulcro's load system covers a number of additional bases that bring the story to completion. There are load markers
(so you can show network activity), UI refresh add-ons (when you modify data that isn't auto-detected, e.g. through a post
mutation), server query parameters, and error handling. See the Developers Guide, doc strings, or source for more details.

=== Handling Mutations on The Server

Mutations are handled on the server using the server's `defmutation` macro (if you're using Fulcro's built-in request parser).

This has the identical syntax to the client version!

IMPORTANT: You want to place your mutations in the same namespace on the client and server since the `defmutation`
macros namespace the symbol into the current namespace.

So, this is really why we have a duplicated namespace in Clojure called `mutations.clj` right
next to our `mutations.cljs`.

So, let's add an implementation for our server-side `delete-person`. Your `mutations.clj` should end
up looking like this (don't forget the require to get access to the people db):

```
(ns app.api.mutations
  (:require
    [taoensso.timbre :as timbre]
    [app.api.read :refer [people-db]]
    [fulcro.server :refer [defmutation]]))

;; Place your server mutations here
(defmutation delete-person
  "Server Mutation: Handles deleting a person on the server"
  [{:keys [person-id]}]
  (action [{:keys [state]}]
    (timbre/info "Server deleting person" person-id)
    (swap! people-db dissoc person-id)))
```

Refresh the code on your server with `(restart)` at the REPL. However, don't expect it to work just yet. We have
to tell the client to send the remote request.

==== Triggering the Remote Mutation from the Client

Mutations are simply optimistic local updates by default. To make them full-stack, you need to add a method-looking
section to your `defmutation` handler:

```
(defmutation delete-person
  "Mutation: Delete the person with person-id from the list with list-id"
  [{:keys [list-id person-id]}]
  (action [{:keys [state]}]
    (let [ident-to-remove [:person/by-id person-id]
          strip-fk        (fn [old-fks]
                            (vec (filter #(not= ident-to-remove %) old-fks)))]
      (swap! state update-in [:person-list/by-id list-id :person-list/people] strip-fk)))
  (remote [env] true)) ; This one line is it!!!
```

The syntax for the addition is:

```
(remote-name [env] boolean-or-ast)
```

where `remote` is the name of a remote server (the default is `remote`). You can have any number of network remotes.
The default one talks to the
page origin at `/api`. What is this AST we speak of? It is the abstract syntax tree of the mutation itself (as data).
Using a boolean true means "send it just as the client specified". If you wish you can pull the AST from the `env`,
augment it (or completely change it) and return that instead. See the Developers Guide for more details.

Now that you've got the UI in place, try deleting a person. It should disappear from the UI as it did before; however,
now if you're watching the network you'll see a request to the server. If you server is working right, it will handle
the delete.

Try reloading your page from the server. That person should still be missing, indicating that it really was removed
from the server.

== Using a legacy REST API [[RESTAPI]]

Fulcro is really meant to be a full-stack solution. That said, it isn't really that hard to make it talk to other kinds
of servers. As an example, this addendum talks you through what it takes to talk to a legacy REST service.

Working with legacy REST APIs is a simple, though tedious, task. Basically you need to add an additional remote to the Fulcro Client
that knows how to talk via JSON instead of EDN.

The basic steps are:

1. Implement `FulcroNetwork`. See the `fulcro.client.network` namespace for the protocol and built-in implementation.
    a. Your `send` method will be passed the query/mutations the client wants to do. You must translate them to a REST
    call and translate the REST response into the desired tree of client data, which you then pass to the `ok` callback
    that `send` is given.
2. Install your network handler on the client (using the `:networking` option)
3. Add the `:remote` option to your loads, or use your remote name as the remote side of a mutation

=== Writing the Networking Code

For this example we're going to use the following public REST API endpoint: `http://jsonplaceholder.typicode.com/posts`
which returns a list of posts (try it to make sure it is working).

It should return an array of JSON maps, with strings as keys.

Basically, when you run a transaction (read or
write) the raw transaction that is intended to go remote is passed into the `send` method of a networking protocol.
The networking can send that unchanged, or it can choose to modify it in some way. Since REST servers don't understand
our Fulcro requests, we have to add a layer at the network to convert one to the other, and back (for the response).

=== The UI and Queries

First, let's talk about the UI code for dealing with these posts, since the UI defines the queries. Here is
a very simple UI we can add to our program:

```
(defsc Post [this {:keys [post/title post/body]}]           ; <1>
  {:ident [:posts/by-id :db/id]
   :query [:db/id :post/user-id :post/body :post/title]}
  (dom/div nil
    (dom/h4 nil title)
    (dom/p nil body)))

(def ui-post (prim/factory Post {:keyfn :db/id}))

(defsc Posts [this {:keys [posts]}]                         ; <2>
  {:initial-state {:posts []}
   :ident         (fn [] [:post-list/by-id :the-one])
   :query         [{:posts (prim/get-query Post)}]}
  (dom/ul nil
    (map ui-post posts)))

(def ui-posts (prim/factory Posts))

; ...

(defsc Root [this {:keys [ui/react-key blog-posts current-user friends enemies]}] ; <5>
  {:query         [:ui/react-key
                   :ui/person-id
                   {:current-user (prim/get-query Person)}
                   {:blog-posts (prim/get-query Posts)}     ; <3>
                   {:friends (prim/get-query PersonList)}
                   {:enemies (prim/get-query PersonList)}]
   :initial-state (fn [params] {:blog-posts (prim/get-initial-state Posts {}) ; <4>
                                :friends    (prim/get-initial-state PersonList {:id :friends :label "Friends"})
                                :enemies    (prim/get-initial-state PersonList {:id :enemies :label "Enemies"})})}
  (dom/div #js {:key react-key}
    (dom/h4 nil (str "Current User: " (:person/name current-user)))
    (dom/button #js {:onClick (fn [] (df/load this [:person/by-id 3] Person))} "Refresh User with ID 3")
    (ui-person-list friends)
    (ui-person-list enemies)
    (dom/h4 nil "Blog Posts")                               ; <6>
    (ui-posts blog-posts)))
```
<1> A component to represent the post itself
<2> A component to represent the list of the posts
<3> Composing the Posts UI into root query
<4> Composing the Posts UI into root initial data
<5> Pull the resulting app db data from props
<6> Render the list

Of course, there are no posts yet, so all you'll see is the heading. Notice that there is *nothing new here*. The UI
is completely network agnostic, as it should be.

Now for the networking code. This bit is a little longer, but most of it is the details around network communcation
itself, rather than the work you have to do. Create a new namespace `src/main/app/rest.cljs`:

```
(ns app.rest
  (:refer-clojure :exclude [send])
  (:require [fulcro.logging :as log]
            [fulcro.client.network :as net]
            [cognitect.transit :as ct]
            [goog.events :as events]
            [fulcro.transit :as t]
            [clojure.string :as str]
            [clojure.set :as set]
            [fulcro.client.primitives :as prim])
  (:import [goog.net XhrIo EventType]))

(defn make-xhrio [] (XhrIo.))

(defrecord Network [url request-transform global-error-callback complete-app transit-handlers]
  net/NetworkBehavior
  (serialize-requests? [this] true)
  net/IXhrIOCallbacks
  (response-ok [this xhr-io valid-data-callback]
    ;; Implies:  everything went well and we have a good response
    ;; (i.e., got a 200).
    (try
      (let [read-handlers (:read transit-handlers)
            ; STEP 3: Convert the JSON response into a proper tree structure to match the query
            response      (.getResponseJson xhr-io)
            edn           (js->clj response) ; convert it to clojure
            ; Rename the keys from strings to the desired UI keywords
            posts         (mapv #(set/rename-keys % {"id"     :db/id
                                                     "title"  :post/title
                                                     "userId" :post/user-id
                                                     "body"   :post/body})
                            edn)
            ; IMPORTANT: structure of the final data we send to the callback must match the nesting structure of the query
            ; [{:posts [...]}] or it won't merge correctly:
            fixed-response      {:posts posts}]
        (js/console.log :converted-response fixed-response)
        ; STEP 4; Send the fixed up response back to the client DB
        (when (and response valid-data-callback) (valid-data-callback fixed-response)))
      (finally (.dispose xhr-io))))
  (response-error [this xhr-io error-callback]
    ;; Implies:  request was sent.
    ;; *Always* called if completed (even in the face of network errors).
    ;; Used to detect errors.
    (try
      (let [status                 (.getStatus xhr-io)
            log-and-dispatch-error (fn [str error]
                                     ;; note that impl.application/initialize will partially apply the
                                     ;; app-state as the first arg to global-error-callback
                                     (log/error str)
                                     (error-callback error)
                                     (when @global-error-callback
                                       (@global-error-callback status error)))]
        (if (zero? status)
          (log-and-dispatch-error
            (str "NETWORK ERROR: No connection established.")
            {:type :network})
          (log-and-dispatch-error (str "SERVER ERROR CODE: " status) {})))
      (finally (.dispose xhr-io))))
  net/FulcroNetwork
  (send [this edn ok error]
    (let [xhrio       (make-xhrio)
          ; STEP 1: Convert the request(s) from query notation to REST...
          ; some logic to morph the incoming request into REST (assume you'd factor this out to handle numerous kinds)
          request-ast (-> (prim/query->ast edn) :children first)
          uri         (str "/" (name (:key request-ast)))   ; in this case, posts
          url         (str "http://jsonplaceholder.typicode.com" uri)]
      (js/console.log :REQUEST request-ast :URI uri)
      ; STEP 2: Send the request
      (.send xhrio url "GET")
      ; STEP 3 (see response-ok above)
      (events/listen xhrio (.-SUCCESS EventType) #(net/response-ok this xhrio ok))
      (events/listen xhrio (.-ERROR EventType) #(net/response-error this xhrio error))))
  (start [this] this))

(defn make-rest-network [] (map->Network {}))
```

The steps you need to customize are annotated in the comments of the code. There are just a few basic steps:

. Fulcro comes with a handy function that can convert a query into an AST, which is easier to process. We don't really
care too much about the whole query, we just want to detect what is being asked for (we're going to ask for
`:posts`).
. Once we've understood what is wanted, we create a REST URL and GET the data from the REST server.
. When we get a successful response we need to convert the JSON into the proper EDN that the client expects. In
this case we're looking for `{ :posts [ {:db/id 1 :post/body "..." :post/title "..." ] ... }`.
. Once we have the properly structure tree of data to match the query, we simply pass it to the ok callback that
our send was given.

In a more complete program, you'd put hooks at steps (2) and (3) to handle all of the different REST requests, so that
the majority of this code would be a one-time thing.

=== Installing our Networking Code

Fulcro lets you set up networking yourself. We'd still like to talk to our server, but now we also want to be able
to talk to the REST server. The modification is done in our client options. For example, our devcard playground could
be changed to this:

```
(ns app.intro
  (:require [fulcro.client.cards :refer [defcard-fulcro]]
            [app.ui.root :as root]
            [fulcro.client.data-fetch :as df]
            [app.rest :as rest]
            [app.api.mutations :as api]
            [fulcro.client.network :as net]))

(defcard-fulcro sample-app
  root/Root
  {}
  {:inspect-data true
   :fulcro       {
                  :networking {:remote (net/make-fulcro-network "/api" :global-error-callback (constantly nil))
                               :rest   (rest/make-rest-network)}
                  :started-callback
                              (fn [app] (df/load app :current-user root/Person)
                                (df/load app :my-friends root/Person {:target        [:person-list/by-id :friends :person-list/people]
                                                                      :post-mutation `api/sort-friends})
                                (df/load app :my-enemies root/Person {:target [:person-list/by-id :enemies :person-list/people]}))}})
```

=== Requesting Data from the Alternate Remote

IMPORTANT NOTE: If you're using the dev cards, you might want to change `:inspect-data true` to `false`. Devcards get
a bit slow if you put a lot of data in the app and ask the card to format it all in the inspector. In those cases
it can be better to use Fulcro Inspect instead).

All the hard stuff is done. Loading is now triggered just like you would have before, except with a `:remote` option
to specify which network to talk over:

```
                       :started-callback (fn [app]

                                           (df/load app :posts Post {:remote :rest :target [:post-list/by-id :the-one :posts]})

                                           ... as before ...
```

=== Mutations over REST

The same technique is used. Everything you've read is accurate for mutations as well (you'll see the mutation come
into the `send` function). To trigger a mutation, just add another section to your client mutation (a mutation can
be sent to any number of remotes, in fact):

```
(defmutation delete-post
  [{:keys [id]}]
  (action [env] ...stuff to affect local db...)
  ; you could also include this: (remote [env] true)
  (rest [env] true)) ; tell the :rest networking to send this mutation
```

So, `action` names the local (optimistic) effect. Each other method name *must* match a remote's name as configured
in the `:networking` of the client. If you return true (or an AST) from one of these "remote" sections, it will trigger
the mutation to be sent to that network handler.

== The Complete Source

For your convenience this complete application is at https://github.com/fulcrologic/fulcro-getting-started

= Core Concepts

This chapter covers some extra detail about core language features and theory that are important in the Fulcro ecosystem. You
need not read this chapter to use Fulcro, but it will aid in your understanding of it quite a bit.

== Immutable Data Structures

Many of the most interesting and compelling features of Fulcro are directly or
indirectly enabled (or made simpler) by the use of persistent data structures
that are a first-class citizen of the language.

In imperative programming languages like Java and Javascript you have no idea what
a function or method might do to your program state:

[source,java]
-----
Person p = new Person();

doSomethingOnAnotherThread(p);

p.fumble();

// did p just change??? Did I just cause a race condition???
-----

This leads to all sorts of subtle bugs and is arguably the source of many of
the hardest problems in keeping software sustainable today. What if `Person` couldn't
change and you instead had to copy instead if you wanted to modify?

[source,java]
-----
Person p = new Person();

doSomethingOnAnotherThread(p);

Person q = p.fumble();

// p is definitely unchanged, but q could be different
-----

Now you can reason about what will happen. The other thread will see `p` exactly as
it was when you (locally) reasoned about it. Furthermore, `q` cannot be affected
because if `p` is truly "read-only" then I still know what it is when I use it to
derive `q` (the other thread can't modify it either).

In order to derive these benefits you need to either write objects that enforce
this behavior (which is highly inconvenient and hard to make efficient
in imperative langauges), or use a programming language that supplies the ability
to do so as a first-class feature.

Another benefit is that persistent data structures can do *structural sharing*. Basically
the new version of a map, vector, list, or set can use references to point to any
parts of the old version that are still the same in the new version. This means,
for example, that adding an element to the head of a list that had 1,000,000 entries
(where only one is being changed) is still a constant time operation!

Here are some of the features in Fulcro that trivially result from using persistent data structures:

. A Time-travel UI history viewer that consumes little space.
. Extremely efficient detection of data changes that affect the UI (can be ref compare instead of data compare)
. "Pure Rendering" is possible and convenient without having to resort to hidden variables in the UI.

== Pure Rendering

Fulcro uses Facebook's React to accomplish updates to the browser DOM. React, in
concept, is really simple:

Render is a function you make that generates a data structure known as the
VDOM (a lightweight virtual DOM)

. On The first "frame", the real DOM is made to match this data structure.
. On every subsequent frame, render is used to make a new VDOM. React
compares the prior VDOM (which is cached) to the new one, and then applies the
changes to the DOM.

The cool realization the creators of React had was that the DOM operations
that are slow and heavy, but there are efficient ways to figure out what
needs to be changed via the VDOM without you having to write a bunch of
controller logic.

Now, because React lives in a mutable space (Javascript), it allows all sorts of things
that can embed "rendering logic" within a component. This sounds like a good
idea to our OOP brains, but consider this:

What if you could have a complete snapshot of the state of your application, pass
that to a function, and have the screen just "look right". Like writing a 2D game: you
just redraw the screen based on the new "state of the world". All of the sudden your
mind shifts away from "bit twiddling" to thinking more about the representation
of your model with minimal data!

That is what we mean by "pure rendering".

[[PureRenderingDiagram]]
[ditaa, target=rendering]
....

   /-------\   /-------\   /-------\   /-------\
   | state |-->| state |-->| state |-->| state |
   \-------/   \-------/   \-------/   \-------/
       |           |           |           |
       |render     |render     |render     |render
       |           |(diff)     |(diff)     |(diff)
       v           v           v           v
   /-------\   /-------\   /-------\   /-------\
   |  DOM  |   |  DOM  |   |  DOM  |   |  DOM  |
   \-------/   \-------/   \-------/   \-------/
....


Here's an example to whet your appetite: Nested check-boxes.
In imperative programming each checkbox has it's own state, and when we want a "check all"
we end up writing nightmares of logic to make sure the thing works right because we're
having to *store a mutable value* into an object that then does the rendering.
Then we play with it and find out we
forgot to handle that event where some sub-box gets unchecked to
fire an event to ensure to uncheck the "select all"...oh wait, but when I do that
it accidentally fires the event from "check all" which unchecks everything
and then goes into an infinite loop!

What a mess! Maybe you eventually figure out something that's tractable, but
that extra bit of state in the "check all" is definitely the source of bugs.

Here's what you do in pure rendering with immutable data:

Each sub-item checkbox is a simple data structure with a `:checked?` key that has a boolean
value. You use that to directly tell the checkbox what it's state should be
(and React enforces that...making it impossible for the UI to draw it any
differently)

```
(def state {:items [{:id :a :checked? true} {:id :b :checked? false} ...]})
```

For a "state of the world", these are read-only. (you have to make a "new
state of the world" to change one). When you render, the state of the
check-all is just the conjunction of it's children's `:checked?`:

```
(let [all-checked (every? :checked? (get state :items)]
   (dom/input #js {:checked all-checked}))
```

The check-all button would have *no application state at all*, and React will
force it to the correct state based on the calculated value.
When the sub-items change, a new "state of the world"
is generated with the altered item:

```
(def next-state (assoc-in state [:items 0 :checked?] false))
```

and the *entire* UI is re-rendered (React makes this fast
using the VDOM diff), the "check all" checkbox will just be
right!

If the "check all" button is pressed, then the logic is similarly very simple:
change the state for the subitems to checked if any were unchecked, or set them
all to unchecked if they were all checked:

```
(def next-state-2
  (let [all-checked? (every? :checked? (get state :items))
        c            (not all-checked?)
        old-items    (get state :items)
        new-items    (mapv #(assoc % :checked? c) old-items)]
    (assoc state :items new-items)))
```

and again you get to pretend you're rendering an entire new frame on the screen!

You'll be continually surprised at how simple your logic gets in the UI once you
adjust to this way of thinking about the problem.

== Data-Driven

Data-driven concepts were pioneered in web development by Facebook's GraphQL and
Netflix's Falcor. The idea is quite powerful, and eliminates huge amounts of
complexity in your network communication and application development.

The basic idea is this: Your UI, which might have various versions (mobile, web, tablet)
all have different, but related, data needs. The prevalent way of talking to our
servers is to use REST, but REST itself isn't a very good query 'or' update
language. It creates a lot of complexity that we have to deal with in order
to do the simplest things. In the small, it is "easy". In the large, it isn't
the best fit.

Data-driven applications basically use a more detailed protocol that allows the
client UIs to specify what they need, and also typically includes a "mutation
on the wire" notation that allows the client to abstractly say what it
needs the server to do.

So, instead of `/person/3` you can instead say "I need person 3, but only their
name, age, and billing info. But in the billing info, I only need to know their
billing zip code".

Notice that this abstract expression (which of course has a syntax we're
not showing you yet) is "walking a graph". This is why Facebook calls their language
"GraphQL".

You can imagine that the person and billing info might be stored in two tables
of a database, with a to-one relationship, and our query is basically asking
to query this little sub-graph:

[ditaa,graph-query-abstract]
....
[person: age? name?]--->[billing info: zip?]
....

Modifications are done in a similar, abstract way. We model them as if
they were "function calls on the wire". Like RPC/RMI:

```
'(change-person {:id 3 :age 44})
```

but instead of actually 'calling' the function, we encode this list as
a data structure (it is a list containing a symbol and a map: the power of Clojure!) and then process that
data locally (in the back-end of the UI) and optionally also
transmit it 'as data' over the wire for server processing!

== Graph Database [[GraphDB]]

The client-side of Fulcro keeps all relevant data in a simple graph database, which
is referenced by a single top-level atom. The database itself is a persistent map.

The database should be thought of as a root-level node (the top-level map itsef),
and tables that can hold data relevant to any
particular component or entity in your program (component or entity nodes).

[ditaa,target=dbmodel]
....
+---------------------+
| prop     42         |
|                     |
| table  { ID entity  |
|          ... }      |
| table  { ID entity  |
|          ... }      |
|                     |
+---------------------+
....

The tables are also simple maps, with a naming convention and well-defined structure.
The name of the table is typically namespaced with the "kind" of thing you're storing,
and has a name that indicates the way it is indexed:

```
{ :person/by-id { 4    { :id 4 :person/name "Joe" }}}
;   ^      ^      ^    ^
; kind   indexed  id   entity value itself
```

=== Idents

Items are joined together into a graph using a tuple of the table name and the key of
an entity. For example, the item above is known as `[:person/by-id 4]`. Notice that this
tuple is also exactly the vector you'd need in an operation that would pull data from that
entity or modify it:

```
(update-in state-db [:person/by-id 4] assoc :person/age 33)
(get-in state-db [:person/by-id 4])
```

These tuples are known as 'idents'. Idents can be used anywhere one node
in the graph needs to point to another. If the idents (which are vectors)
'appear' in a vector, then you are creating a 'to-many' relation:

[source,clojure]
------
{ :person/by-id
    {  1  {:id 1 :person/name "Joe"
           :person/spouse [:person/by-id 2]         ; <1>
           :person/children [ [:person/by-id 3]
                              [:person/by-id 4] ] } ; <2>
       2  { :id 2 :person/name "Julie"
            :person/spouse [:person/by-id 1]}       ; <3>
       3  { :id 3 :person/name "Billy" }
       4  { :id 4 :person/name "Heather"}}
------

<1> A to-one relation to Joe's spouse (Julie)
<2> A to-many relation to Joe's kids
<3> A to-relation back to Joe from Julie

Notice in the example above that Joe and Julie point at each other. This creates
a 'loop' in the graph. This is perfectly legal. Graphs can contain loops. The
table in the example contains 4 nodes.

The client database treats the 'root' node as a special set of non-table properties
in the top of the database map. Thus, an entire state database with 'root node'
properties might look like this:

The above data structure is now a graph database that looks like this:

[ditaa,target=dbgraph]
....
root          +---> [:person/by-id 1] <----+
+-----------+ |    +-----------------+     |
|           | |    | id 1            |     |
| people -----+    | name "Joe"      |     |
|           | |    | spouse ----+    |     |
|           | |    | children --+------+------+
+-----------+ |    +------------|-----     |  |
              |                 v          |  |
              +--->[:person/by-id 2]       |  |
              |    +-----------------+     |  |
              |    | id 2            |     |  |
              |    | name "Julie     |     |  |
              |    | spouse ---------------+  |
              |    +------------------        |
              |                               |
              +--> [:person/by-id 3] <--------+
              |    +-----------------+        |
              |    | id 3            |        |
              |    | name "Billie"   |        |
              |    |                 |        |
              |    +-----------------+        |
              |                               |
              +--> [:person/by-id 4] <--------+
                   +-----------------+
                   | id 4            |
                   | name "Heather"  |
                   |                 |
                   +-----------------+
....

This makes for a very compact representation of a graph with an arbitrary number of nodes and edges.
All nodes but the special "root node" live in tables. The root node itself is special because
it is the storage location for both root properties *and* for the tables themselves.

IMPORTANT: Since the root node and the tables containing other nodes are merged
together into the same overall map it is important that you use
care when storing things so as not to accidentally collide on a name. Larger programs
should namespace all keywords.

=== A Special Note about The Client-Side Database

The graph database on the client is the most central and key concept to understand in Fulcro. Remember
that we are doing pure rendering. This means that the UI is simply a function transforming this
graph database into the the UI.

There are two primary things to write in Fulcro: the UI and the mutations. The UI pulls data from
this database and displays it. The mutations evolve this database to a new version.
Every interaction that changes the UI should be thought of as a *data manipulation*. You're making
a new *state of the world* that your pure renderer turns into DOM.

The graph format of the database means that your data manipulation, the main dynamic thing in
the entire application, is simplified down to updating properties/nodes, which themselves
live at the top of the state atom or are only 2-3 levels deep:

```
; change the root list of people, and modify the name and age of person 2
(swap! state (fn [s]
               (-> s
                 (assoc :people [[:people/by-id 1] [:people/by-id 2]])
                 (assoc-in [:people/by-id 2 :person/name] "George")
                 (assoc-in [:people/by-id 2 :person/age] 33))))
```

For the most part the UI takes care of itself. Clojure has very good functions for manipulating
maps and vectors, so even when your data structures get more complex the task is still about
as simple as it can be.

=== Client Database Naming Conventions

To avoid collisions in your database, the following naming conventions are recommended for
use in the Fulcro client-side graph database:

[horizontal]
*UI-only Properties*:: `:ui/name`. These are special in that they never end up in server queries
derived from components. Can be used on any node to hold UI-only state. Not needed if the node itself
is not involved with server interaction.
*Tables*:: `:entity-type/index-indicator`. Examples: `:person/by-id` or `:graph/by-type`
*Root properties*:: `:root/prop-name`
*Targeted Loads*:: Loads temporarily place their results in root. Targeting relocates them. If you've followed the
other naming conventions, then these can elide a namespace if that facilitates server interactions.
*Node properties*:: `:entity-type/property-name`. Examples: `:person/name` or `:graph/data`

= Component Rendering

== HTML5 Element Factories

The core HTML5 elements all have simple factory functions that
generate the core elements that stand-in for the real DOM.
These stand-ins (commonly referred to as the virtual DOM or VDOM)
are ultimately what React uses to generate, diff, and update the real DOM.

So, there are functions for every possible HTML5 element. These are in the
`fulcro.client.dom` namespace, and take a Javascript map for attributes (this gives
optimal performance, since React wants to consume Javascript data):

```
(dom/div #js { :className "some-class" }
  (dom/ul nil
    (dom/li ...)))
```

Remember that this (nested) call of functions results in a representation (VDOM) of
what you'd like to end up on the screen.

The next level of abstraction you can use is simply a function.
Combining more complex bits of UI into a function is a great way to group
re-usable nested DOM:

```
(defn my-header []
  (dom/div #js { :className "some-class" }
    (dom/ul nil
      (dom/li ...))))
```

=== Fulcro and React DOM – Notes

Here are some common things you'll want to know how to do that are different when rendering with Fulcro:

* Inline styles are specified with JS maps `(dom/p #js { :style #js {:backgroundColor "rgb(120,33,41)"} } ...)`.
** `#js` is a reader tag. The reader is the thing that reads your source code, and it is configurable. This one
tells the reader how to turn the map into a js object.
** `dom/p` is a function for generating p tags for use in React componenets. There is one of these for every legal HTML tag.
* There are alternatives to this ([sablono](https://github.com/r0man/sablono) is popular). It adds some overhead, but many
people prefer how it reads.
* Attributes follow the react naming conventions for [Tags and Attributes](https://facebook.github.io/react/docs/tags-and-attributes.html)
** As an example - CSS class names are specified with `:className` instead of `:class`.
* Any time a VDOM includes a collection of elements they should each have a unique `:key`
attribute. This helps the React diff figure out how that collection has changed. You will
get warnings in the browser console if you fail to do so.
* You can run-time convert cljs data structures (recursively) to js types with `(clj->js {:x {y 1}})`.
The `#js` tag causes the *compiler* to output a Javascript
data structure (it is *not* a conversion, nor is it recursive). Thus `#js` has no runtime overhead,
but `clj->js` can convert dynamic things on the fly at runtime.

== The Reconciler [[Reconciler]]

When you start a Fulcro application your `:started-callback` will get the completed `app` as a parameter.

Inside of this app is a reconciler under the key `:reconciler`. The reconciler is a central component in the system
that is responsible reconciling the differences between the database and the UI. Therefore it
is involved in processing the queries, merging novel data into the database, network interactions, and tracking
mounted components that might need refresh.

You will see it mentioned in many places in this book, and we'll point out where you'll use it directly.

=== Useful Reconciler Options

When you create a new client you can pass options directly to the reconciler with `:reconciler-options`.
There are a number of options that are used internally by the higher-level layers of Fulcro and should not
really be used directly, but there are a number of options that can be quite useful.

[horizontal]
`:shared`::  A map of global (immutable) properties that will be visible to all components. See <<SharedState, Shared State>>.
`:shared-fn`:: A function to compute shared properties from the root props on UI refresh. *only* recomputed on
root-level refresh, such as a call to `force-root-render`. See <<SharedState, Shared State>>.
`:root-render`::  The root render function. Defaults to ReactDOM.render. Useful for switching to React Native.
`:root-unmount`:: The root unmount function. Defaults to ReactDOM.unmountComponentAtNode. Useful for React Native.
`:render-mode`::  One of `:normal`, `:keyframe`, or `:brutal`. See below.
`:lifecycle`::    A function (fn [component event]) that is called when react components either :mount or :unmount. Useful for debugging tools.
`:tx-listen`::    A function of 2 arguments that will listen to transactions. Called when `transact!` runs. Gets the
transaction and the environment. The environment includes `:old-state`, `:new-state`, the state atom, etc.
`:instrument`:: A function that will wrap all rendering. `(fn [{:keys [props children class factory}] )` that
is called instead of the real factory. You can use this to wrap all UI components for things like performance
timing, tooling, etc.

=== Rendering Optimizations [[RenderingOptimizations]]

The reconciler does a number of things to optimize rendering beyond the basics of React.

* Fulcro provides a a built-in `shouldComponentUpdate` that uses a comparison of the prior props to
tell React to skip no-op updates that would lead to a useless VDOM diff.
* When more than one component will refresh the components are refreshed in depth-first order. This allows Fulcro
to prevent double-rendering of children. (e.g. if a Parent and Child need to refresh then updating the parent
first will render the child, and the child can be skipped. If the child was rendered first then the parent refresh would
try to double-render the child).
* If a component is the target of a refresh and has an ident then Fulcro will run the query for *just* that component,
and re-render *just* that component's subtree (avoiding a root query and root render).
** NOTE: a component without an ident will *always* trigger a root refresh, since there is no way to figure out
how to run that component's query (queries are relative, and idents give you an anchor point for them).

The `shouldComponentUpdate` optimization reduces the load by quite a bit, but running the query from root can
be somewhat costly depending on how well you <<Performance, optimized>> your UI query. Thus, idents become a major
factor in both normalization and rendering performance since Fulcro relies on them in order to reduce
the query overhead of UI refresh.

=== Rendering Modes

Version 2.1+ of Fulcro include the ability to tell the reconciler which rendering mode to use.

[[horizontal]]
`:normal`:: The default mode. Uses all possible optimizations.
`:keyframe`:: Disables the ident-based targeted refresh. Thus every render is considered a key frame of the DOM.
This means that every transaction/change will run the root UI query and render from root. The `shouldComponentUpdate`
optimization is in force and prevents quite a bit of work from React. This mode can be plenty fast and has the advantage
of not needing you to program with follow-on reads.
`:brutal`:: Disables all optimizations, runs queries from root, runs refresh from root, and forces React to do a full
DOM diff. Primarily useful to compare how much benefit optimizations are actually giving you beyond React's DOM diff.

== The `defsc` Macro

NOTE: If you're new to Fulcro and started with version 2.0, you can safely ignore most comments about `defui`. The two
are rougly equivalent, with `defsc` being the newer.

Fulcro's defsc is a front-end to the legacy defui macro. It is sanity-checked for the most common elements: ident (optional), query,
render, and initial state (optional). The sanity checking prevents a lot of the most common errors when writing a component,
and the concise syntax reduces boilerplate to the essential novelty. The name means "define stateful component" and is
intended to be used with components that have queries (though that is not a requirement).

=== The Argument List

The primary argument list contains the common elements you might need to use in the body:

```
(defsc [this props <optional-computed> <optional-css-map-if-using-css>]
 { ...options... }
 (dom/div #js {:onClick (:onClick computed)} (:db/id props)))
```

The last parameter will let you destructure fulcro-css names, if and only if you're using the Fulcro CSS library.

Only the first two parameters are required, so you can even write:

```
(defsc [this props]
 { ...options... }
 (dom/div nil (:db/id props)))
```

==== Argument Destructuring

The parameter list fully supports Clojure destructuring on the props, computed, and css-name-map without having to write a
separate let:

```
(defsc DestructuredExample [this
                            {:keys [db/id] :as props}
                            {:keys [onClick] :as computed :or {onClick identity}}
                            {:keys [my-css-class] :as css-name-map}]
  {:query         [:db/id]
   :initial-state {:db/id 22}
   :css           [[:.my-css-class {:color :black}]]}
  (dom/div #js {:className my-css-class}
    (str "Component: " id)))
```

=== Options – Lambda vs. Template

The core options (`:query`, `:ident`, `:initial-state`, `:css`, and `:css-include`) of `defsc` support both a lambda and a template
form. The template form is shorter and enables some sanity checks; however, it is not expressive enough to cover all
possible cases. The lambda form is slightly more verbose, but enables full flexibility at the expense of the sanity checks.

IMPORTANT NOTE: In lambda mode use `this` and `props` from the `defsc` argument list. So, for example, `(fn [] [:x])` is
valid for query (this is added by the macro), and `(fn [] [:table/by-id id])` is valid for ident.

=== Ident Generation

If you include `:ident`, it can take two forms: a template or lambda.

==== Template Idents

A template ident is just a vector that patterns what goes in the ident. The first element is always literal, and the
second is the name of the property to pull from props to get the ID.

This is the most common case, and if you use the template mechanism you get some added sanity checks: it won't compile
if your ID key isn't in your query, eliminating some possible frustration.

==== Lambda Idents

Template idents are great for the common case, but they don't work if you have a single instance ever (i.e. you want
a literal second element), and they won't work at all for union queries. They also do not support embedded code.
Therefore, if you want a more advanced ident, you'll need to spell out the code.

`defsc` at least eliminates some of the boilerplate:

```
(defsc UnionComponent [this {:keys [db/id component/type]}]
  {:ident (fn [] (union-ident type id))} ; id and type are destructured into the method for you.
  ...)
```

=== Query

`defsc` also allows you to specify the query as a template or lambda.

==== Template Query

The template form is strongly recommended for most cases, because without it many of the sanity checks won't work.

In template mode, the following sanity checks are enabled:

* The props destructuring
* The ident's id name is in the query (if ident is in template mode)
* The initial app state only contains things that are queried for (if it is in template mode as well)

==== Lambda Query

This mode is necessary if you use more complex queries. The template mode currently does not support union queries.

To use this mode, specify your query as `(fn [] [:x])`. In lambda mode, `this` comes from the argument list of `defsc`.

=== Initial State

As with `:query` and `:ident`, `:initial-state` supports a template and lambda form.

The template form for initial state is a bit magical, because it tries to sanity check your initial state, but also has
to support relations through joins. Finally it tries to eliminate typing for you by auto-wrapping nested relation
initializations in get-initial-state for you by deriving the correct class to use from the query.
This further reduces the chances of error; however, you may find the terse result more difficult to read and
instead choose to write it yourself. Both ways are supported:

==== Lambda mode

This is simple to understand, and all you need to see is a simple example:

```
(defsc Component [this props]
 {:initial-state (fn [params] ...exactly the state this component should start with...)}
 ...)
```

==== Template Mode

In template mode `:initial-state` converts incoming parameters (which must use simple keywords) into :param/X keys. So,

```
(defsc Person [this props]
  {:initial-state {:db/id :param/id}}
  ...)
```

means:

```
(defsc Person [this props]
  {:initial-state (fn [params] {:db/id (:params id)}})}
  ...)
```

It is even more powerful than that, because it analyzes your query and can deal with to-one and to-many join initialization as well:

```
(defsc Person [this props]
  {:query [{:person/job (prim/get-query Job)}]
  :initial-state {:person/job {:job/name "Welder"}}
  ...)
```

means (in simplified terms):

```
(defsc Person [this props]
  {:initial-state (fn [params] {:person/job (prim/get-initial-state Job {:job/name "Welder"})})}
  ...)
```

Notice the magic there. `Job` was pulled from the query by looking for joins on the initialization keyword (`:person/job`).

To-many relations are also auto-derived:

```
(defsc Person [this props]
  {:query [{:person/prior-jobs (prim/get-query Job)}]
  :initial-state {:person/prior-jobs [{:job/name "Welder"} {:job/name "Cashier"]}
  ...)
```

means (in simplified terms):

```
(defsc Person [this props]
  {:initial-state (fn [params]
    {:person/prior-jobs [(prim/get-initial-state Job {:job/name "Welder"})
                         (prim/get-initial-state Job {:job/name "Cashier"})]})}
  ...)
```

The internal steps for processing this template are:

* Replace all uses of :param/nm with (get params :nm)
* The query is analyzed for joins on keywords (ident joins are not supported).
** If a key in the initial state matches up with a join, then the value in initial state must be a map or a vector.
In that case (get-initial-state JoinClass p) will be called for each map (to-one) or mapped across the vector (to-many).

REMEMBER: the value that you use in the initial-state for children is the parameter map to use against that child's
initial state function. To-one and to-many relations are implied by what you pass (a map is to-one, a vector is to-many).

Step (1) means that nesting of param-namespaced keywords is supported, but realize that the params come from the
*declaring component's* initial state parameters, they are substituted *before* being passed to the child.

=== CSS Support

Support for using `fulcrologic/fulcro-css` is built-in, but it is a dynamic dependency so to use it you must include
the `fulcrologic/fulcro-css` library in your project dependencies and require the `fulcro-css.css` namespace in any file
that uses this support.

The keys in the options map are:

* `:css` - The items to put in protocol method css/local-rules. Can be pure garden data, or `(fn [] ...)`
* `:css-include` - The items to put in protocol method css/include-children. Can be a vector of classes, or `(fn [] ...)`

Both are optional. If you use neither, then your code will not incur a dependency on the fulcro-css library.

See Fulcro CSS for more information.

=== React Lifecycle Methods

The options of defsc allow for React Lifecycle methods to be defined (as lambdas). The `this` parameter of `defsc` is
in scope for all of them, but *not* `props` or `computed`. You can obtain computed using `prim/get-computed`. This is
because the lifecycle method may receive prior or next props, and using the top parameter list could be confusing.

The signatures are:

```
(defsc Component [this props]
    ; remember that 'this' is in scope for lifecycle
    :initLocalState            (fn [] ...)
    :shouldComponentUpdate     (fn [next-props next-state] ...)
    :componentWillReceiveProps (fn [next-props] ...)
    :componentWillUpdate       (fn [next-props next-state] ...)
    :componentDidUpdate        (fn [prev-props prev-state] ...)
    :componentWillMount        (fn [] ...)
    :componentDidMount         (fn [] ...)
    :componentWillUnmount      (fn [] ...)
```

See the React documentation for more details on how these work.

==== Additional Protocol Support

If you need to include additional protocols (or lifecycle React methods) on the generated class then you can use the
`:protocols` option. It takes a list of forms that have the same shape as the body of a `defui`, and the `static` qualifier
is supported. If you supply `Object` methods then they will be properly combined with the generated render:

Here is an example of adding Fulcro CSS using protocols instead of options:

```
(defsc MyComponent [this props]
   {:protocols (Object
                static css/CSS
                (local-rules [_] [])
                (include-children [_] []))
    ...}
   (dom/div nil ...))
```

This gives you the full protocol capabilities of `defui`, but you only need the extra protocol additions when you
use methods and protocols beyond the central ones.

=== Sanity Checking

The sanity checking mentioned in the earlier sections causes compile errors. The errors are intended to be self-explanatory.
They will catch common mistakes (like forgetting to query for data that you're pulling out of props, or misspelling a property).

Feel free to edit the components in this source file and try out the sanity checking. For example, try:

* Mismatching the name of a prop in options with a destructured name in props.
* Destructuring a prop that isn't in the query
* Including initial state for a field that is not listed as a prop or child in options.
* Using a scalar value for the initial value of a child (instead of a map or vector of maps)
* Forget to query for the ID field of a component that is stored at an ident

In some cases the sanity checking is more aggressive that you might desire. To get around it simply use the lambda style.

== Factories

Factories are how you generate React elements (the virtual DOM nodes) from your React classes defined with
`defsc`. You make a new factory using `fulcro.client.primitives/factory`:

```
(def ui-component (prim/factory MyComponent {:keyfn f :validator v :instrument? true}))
```

There are 3 supported options to a factory:

[horizontal]
`:keyfn`:: A function from `props` to a React key. Should generally be supplied to ensure React rendering can properly diff.
`:validator`:: A function from props to boolean. If it returns false then an assertion will be thrown at runtime.
`:instrument?`:: A boolean. If true, it indicates that instrumentation should be enabled on the component.

Instrumentation is a function you can install on the <<Reconciler,reconciler>> that wraps component `render` allowing you to add
measurement and debugging code to your component's rendering.

In Fulcro documentation we generally adopt the naming convention for UI factories to be prefixed with `ui-`. This
is because you often want to name joins the same thing as a component: e.g. your query might be
`[{:child (prim/get-query Child)}]`, and then when you destructure in render: `(let [{:keys [child]} (prim/props this) ...`
you have local data in the symbol `child`. If your UI factory was also called `child` then it would cause annoying name
collisions. Prefixing the factories with `ui-` makes it very clear what is data and what is an element factory.


== Render and Props

Properties are always passed to a component factory as the first argument. The properties can be accessed
from within `render` by calling `fulcro.client.primitives/props` on the parameter passed to `render` (typically named `this`
to remind you that it is a reference to the instance itself).

In components with queries there is a strong correlation between the query (which must join the child's query),
props (from which you must extract the child's props), and calling of the child's factory
(to which you must pass the child's data).

If you are using components that do not have queries, then you may pass whatever properties you deem useful.

Details about additional aspects of rendering are in the sections that follow.

=== Derived Values

It is possible that your logic and state will be much simpler if your UI components derive some values at render time.
A prime example of this is the state of a "check all" button. The state of such a button is dependent on other components
in the UI, and it is *not* a separate value. Thus, your UI should compute it and not store it else it could
easily become out of sync and lead to more complex logic.

```
(defn item-checked? [item] (:checked? item))

(defsc Checkboxes [this {:keys [items]}]
  {:query [{:items (prim/get-query CheckboxItem)}]}
  (let [all-checked? (every item-checked? items)]
    (dom/div nil
      "All: " (dom/input #js {:checked all-checked? ...})
    (dom/ul nil ...))))
```

==== General Guidelines for Derived Values

You should consider computing a derived value when:
* The known data from the props already gives you sufficient information to calculate the value.
* The computation is relatively light.

Some examples where UI computation are effective, light, or even necessary:

* Rendering an internationalized value. (e.g. `tr`)
* Rendering a check-all button
* Rendering "row numbering" or other decorations like row highlighting

There are some trade-offs, but most significantly you generally do *not* want to compute things like the order/pagination of a list of items.
The logic and overhead in sorting and pagination often needs caching, and there are
clear and easy "events" (user clicking on sort-by-name) that make it clear when to call the mutation to update
the database. You still have to store the selected sort order, and you have to have idents pointing to the list of
items. It is possible for your "selected sort order" and list to become out of sync, but the trade-offs of sorting
in the UI are typically high, particularly when pagination is involved and large amounts of data would have
to be fed to the UI.


=== Computed Props and Callbacks

Many reusable components will need to tell their parent about some event. For example, a list item generally wants
to tell the parent when the user has clicked on the "remote" button for that item. The item itself cannot
be truly composable if it has to know details of the parent. But a parent must always know the details of
a child (it rendered it, didn't it?). As such, manipulations that affect the content of a parent should be
communicated to that parent for processing. The mechanism for this is identical to what you'd do in stock
React: callbacks from the child.

The one *major* difference is how you pass the callback *to* a component.

The query and data feed mechanisms that supply props to a component are capable of refreshing a child *without*
refreshing a parent. This UI optimization can pull the props directly from the database using the query, and
re-feed them to the child.

But this mechanism knows nothing about callbacks, because they are not (and should not be) stored in
the client database. Such a targeted refresh of a component cannot pass callbacks through the props
because the parent is where that is coded, but the parent may not be involved in the refresh!

So, any value (function or otherwise) that is generated on-the-fly by the parent must be passed via
`fulcro.client.primitives/computed`. This tells the data feed system how to reconstruct the complete data should it do a targeted update.

```
(defsc Child [this {:keys [y]}]
  {:query [:y]}
  (let [onDelete (prim/get-computed this :onDelete)]
    ...))

(defsc Parent [this {:keys [x child]}]
  {:query  [:x {:child (prim/get-query Child)}]}
  (let [onDelete (fn [id] (prim/transact! ...))
        child-props-with-callbacks (prim/computed child {:onDelete onDelete})]
    (ui-child child-props-with-callbacks)))
```

WARNING: Not understanding this can cause a lot of head scratching: The initial render will always work perfectly,
because the parent is involved. All events will be processed, and you'll think everything is fine; however, if you
have passed a callback incorrectly it will mysteriously stop working after a (possibly unnoticeable) refresh. This
means you'll "test it" and say it is OK, only to discover you have a bug that shows up during heavier use.

=== Children

A very common pattern in React is to define a number of custom components that are intended to work in a nested fashion. So,
instead of just passing `props` to a factory, you might also want to pass other React elements. This is fully supported
in Fulcro, but can cause confusion when you first try to mix it with the data-driven aspect of the system.

==== Working with Children

Fulcro includes a few functions that are helpful when designing React components that are intended to be nested as direct
children within a single render:

[horizontal]
`(prim/children this)`:: Returns the React children of `this`
`(cutil/react-instance? Component instance)`:: Returns true if the given element is an instance of the given component class. Otherwise `nil`.
`(cutil/first-node` Component child-seq):: Returns the first of a sequence of elements that has the given component class.

So, say you wanted to create the following kind of rendering scheme:

```
(defsc Panel ...)
(def ui-panel (prim/factory Panel))
(defsc PanelHeader ...)
(def ui-panel-header (prim/factory PanelHeader))
(defsc PanelBody ...)
(def ui-panel-body (prim/factory PanelBody))

(ui-panel {}
  (ui-panel-header {} "Some Heading Text")
  (ui-panel-body {}
     (dom/div nil "Some sub-DOM")))
```

The DOM generation for `Panel` will need to find the header and body children:

```
(defsc Panel [this props]
  (let [children (prim/children this)
        header (util/first-node PanelHeader children)
        body (util/first-node PanelBody children)]
    (when header
      (dom/h4 nil header))
    (when body
      (dom/div nil body))))
```

Basically, the child or children can simply be dropped into the place where they should be rendered.

==== Mixing Data-Driven Children with UI-Only Concerns

At first this seems a little mind-bending, because you are in fact nesting components in the UI, but
the query nesting need only mimic the *stateful* portion of the UI tree. This means there is ample opportunity
to use React children in a way that looks incorrect from what you've learned so far. On deeper inspection
it turns out it is alignment with the rules, but it takes a minute on first exposure.

Take the Bootstrap collapse component: It needs state of its own in order to know when it is collapsed,
and we'd like that to be part of the application database so that the support history viewer can show the
correct thing. However, the children of the collapse cannot be known in advance when writing the collapse
reusable library component.

The solution is simple once you see it: Query for the collapse component's state and the child state in
the common parent component, then do the UI nesting in that component. Technically the component that is "laying out" the
UI (the ultimate parent) is in charge of both obtaining and rendering the data.  The fact that the UI child ends
up nested in a query sibling is perfectly fine.

The collapse component itself is only concerned with the fact that it is open/closed, and that it has children that
should be shown/hidden. The actual DOM elements of those children are immaterial, and can be assembled by the parent:

```
(defsc CollapseExample [this {:keys [collapse-1 child]}]
  {:initial-state (fn [p] {:collapse-1 (prim/get-initial-state b/Collapse {:id 1 :start-open false})})
   :query [{:collapse-1 (prim/get-query b/Collapse)}
           {:child (prim/get-query SomeChild)}]}
  (dom/div nil
    (b/button {:onClick (fn [] (prim/transact! this `[(b/toggle-collapse {:id 1})]))} "Toggle")
    (b/ui-collapse collapse-1
      (ui-child child))))
```

== Controlled Inputs

Form inputs in React can take two possible approaches: controlled and uncontrolled. The browser normally maintains
the value state of inputs for you as mutable data; however, this breaks our overall model of pure rendering! The
advantage is UI interaction speed: If your UI gets rather large, it is possible that UI updates on keystrokes in
form inputs may be too slow. This is the same sort of trade-off that we talked about when covering component
local state for rendering speed with more graphical components. If you follow the basic <<Performance,optimization guidelines>>
then your application should be fast enough to do database updates on every keystroke, and you can keep all input
changes in your client database.

In general it is recommended that you use controlled inputs and retain the benefits of pure rendering: no embedded
state, your UI exactly represents your data representation, concrete devcards support for UI prototyping, and full
support viewer support.

Most inputs become controlled when you set their `:value` property. The table below lists the mechanism whereby
a form input is completely controlled by React:

[width="80%",options="header"]
|================================
| Input type  | Attribute | Notes
| input       | :value    | (not checkboxes or radio)
| checkbox    | :checked  |
| radio       | :checked  | (only one in a group should be checked)
| textarea    | :value    |
| select      | :value    | Instead of marking an option selected. Match `select`'s `:value` to the `:value` of a nested `option`.
|================================

IMPORTANT: React will consider `nil` to mean you want an uncontrolled component. This can result in
a warning about converting uncontrolled to controlled components. In order to prevent this warning you should make
sure that `:checked` is always a boolean, and that other inputs have a valid `:value` (e.g. an empty string). The
`select` input can be given an "extra" option that stands for "not selected yet" so that you can start its value
at something valid.

See https://facebook.github.io/react/docs/forms.html[React Forms] for more details.

NOTE: Fulcro 2.0 and lower had wrapped inputs to fix some IE bugs. You can disable the wrapping in 2.0 with
the JVM option `-DrawInputs`. Future versions will drop this legacy wrapping by default.

== React Lifecycle Examples [[ReactLifecycle]]

There are some common use-cases that can only be solved by working directly with the React Lifecycle methods.

Some topics you should be familiar with in React to accomplish many of these things are:

- Component references: A mechanism that allows you access to the *real* DOM of the component once it's on-screen.
- Component-local state: A stateful mechanism where mutable data is stored on the component instance.
- General DOM manipulation. Clojurescript builds using the Google Closure compiler and therefore
  includes the Google Closure library, which in turn has all sorts of helpful low-level functions should you need them.

=== Focusing an input

Focus is a stateful browser mechanism, and React cannot force the rendering of "focus". As such, when you need
to deal with UI focus it generally involves some interpretation, and possibly component local state. One way
of dealing with deciding when to focus is to look at a component's prior vs. next properties. This can be
done in `componentDidUpdate`. For example, say you have an item that renders as a string, but when clicked
turns into an input field. You'd certainly want to focus that, and place the cursor at the end of the
existing data (or highlight it all).

If your component had a property called `editing?` that you made true to indicate it should render as an input
instead of just a value, then you could write your focus logic based on the transition of your component's props
from `:editing?` false to `:editing?` true.

++++
<div class="example" id="focus-example"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.focus-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="focus-example source"]
----
include::src/book/book/ui/focus_example.cljs[]
----

NOTE: React documentation encourages a more functional form of `ref` (you supply a function instead of a string).
This example could also cache that in component local state like this:

```
(defsc ClickToEditField [this {:keys [value editing?]}]
  ...
     (dom/input #js {:ref (fn [r] (prim/set-state! this {:input r}))})
  ...
```

WARNING: The wrapped inputs of Fulcro 2.0 and earlier do not work with the functional ref technique.
The `ref` with a function only works on form elements in Fulcro 2.0.0 and older if you supply the
JVM with `-DrawInputs`. This will become the default in later versions of Fulcro.

=== Taking control of the sub-DOM (D3, etc)

Libraries like D3 are great for dynamic visualizations, but they need full control
of the portion of the DOM that they create and manipulate.

In general this means that your `render` method should be called once
(and only once) to install the base DOM onto which the other library
will control.

For example, let's say we wanted to use D3 to render things. We'd first
write a function that would take the *real* DOM node and the incoming
props:

```
(defn db-render [DOM-NODE props] ...)
```

This function should do everything necessary to render the sub-dom (and
update it if the props change). Then we'd wrap that under a component that
doesn't allow React to refresh that sub-tree via `shouldComponentUpdate`.

Below is a demo of this:

++++
<div class="example" id="ui-d3"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.ui-d3').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="ui-d3 source"]
----
include::src/book/book/ui/d3_example.cljs[]
----

The things to note for this example are:

* We override the React lifecycle method `shouldComponentUpdate` to return false. This tells React to never ever call
  render once the component is mounted. D3 is in control of the underlying stuff.
* We override `componentWillReceiveProps` and `componentDidMount` to do the actual D3 render/update. The former will
   get incoming data changes, and the latter is called on initial mount. Our render method
   delegates all of the hard work to D3.


=== Dynamically rendering into a canvas

Sometimes you need to use component-local state to avoid the overhead in running a query to feed props. An example
of this is when handing mouse interactions like drag. You'll typically use React refs to grab the actual low-level canvas.

There are actually two ways to change component-local state. One of them defers rendering to the next animation frame,
but it *also* reconciles the database with the stateful components. This one will not give you as much of a speed boost
(though it may be enough, since you're not changing the database or recording more UI history).

The other mechanism completely avoids this, and just asks React for an immediate forced update.

* `(set-state! this data)` and `(update-state! this data)` - trigger a reconcile against the database at the next animation frame. Limits frame rate to 60 fps.
* `(react-set-state! this data)` - trigger a React forceUpdate immediately

In this example we're using `set-state!`, and you can see it is still plenty fast!

++++
<div class="example" id="hover-example"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.hover-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="hover-example source"]
----
include::src/book/book/ui/hover_example.cljs[]
----

The component receives mouse move events to show a hover box. To make this move in real-time we use component
local state. Clicking to set the box, or resize the container are real transactions, and will actually cause
a refresh from application state to update the rendering.

== Using Javascript React Components

One of the great parts about React is the ecosystem. There are some great libraries out there.
However, the interop story isn't always straight forward. The goal of this section is to make that story a little clearer.

=== Factory Functions for JS React Components

Integrating React components is fairly straightforward if you have used React from JS before. The curve comes having
spent time with libraries or abstractions like Om and friends. JSX will also abstract some of this away, so it's not
just the cljs wrappers. For a good article explaining some of the concepts read, React Elements The take-aways here are:

. If you are importing third party components, you should be importing the class, not a factory.
. You need to explicitly create the react elements with factories. The relevant js functions are React.createElement, and React.createFactory.

It is very important to consider when using any of these functions - the children. JS does not have a built in notion
of lazy sequences. Clojurescript does. This can create subtle bugs when evaluating the children of a component.

`fulcro.util/force-children` helps us in this regard by taking a seq and returning a vector. We can use this to
create our own factory function, much like React.createFactory:

```
(defn factory-force-children
  [class]
  (fn [props & children]
    (js/React.createElement class
      props
      (util/force-children children))))
```

This is fine, but you will notice that children in our factory may be missing keys. Because we passed a vector in,
React won't attach the key attribute. We can solve this problem by using the apply function.

```
(defn factory-apply
  [class]
  (fn [props & children]
    (apply js/React.createElement
      class
      props
      children)))
```

Here the apply function will pass the children in as args to `React.createElement`, thus avoiding the key problem
as well as the issue with lazy sequences.

Now that we have some background on creating React Elements it's pretty simple to implement something.
Let' look at making a chart using Victory. We are going to make a simple line chart, with an X axis that contains
years, and a Y axis that contains dollar amounts. Really the data is irrelavent, it's the implementation we care about.

The running code and source are below:

++++
<div class="example" id="victory-example"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.victory-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="victory-example source"]
----
include::src/book/book/ui/victory_example.cljs[]
----

=== The Function-As-a-Child Pattern

A common pattern in React libraries is to use a function as a single child instead of an actual element. This
is an accepted and widely used pattern, but you need to do a simple extra step for it to work properly with
Fulcro. You see, Fulcro components use some behind-the-scenes bindings to allow for targeted UI rendering 
optimizations, and when you embed them in a function that is invoked from external JS out of that context, things
won't work correctly.

For example, the `react-motion` library gives you React tools that can animate DOM motion. It animates variables
that you apply to nested DOM, and it does this through the function-as-a-child pattern. Here's an example from
a https://github.com/awkay/fulcro-react-motion[demo project] (which uses shadow-cljs to get easy access to NPM
libraries):

```
(ns sample
  (:require ["react-motion" :refer [Motion spring]]
            [fulcro.client.primitives :as prim :refer [defsc]]
            [fulcro.client.dom :as dom]
            [goog.object :as gobj]))

(def ui-motion (factory-apply Motion))


(defsc Demo [this {:keys [ui/slid? block]}]
  {:query         [:ui/slid? {:block (prim/get-query Block)}]
   :initial-state {:ui/slid? false :block {:id 1 :name "N"}}
   :ident         (fn [] [:control :demo])}
  (dom/div nil
    (dom/button #js {:onClick (fn [] (m/toggle! this :ui/slid?))} "Toggle")
    (ui-motion (clj->js {:style {"x" (spring (if slid? 400 0))}})
      (fn [p]
        (let [x (gobj/get p "x")]
          ; The binding wrapper ensures that internal fulcro bindings are held within the lambda
          (prim/with-parent-context this
            (dom/div #js {:className "demo"}
              (ui-block (prim/computed block {:x x})))))))))
```

The key is the call to `with-parent-context`. It causes the enclosed elements to have bindings pulled 
from the component passed as the first parameter (in this case `this`).  Rendering will work 
correctly without this wrapper, but interactions (particularly `transact!`) will not operate correctly 
without it.

== Demo: An Image Clip Tool

Fulcro has the start of an image clip tool. Right now it is mainly for demonstration purposes, but it is in the main
library and is a good example of a complex UI component where two components have to talk to each other and share
image data.

You should study the source code (`src/main/fulcro/ui/clip_tool.cljs`) to get the full details,
but here is an overview of the critical facets:

* ClipTool creates a canvas on which to draw
** It uses initial state and a query to track the setup (e.g. size, aspect ratio, image to clip)
** For speed (and because some data is not serializable), it uses component-local state to track current clip region,
a javascript Image object and the DOM canvas (via React ref) for rendering, and the current active operation (e.g. dragging a handle).
** The mouse events are essentially handled as updates to the component local state, which causes a local component
render update.
* PreviewClip is a React component, but not data-driven (no query). Everything is just passed through props.
** It technically knows nothing of the clip tool.
** It expects an :image-object and clip data to be passed in...it just renders it on a canvas.
** It uses React refs to get the reference to the real DOM canvas for rendering
** It renders whenever props change
* A callback on the ClipTool communicates *through* the common parent's component local state. The parent
will re-render when its state changes, which will in turn force a new set of props to be passed to the preview).

As you can see, the interaction performance is quite good.

++++
<div class="example" id="clip-tool-example"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.clip-tool-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="clip-tool-example source"]
----
include::src/book/book/ui/clip_tool_example.cljs[]
----

== The `defui` Macro (Fulcro 1.x. Legacy support in 2.x)

The `defui` macro generates a React component. It does the same thing as the
`defsc` macro, but looks more like a `defrecord` and is a bit more OO in style. It
does not error-check your work, nor does it allow you to destructure incoming data
over the body or options; however, it is syntax-comptible with Om Next so if you're
porting from that library it can be useful.

It is 100% compatible with the React ecosystem. The macro is intended
to look a bit like a class declaration, and borrows generation notation style from `defrecord`. There is no
minimum required list of methods (e.g. you don't even have to define `render`). This latter fact is useful
for cases where you want a component for server queries and database normalization, but not for rendering.

=== React (Object) methods

`defui` is aware of the following React-centric methods, which you can override:

```
(defui MyComponent
  Object
  (initLocalState [this] ...)
  (shouldComponentUpdate [this next-props next-state] ...)
  (componentWillReceiveProps [this next-props] ...)
  (componentWillUpdate [this next-props next-state] ...)
  (componentDidUpdate [this prev-props prev-state] ...)
  (componentWillMount [this] ...)
  (componentDidMount [this] ...)
  (componentWillUnmount [this] ...)
  (render [this] ...))
```

See <<ReactLifecycle, React Lifecycle Examples>> for some specific examples, and the React documentation for a complete description of each of these.

NOTE: Fulcro does override `shouldComponentUpdate` to short-circuit renders of a component whose props have not changed. You
generally do *not* want to change this to make it render more frequently; however, when using Fulcro with
libraries like D3 that want to "own" the portion of the DOM they render you may need to make it so that
React never updates the component once mounted (by returning `false` always). The Developer's Guide shows an example
of this in the UI section.

=== The `static` Protocol Qualifier

`defui` supports implementations of protocols in a `static` context. It basically
means that you'd like the methods you're defining to go on the class (instead of instance), but conform to the
given protocol. There is no Java analogue for this, but in Javascript the classes themselves are open.

WARNING: Since there is no JVM equivalent of implementing `static` methods, a hack is used internally where the
protocol methods are placed in metadata on the resulting symbol. This is the reason functions like
`get-initial-state` exist. Calling the protocol (e.g. `initial-state`) in Javascript will work, but if you
try that when doing server-side rendering on the JVM, it will blow up.

=== IQuery and Ident

There are two core protocols for supporting a component's data in the graph database. They work in tandem to
find data in the database for the component, and also to take data (e.g. from a server response or initial state) and
normalize it into the database.

Both of these protocols *must* be declared *static*. The reason for this is initial normalization and query: The
system has to be able to ask components about their ident and query generation in order to turn a tree of data
into a normalized database.

[ditaa,target=queryidentoperation]
....

Tree of Data --> Component-based Query/Ident --> Normalized Data


Normalized Data --> Component Query --> Tree of UI Data

....

Queries *must* be composed towards the root component (so you end up with a UI query that can pull the entire
tree of data for the UI).

```
(defui ListItem
  static prim/IQuery
  (query [this] [:db/id :item/label])
  static prim/Ident
  (ident [this props] [:list-item/by-id (:db/id props)])
  ...)

(defui List
  static prim/IQuery
  (query [this] [:db/id {:list/items (prim/get-query ListItem)}])
  static prim/Ident
  (ident [this props] [:list/by-id (:db/id props)])
  ...)

;; queries compose up to root
```

==== Notes on the IQuery Protocol

Even though the method itself is declared statically, there are some interesting things about the `query` method:

- Once mounted, a component can have a dynamic query. This means calling `(prim/get-query this)` will return either
the static query, or whatever has been set on that component via `(prim/set-query! ...)`.
- The `get-query` accessor method not only helps with server-side invocation, it annotates the query with
metadata that includes the component info. This is what makes normalization work.

Some rules about the query itself:

- A query *must not* be stolen from another component (*even* if it seems more DRY):
+
```
(defui PersonView1
  static prim/IQuery
  (query [this] (prim/get-query PersonView2)) ;; WRONG!!!!
```
+
This is wrong because the query will end up annotated with `PersonView2`'s metadata. Never use the return
value of `get-query` as the return value for your own `query`.
- The query will be structured with joins to follow the UI tree. In this manner the render and query
follow form. If you query for some subcomponent's data, then you should pass that data to that
component's factory function for rendering.

==== Notes on the Ident Protocol

The ident of a component is often needed in mutations, since you're always manipulating the graph. To avoid
typos, it is generally recommended that you write a function like this:

```
(defn person-ident [id-or-props]
  (if (map? id-or-props)
    [:person/by-id (:db/id id-or-props)]
    [:person/by-id id-or-props]))
```

and use that in both your component's ident implementation and all of your mutations:

```
(defui Person
  static prim/Ident
  (ident [this props] (person-ident props)))

...

(defmutation change-name [{:keys [id name]}]
  (action [{:keys [state]}]
    (let [name-path (conj (person-ident id) :person/name)]
      (swap! state assoc-in name-path name))))
```

=== Om Next Compatibility

Fulcro's `defui` is identical in syntax to Om Next's `defui`. Porting
Om Next UI code to Fulcro is a simple matter of changing namespaces.

= The Query and Mutation Language

Before reading this chapter you should make sure you've read <<GraphDB,The Graph Database Section>>. It details
the low-level format of the application state, and talks about general details that
are referenced in this chapter.

In Fulcro all data is pulled from the database using a notation that is a subset of Datomic's pull query syntax. Since
the query is a graph walk it is a relative notation: it must start at some specific spot, but that spot is not
always named in the query itself. On the client side the starting point is usually the root node of your database. Thus,
a complete query from the Root UI component will be a graph query that can start at the root node of the database.

However, you'll note that any query *fragment* is implied to be relative to where we are in the walk of the graph
database. This is important to understand: no component's query can just be grabbed and run against the database
as-is. Then again, if you know the `ident` of a component, then you can *start* at that table entry in the database
and go from there.

The mutation language is a data representation of the abstract actions you'd like to take on the data model. It is
intended to be network agnostic: The UI need not be aware that a given mutation does local-only modifications and/or
remote operations against any number of remote servers. As such, the mutations, like queries, are simply data. Data
that can be interpreted by local logic, or data that can be sent over the wire to be interpreted by a server.

Queries can either be a vector or a map of vectors. The former is a regular component query, and the latter is
known as a *union* query. Union queries are useful when you're walking a graph edge and the target could be
one of many different kinds of nodes, so you're not sure which query to use until you actually are walking
the graph.

== Properties

The simplest thing to query are properties "right here" in the relative node of the graph. Properties are queried
by a simple keyword. Their values can be any scalar data value that is serializable in https://github.com/edn-format/edn[EDN].

The query

```
[:a :b]
```

is asking for the properties known as `:a` and `:b` at the "current node" in the graph traversal.

== Joins

A join represents a traversal of an edge to another node in the graph. The notation is a map with a single key
(the local key on the current node that holds the "pointer" to another node) whose single value is the
query for the remainder of the graph walk:

```
[{:children (prim/get-query Child)}]
```

The query itself cannot specify that this is a to-one or to-many join. The data in the *database graph itself*
determines the arity when the query is being run. Basically, if walking the join property leads to a vector of
links, it is to-many. If it leads to a single link, then it is to-one. Rendering the data is going
to have the same concern so the arity of the relation more strongly affects the rendering code.

Joins should always use `get-query` to get the next component in the graph. This annotates (with metadata) the sub-query
so that normalization can work correctly.

== Unions [[Unions]]

Unions represent a map of queries, only one of which applies at a given graph edge. This is a form of
dynamic query that adjusts based on the actual linkage of data. Unions cannot stand alone.
They are meant to select one of many possible alternate queries when a link (to-one or to-many join) in the
graph is reached. Unions are always used in tandem with a join, and can therefore not be used on root-level
components. The union query itself is a map of the possible queries:

```
(defsc PersonPlaceOrThingUnion [this props]
  ; lambda form required for unions (a limitation of the error checking routines in defsc)
  {:query (fn [] {:person/by-id (prim/get-query Person)
                  :place/by-id (prim/get-query Place)
                  :thing/by-id (prim/get-query Thing)})}
  ...)
```

and such a query must be joined by a parent component. Therefore, you'll always end up with something
like this:

```
(defsc Parent [this props]
  {:query [{:person-place-or-thing (prim/get-query PersonPlaceOrThingUnion)}]})
```

Union queries take a little getting used to because there are a number of rules to follow when
using them in order for everything to work correctly (normalization, queries, and rendering).

Here is what a graph database might look like for the above query assuming we started at `Parent`:

```
{ :peron-place-or-thing [:place/by-id 3]
  :place/by-id { 3 { :id 3 :location "New York" }}}
```

The query would start at the root. When it saw the join it would detect a union. The union would be resolved
by looking at the *first* element of the *ident in the database* (in this case `:place` from `[:place 3]`). That keyword
would then be used to select the *query* from the subcomponent union (in this example, `(prim/get-query Place)`).

Processing of the query then continues as normal as if the join was just on `Place`.

A to-many linkage works just as well:

```
{ :peron-place-or-thing [[:person/by-id 1] [:place/by-id 3]]
  :person/by-id { 1 { :id 1 :name "Julie" }}
  :place/by-id { 3 { :id 3 :location "New York" }}}
```

and now you have a mixed to-many relationship where the correct sub-query will be used for each item in turn.

Normalization of unions requires that the union component *itself* have an ident function that can properly
generate idents for *all of the possible kinds of things that could be found*. Often this means that you'll need
to encode some kind of type indicator in the data itself.

Say you had this incoming tree of data:

```
{:person-place-or-thing [ {:id 1 :name "Joe"} {:id 3 :location "New York"} ]}
```

In order to normalize this correctly we need to end up with the correct `person` and `place` idents. The resulting
ident function might look like this:

```
(defsc PersonPlaceOrThingUnion [this props]
  {:ident (fn []
    (cond
      (contains? props :name) [:person/by-id (:id props)]
      (contains? props :location) [:place/by-id (:id props)]
      :else [:thing/by-id (:id props)]))}
  ...)
```

Often it is easier to just include a `:type` field so that `ident` can look up both the type and id.

Rendering the correct thing in the UI of the union component has the same concern: you must detect what
kind of data (among the options) that you actually receive, and pass that on to the correct child factory (e.g.
`ui-person`, `ui-place`, or `ui-thing`. This is most commmonly done with a simple `case` statement.

=== Demo – Using Unions as a UI Type Selector

The `fulcro.client.routing/defrouter` macro emits a union component that can be switched to point at any kind
of component that it knows about. The support for parameterized routers in the routing tree makes it possible
to very easily reuse the UI router as a component that can show one of many screens in the same location.

This is particularly useful when you have a list of items that have varying types, and you'd like to, for example,
show the list on one side of the screen and the detail on the other.

To write such a thing one would follow these steps:

. Create one component for each item type that represents how it will look in the list.
. Create one component for each item type that represents the fine detail view for that item.
. Join (1) together into a union component and use it in a component that shows them as a list. In other words
  the union will represent a to-many edge in your graph. Remember that unions cannot stand alone, so there
  will be a union component (to switch the UI) and a list component to iterate through the items.
. Combine the detail components from (2) into a `defrouter` (e.g. named :detail-router).
. Create a routing tree that includes the :detail-router, and parameterize both elements of the target ident (kind and id)
. Hook a click event from the items to a `route-to` mutation, and send route parameters for the kind and id.

The output of this defrouter (macro):

```
(defrouter ItemDetail :detail-router
  (ident [this props] (item-ident props))
  :person/by-id PersonDetail
  :place/by-id PlaceDetail
  :thing/by-id ThingDetail)
```

is roughly this (cleaned up from macro output):

```
(defsc ItemDetail-Union [this props]
  {:initial-state [clz params] (prim/get-initial-state PersonDetail params)) ;; defaults to the first one listed
   :ident [this props] (item-ident props))
   :query (fn [] {:person/by-id (prim/get-query PersonDetail),
                  :place/by-id (prim/get-query PlaceDetail),
                  :thing/by-id (prim/get-query ThingDetail)}}
   (let [page (first (prim/get-ident this))]
    (case page
     :person/by-id ((prim/factory PersonDetail) (prim/props this))
     :place/by-id ((prim/factory PlaceDetail) (prim/props this))
     :thing/by-id ((prim/factory ThingDetail) (prim/props this))
     (dom/div nil (str "Cannot route: Unknown Screen " page))))

(defsc ItemDetail [this props]
  {:initial-state (fn [params] {:fulcro.client.routing/id :detail-router
                                :fulcro.client.routing/current-route (prim/get-initial-state ItemDetail-Union params)})
   :ident (fn [] [:fulcro.client.routing.routers/by-id :detail-router])
   :query [this] [:fulcro.client.routing/id {:fulcro.client.routing/current-route (prim/get-query ItemDetail-Union)}]}
  (let [computed (prim/get-computed this)
        props (:fulcro.client.routing/current-route (prim/props this))
        props-with-computed (prim/computed props computed)]
   ((prim/factory ItemDetail-Union) props-with-computed)))))
```

You can see that this just defines a union whose "selection" is controlled by the `:current-route` property!

Here is a complete working example that uses this to make a UI around displaying things of various types:

++++
<div class="example" id="union-example-1"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.union-example-1').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="union-example-1 source"]
----
include::src/book/book/queries/union_example_1.cljs[]
----

== Mutations [[Mutations]]

Mutations are also just data, as we mentioned earlier. However, they are intended to *look like* single-
argument function calls where the single argument is a map of parameters:

```
[(do-something)]
```

The main concern is that this expression, in normal Clojure, will be evaluated because it contains a raw list.
In order to keep it data, one must quote expressions with mutations. Of course you may use syntax quoting
or literal quoting. Usually we recommend namespacing your mutations (with `defmutation`) and then using
syntax quoting to get reasonably short expressions:

```
(ns app.mutations)

(defmutation do-something [params] ...)
```

```
(ns app.ui
  (:require [app.mutations :as am]))

...
   (prim/transact! this `[(am/do-something {})])
```

We talked about <<Transactions,syntax quoting transactions>> in the Getting Started chapter. You may want to
review that or just read more online about Clojure syntax quoting.

The parameter map on mutations is optional, but recommended, if you're using IDE support since the IDE will always
see mutations as if they were function calls with an arity of one.

== Parameters

Most of the query elements also support a parameter map. In Fulcro these are mainly useful when sending a query
to the server, and it is rare you will write such a query "by hand". However, for completeness you should know
what these look like. Basically, you just surround the property or join with parentheses, and add a map as
parameters. This is just like mutations, except instead of a symbol as the first element of the list it is either
a keyword (prop) or a map (join).

Thus a property can be parameterized:

```
[(:prop {:x 1})]
```

This would cause, for example, a server's query processing to see `{:x 1}` in the `params` when handling the read
for `:prop`.

A join is similarly parameterized:

```
[({:child (prim/get-query Child)} {:x 1})]
```

with the same kind of effect.

NOTE: The plain list has the same requirement as for mutations: quoting. Generally syntax quoting is again the best
choice, since you'll often need unquoting. For example, the join example above would actually be written in code as:

```
  ...
  (query [this] `[({:child ~(prim/get-query Child)} {:x 1})])
  ...
```

to avoid trying to use the map as a function for execution, yet allowing the nested `get-query` to run and embed
the proper subquery.

== Queries on Idents

Idents are valid in queries as a plain prop or a join. When used alone (not in a join) this will pull a table
entry from the database *without normalizing it or following any subquery*:

```
[ [:person/by-id 1] ]
```

results in something like this:

```
(defsc Phone [this props]
  {:query [:id :phone/number]
   :ident [:phone/by-id :id]}
  ...)

(defsc Person [this props]
  {:query [:id {:person/phone (prim/get-query Phone)}]
   :ident [:person/by-id :id]}
  ...)

(defsc X [this props]
  {:query [ [:person/by-id 1] ] } ; query just for the ident
  (let [person (get props [:person/by-id 1]) ; NOT get-in. The key of the result is an ident
        ...
        ; person contains {:id 1 :person/phone [:phone/by-id 4]}
```

This is not typically what you want because you'd typically want it to follow the graph links (resolving phone number).

Therefore these kinds of queries are normally done via a join:

```
(defsc X [this props]
  {:query [{[:person/by-id 1] (prim/get-query Person)}]}
  (let [person (get props [:person/by-id 1])
        ...
        ; person contains {:id 1 :person/phone {:phone/id 4 :phone/number "555-1212"}}
```

This has the effect of "re-rooting" the graph walk at that ident's table entry and continuing from there for the
rest of the subtree. In fact this is how Fulcro's <<RenderingOptimizations,ident-based rendering optimization>> works.

== Link Queries

There are times when you want to start "back at the root" node. This is useful for pulling data that has
a singleton representation in the root node itself. For example, the current UI locale or currently logged-in
user. There is a special notation for this the looks like an ident without an ID:

```
[ [:ui/locale '_] ]
```

This component query would result in `:ui/locale` in your props (not an ident) with a value that came from the
overall root node of the database. Of course, denormalization just requires you use a join:

```
[ {[:current-user '_] (prim/get-query Person)} ]
```

would pull `:current-user` into the component's props with a continued walk of the graph. In other words this is
just like the ident join, except the special symbol `_` indicates there is only one of them and it is in the root
node.

== A Warning About Ident and Link Queries

Components can query for whatever they want, and sometimes it is useful to write components that *only* query
for things "elsewhere" in the database:

```
(defsc LocaleSwitcher [this {:keys [ui/locale]}]
  {:query [[:ui/locale '_]]}
  (dom/div ...))
```

When the database is constructed for such components they will have no state of their own.

Sadly, even if you compose it into your UI properly it may not receive any data:

```
(defsc Root [this {:keys [locale-selector]}]
  {:query [{:locale-selector (prim/get-query LocaleSelector)}]}
  (ui-locale-selector locale-selector)) ; data comes back nil!!!
```

The problem is that the query engine walks the database and query in tandem. When it sees a join
(`:locale-selector` in this case) it goes looking for an entry in the database *at the current location*
(root node in this case) to process the subquery against. If it finds an ident it follows it and processes
the subquery. If it is a map it uses that to fulfill the subquery. If it is a vector then it processes the
subquery against every entry. But if it is _missing_ *then it stops*.

The fix is simple: make sure the component has a presence in the database, even if empty:

```
(defsc LocaleSwitcher [this {:keys [ui/locale]}]
  {:query [[:ui/locale '_]]
   :initial-state {}} ; empty map
  (dom/div ...))

(defsc Root [this {:keys [locale-selector]}]
  {:query [{:locale-selector (prim/get-query LocaleSelector)}]
   :initial-state (fn [params] {:locale-selector (prim/get-initial-state LocaleSwitcher)})} ; empty map from child
  (ui-locale-selector locale-selector)) ; link query data is found/passed
```

=== Using Shared State [[SharedState]]

An alternative to ident and link queries is shared state. The first thing to note is that it is *not*
a complete replacement for link queries. It is a low-level feature that is meant for two basic scenarios:

* Data that needs to be visible to all components, but never changes once the app is mounted.
* Data that is derived from the UI props (from root) or globals, but only updates on root-level renders (not component-local updates).

The first use-case might be handy if you pass some data to your mount through the HTML page itself. The
latter is useful for data that affects everything in your application, such as the current user.

The primary thing to remember is that components that look at shared state will not see updates unless a
root render occurs with those updates. This typically means calling `prim/force-root-render!`.

Say we wanted all components to be able to see `:pi` (a constant) and `:current-user` (a value from
the database). We could declare this as follows:

```
(fc/new-fulcro-client
  :reconciler-options {:shared {:pi 3.14} ; never changes
                       :shared-fn #(select-keys % :current-user)} ; updates on root render
```

Now *any* component can access these as follows:

```
(defsc C [this props]
  (let [{:keys [pi current-user]} (prim/shared this)]
    ; current-user will be DEnormalized...it comes from the root props (Root must query for it still)
    ...))
```

WARNING: Remember that this is *not* equivalent to a link query for `[:current-user '_]`. There are two differences.
The first is that pulling `:current-user` still requires that your root component query for it (or it
won't even be in the props). Second, the shared value will not visibly change until a root render happens, where
link queries *can* refresh locally with a component. The final difference is that *if* you use data in
your shared-fn that is derived from anything other than the state database then it will not work correctly
in the history support viewer.

== Recursive Queries

Fulcro's query syntax includes support for recursive queries. Recursion is *always* expressed on a join,
and it *always* means that the recursive item has the same type as the component you're on.
There are two notations for this: `...` and a number. The former means "recurse until there are no more links
(circular detection is included to prevent infinite loops)", and the other is the recursion limit:

NOTE: At the time of this writing you must use the lamba mode of `defsc` for queries that include recursion.

The following demo (with source) demonstrates the core basics of recursion:

++++
<div class="example" id="recursive-demo-1"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.recursive-demo-1').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="recursive-demo-1 source"]
----
include::src/book/book/queries/recursive_demo_1.cljs[]
----

=== Circular Recursion

It is perfectly legal to include recursion in your graph, and it is equally fine to
query for it. The query engine will automatically stop if a loop is detected.

However, this is not the whole story. You see, components can be updated in a relative
fasion when all optimizations are enabled. This means that a refresh could happen anywhere
in the (recursive) UI, and the query would run until it detects the loop again. This can
lead to funny-looking results.

The demo below lets you modify people and their spouse (a circular relation). Try it out
and you'll see that something isn't quite right (try making Sally older):

++++
<div class="example" id="recursive-demo-2"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.recursive-demo-2').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="recursive-demo-2 source"]
----
include::src/book/book/queries/recursive_demo_2.cljs[]
----

The problem is that when you touch Sally the UI refresh updates *just* that component; however,
that component has a recursive query of depth 1, so it ends up returning Joe as her spouse! This
is technically correct, but almost certainly isn't what you want!

The fix is equally simple: calculate depth and pass it to the child. Use the calculated depth
to prevent the extra rendering when local refresh gives you data you don't need. The
demo below has this fix.

++++
<div class="example" id="recursive-demo-3"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.recursive-demo-3').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="recursive-demo-3 source"]
----
include::src/book/book/queries/recursive_demo_3.cljs[]
----

=== Duplicates and Recursion

Of course it is perfectly fine for there to be multiple edges in your graph that point
to the same node. Below is a recursive bullet list example. We've intentionally nested
item `B.1` under B and D so you can see that it all works itself out.

Normalization of initial state (which must be a tree) is perfectly happy to see duplcate
entries. It simply merges the multiple copies into the same normalized entry in the table.

Since the two entries merge to the same entry, it also means the modifications will
be shared among them. Try checking item `B.1` in either location.

++++
<div class="example" id="recursive-demo-4"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.recursive-demo-4').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="recursive-demo-4 source"]
----
include::src/book/book/queries/recursive_demo_4.cljs[]
----

== The AST

You can convert any expression in the query/mutation language into an AST (abstract syntax tree) and vice
versa. This lends itself to doing complex parsing of the query (typically on the server). The functions
of interest are `fulcro.client.primitives/query->ast` and `ast->query`.

There are many uses for this. One such use might be to convert the graph expression into another form. For
example, say you wanted to run a query against an SQL database. You could write an algorithm that translates
the AST into a series of SQL queries to build the desired result. The AST is always available as one
of the parameters in the mutation/query `env` on the client and server.

Another use for the AST is in mutations targeted at a remote: it turns out you can morph a mutation before
sending it to the server.

=== Morphing Mutations

The most common use of the AST is probably adding parameters that the UI is unaware need to be sent to
a remote. When processing a mutation with `defmutation` (or just the raw defmethod) you will receive
the AST of the mutation in the `env`. It is legal to return *any* valid AST from the remote side of a
mutation. This has the effect of changing what will be sent to the server:

```
(defmutation do-thing [params]
  (action [env] ...)
  (remote [{:keys [ast]}] ast)) ; same effect as `true`

(defmutation do-thing [params]
  (action [env] ...)
  (remote [{:keys [ast]}] (prim/query->ast `[(do-other-thing)])) ; completely change what gets sent to `remote`

(defmutation do-thing [params]
  (action [env] ...)
  (remote [{:keys [ast]}] (assoc ast :params {:y 3}))) ; change the parameters
```

For more on mutations see the chapter on <<MutationsChapter, Handling Mutations>>

= Initial Application State

When starting any application one thing has to be done before just about anything else: Establish a starting state. In Fulcro
this just means generating a client-side application database (normalized). Other parts of this guide have talked about
the <<GraphDB, Graph Database>>. You can well imagine that hand-coding one of these for a large application's starting
state could be kind of a pain. Actually, coding it would turn out to be less of a pain than maintaining such
a hand-coded thing it as you refactor and evolve your UI!

However, Fulcro already knows how to normalize a tree of data, and your UI is the tree you're interested in. So, Fulcro
encourages you to co-locate initial application state with the components that need the state and compose it towards
the root, just like you do for queries. This gives some nice results:

* Your initial application state is reasoned about local to each component, just like the queries.
* Refactoring the UI just means modifying the *local* composition of queries and initial state from one place
to another in the UI.
* Fulcro understands unions (you can only initialize one branch of a to-one relation), and can scan for and initialize alternate branches.

== Adding Initial State to Components

To add initial state, follow these steps:

1. For each component that should appear initially: add the `:initial-state` option.
2. Compose the components in (1) all the way to your root.

That's it! Fulcro will automatically detect initial state on the root, and use it for the application!

NOTE: Pulling the initial state from a component should be done with `fulcro.core/get-initial-state`. Calling a static
protocol cannot work on the server, so this helper method makes server-side rendering possible for your components.

```
(defui Child
  static fulcro.core/InitialAppState
  (initial-state [cls params] { :x 1 }) ; set :x to 1 for this component's state
  static prim/IQuery
  (query [this] [:x]) ; query for :x
  static prim/Ident
  (ident [this props] ...) ; how to normalize
  Object
  (render [this]
    (let [{:keys [x]} (prim/props this)] ; pull x from props
      ...)))

(defui Parent
  static fulcro.core/InitialAppState
  (initial-state [cls params] { :y 2 :child (prim/get-initial-state Child {}) }) ; set y, and compose in child's state
  static prim/IQuery
  (query [this] [:y {:child (prim/get-query Child)}]) ; query for :y and compose child's query
  static prim/Ident
  (ident [this props] ...) ; how to normalize
  Object
  (render [this]
    (let [{:keys [y child]} (prim/props this)] ; pull y and child from props
      ...)))

...
```

Notice the nice symmetry here. The initial state is (usually) a map that represents (recursively) the entity and
it's children. The query is a vector that lists the "scalar" props, and joins as maps.  So, in `Child` we have
initial state for `:x` and a query for `:x`. In the parent we have a query for the property `:y` and a join to
the child, and initial state for the scalar value of `:y` and the composed initial state of the `Child`. Render has
the same thing: the things you pull out of props will be the things for which you queried. Thus, all three essentially
list the same things, but in slightly different forms.

=== Initial State and Alternate Branches of Unions

The one "extra" feature that initial state support does for you is to initialize *alternate branches* of components that
have to-one <<Unions, union query>>. Remember that a to-one relation from a union could be to any number of alternates.

Take this union query: `{:person (prim/get-query Person) :place (prim/get-query Place)}`

It means "if you find an ident in the graph pointing to a `:person`, then query for the person. If you find one
for `:place`, then query for a place. The problem is: if it is a to-one relation then only *one* can be in the
initial state tree at startup!

```
{ :person-or-place [:person 2]
  :person {2 {:id 2 ...}}}
```

If you look at a proposed initial state, it will make the problem more clear:

```
(defui Person
  static prim/InitialAppState
  (initial-state [c {:keys [id name]}] {:id id :name name :type :person})
  ...)

(defui PersonPlaceUnion
  static prim/InitialAppState
  (initial-state [c p] (prim/get-initial-state Person {:id 1 :name "Joe"})) ; I can only put in one of them!
  static prim/IQuery
  (query [this] {:person (prim/get-query Person) :place (prim/get-query Place)})
  ...)

(defui Parent
  static prim/InitialAppState
  (initial-state [c p] {:person-or-place (prim/get-initial-state PersonPlaceUnion)})
  static prim/IQuery
  (query [this] [{:person-or-place (prim/get-query PersonPlaceUnion)}]))
```

This would result in a person in the initial state, but not a place.

Fulcro solves this at startup in the following manner: It pulls the query from root and walks it. If it finds
a union component, then *for each branch* it sees if that component (via the query metadata) has initial state. If
it does, it places it in the correct table in app state. This does *not*, of course, join it to anything in the graph
since it isn't the "default branch" that was explicitly listed (in `PersonPlaceUnion`'s `InitialAppState`).

This behavior is critical when using unions to handle UI routing, which is in turn essential for good application
performance.


=== Initial State Demo

The following demo shows all of this in action.

++++
<div class="example" id="initial-app-state"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.initial-app-state').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="initial-app-state source"]
----
include::src/book/book/demos/initial_app_state.cljs[]
----


== Initial State and State Progressions

If you remember from the <<PureRenderingDiagram, diagram>> about pure rendering, then you'll also note that this step
generates the *first state* in that progression. Rendering any state results in the UI for that state.

An interesting note is that this model also results in a really useful property: You can take the initial state,
run it though the implementation of one or more mutations, and end up with any other state. This means you can
easily reason about initializing your application into *any* state, which is useful for things like testing and server-side rendering.

There are all sorts of very useful features that fall out of this. For example, it is also possible to record a series
of "user interactions" (which can be recorded as a list of the mutations that ran) and replay those. This could be used
to send a tester a sequence of steps to show recent development work, run automated demos/tests, teleport your development
environment to a specific page, etc.

Writing tests against the state model and mutation implementations is a great way to *unit test* your application
without needing to involve the UI itself at all! You can read more about that in the section on
<<VisualRegression, Visual Regression Testing>>

= Normalization [[Normalization]]

Normalization is a central mechanism in Fulcro. It is the means by which your data
trees (which you receive from component queries against servers) can be placed into
your normalized graph database.

== Internals

The function `prim/tree->db` is the workhorse that turns an incoming tree of data into normalized data (which can then
be merged into the overall database).

Imagine an incoming tree of data:

```
{ :people [ {:db/id 1 :person/name "Joe" ...} {:db/id 2 ...} ... ] }
```

and the query:

```
[{:people (prim/get-query Person)}]
```

which expands to:
```
[{:people [:db/id :person/name]}]
          ^ metadata {:component Person}
```

`tree->db` recursively walks the data structure and query:

- At the root, it sees `:people` as a root key and property. It remembers it will be writing `:people` to the root.
- It examines the value of `:people` and finds it to be a vector of maps. This indicates a to-many relationship.
- It examines the metadata on the subquery of `:people` and discovers that the entries are represented by
the component `Person`
- For each map in the vector, it calls the `ident` function of `Person` (which it found in the metadata) to get a
database location. It then places the "person" values into the result via `assoc-in` on the ident.
- It replaces the entries in the vector with the idents.

If the metadata was missing then it would assume the person data did not need normalization. This is why it is
critical to compose queries correctly. The query and tree of data must have a parallel structure, as should the
UI. In template mode `defsc` will try to check some things for you, but you must ensure that you
compose the queries correctly.

== Normalization: Initial State, Server Interations, and Mutations

The process described above is how most data interactions occur. At startup the `:initial-state` supplies data that
exactly matches the tree of the UI. This gives your UI some initial state to render. The normalization mechanism
described above is exaclty what happens to that initial tree when it is detected by Fulcro at startup.

Network interactions send a UI-based query (which remember is annotated with the components). The query is
remembered and when a response tree of data is received (which must match the tree structure of the query), the
normalization process is applied and the resulting normalized data is merged with the database.

If using websockets, it is the same thing: A server push gives you a tree of data. You could hand-normalize that data,
but actually if you know the structure of the incoming data you can easily generate a client-side query (using
`defsc` or `defui`) that can be used in conjunction with `prim/tree->db` to normalize that incoming data.

Mutations can do the same thing. If a new instance of some entity is being generated by the UI as a tree of data, then
the query for that UI component can be used to turn it into normalized data that can be merged into the state
within the mutation.

Some useful functions to know about:

- `prim/merge-component` - A utility function for merging new instances of a (possibly recursive) entity state into
the normalized database. Usable from within mutations.
- `prim/merge-state!` - A utility function for merging out-of-band (e.g. push notification) data into your application.
Includes ident integration options, and honors the Fulcro merge clobbering algorithm (if the query doesn't ask for it,
then merge doesn't affect it). Also queues rendering for affected components (derived from integration of idents). Generally
*not* used within mutations (use `merge-component` and `integrate-ident!` instead).
- `prim/tree->db` - General utility for normalizing data via a query and chunk of data.
- `prim/integrate-ident!` - A utility for adding an ident into existing to-one and to-many relations in your database.
Can be used within mutations.
- `fulcro.client.util/deep-merge` - An implementation of merge that is recursive

= Handling Mutations [[MutationsChapter]]

Mutations are known by their symbol and are dispatched to the internal multimethod
`fulcro.client.mutations/mutate`. To handle a mutation you can do two basic things: use `defmethod`
to add a mutation support, or use the macro `defmutation`. The macro is recommended for most cases
because it namespaces the mutation, prevents some common errors, and works better with IDEs.

== Stages of Mutation

There are multiple passes on a mutation: one local, and one for each possible remote. It is
technically the job of the mutation handler to return a lambda for the local pass, and a boolean (or AST)
for each remote. Returning `nil` from any pass means to not do anything for that concern.

For example, say you have three remotes: one for normal API, one that hits a REST API, and one for
file uploads. Each would have a name, and each pass of the mutation handling would be interested
in knowing what you'd like to do for the local or remote.

The mutation environment (`env` in the examples) contains a target that is set to a remote's name when
the mutation is being asked for details about how to handle the mutation with respect to that remote.

For each pass the mutation is supposed to return a map whose key is `:action` or the name of the remote, and
whose value is the thing to do (a lambda for `:action`, and AST or true/false for remotes).

Summary:

1. You `transact!` somewhere in the UI
2. The internals call your mutation with `:target` set to nil in `env`. You return a map with an `:action` key
whose value is the function to run.
3. The internals call your mutation once for each remote, with `:target` set. You return a map with
that remote's keyword as the key, and either a boolean or AST as the remote action. (true means send the
AST for the expression sent in (1) to the remote)

== Using the Multimethod Directly [[MutationMultimethod]]

Typically the multipass nature is ignored by the mutation itself, and it just returns a map
containing all of the possible things that should be done. This looks like:

```
(defmethod fulcro.client.mutations/mutate `mutation-symbol [{:keys [state ast target] :as env} k params]
   {:action (fn [] ...)
    :rest-api true ; trigger this remotely on the rest API AND the normal one.
    :remote true })
```

Since the action is just data, it doesn't matter that we "generate" it for the multiple passes. Same for
the remotes.

.Reminder
****
The example above uses syntax quoting on the symbol which will add the current
namespace to it. In any case the symbol is just that: a symbol (data) that acts as the dispatch
key for the multimethod. If you use a plain quote (`'`) then you should manually namespace the symbol.
****

Some common possible mistakes are:

1. You side-effect. Your mutation will be called at least two times so this is a bad idea.
Side effects should be wrapped in the action.
2. You assume that the remote expression "sees" the old state (e.g. you might build an AST based on
what is in app state). The local action is usually run before the remote passes, meaning the state has already changed
and the remote logic is seeing the "new" client database state.
3. You forget to return a map with the correct keys (usually if you made mistake 1).

There is no guaranteed order to evaluation. Therefore if you need a value from state as it was seen
when the mutation was triggered: *send it as a _parameter_ to the mutation* from the UI (where you knew the old value).
That way the call itself has captured the old value.

== Using `defmutation`

`defmutation` is a macro that writes the multimethod for you. It looks like this:

```
(defmutation mutation-symbol
  "docstring"
  [params]
  (action [{:keys [state] :as env}]
    (swap! state ...))
  (rest-api [env] true)
  (remote [env] true))
```

Thus it ends up looking more like a function definition. IDE's like Cursive can be told how to resolve
the macro (as `defn` in this case) and will then let you read the docstrings and navigate to the definition
from the usage site in transact. This makes development a lot easier.

Another advantage is that the symbol is placed into the namespace in which it is declared (not interned,
just given the namespace...it is still just symbol data). Syntax quoting can expand aliasing, which means
you get a very nice tool experience at usage site:

```
(ns app
  (:require [app.mutations :as am]))

...
   (prim/transact! this `[(am/mutation-symbol {})]) ; am gets expanded to app.mutations
```

The final advantage is it is harder to accidentally side-effect. The `action` section of `defmutation`
will wrap the logic in a lambda, meaning that it can read as-if you're side-effecting, but in fact
will do the right thing.

In general these advantages mean you should generally use the macro to define mutations, but it is good
to be aware that underneath is just a multimethod.

== Refreshing Non-local UI

In the default rendering mode Fulcro is capable of optimizing your rendering refresh so that the bare
minimum amount of activity happens in the query engine and React. The basic rules are as follows:

. Refresh the subtree starting at the component that ran `transact!`. If it was the reconciler, run from root.
. Refresh any component's that share the same `ident` with the component that ran the transaction.
. Refresh any component that *queries* for any of the data that was indicated in "follow-on" reads.

=== Parent-Child Relationships

The most common case of non-local UI refresh comes up with parent-child relationships. In these cases, the parent can
be seen as a UI component in control of the children (it is responsible for telling them to render). In such cases it is
usually better to reason about the *management* logic (i.e. deleting, reordering, etc) from the parent; however,
it is commonly the case the you want the *child* to render some controls, such as a delete button. Thus, the control
that wants to modify the state (the delete button on the item) is not local to the component that will need to refresh
(the parent's list).

The solution is simple: create a callback in the parent that can run the delete transaction and pass it through
as a computed value.

In our example, we'll assume the delete is global (removes the item from the list and the normalized table):

```
(m/defmutation delete-item
  "Mutation: Delete an item from a list"
  [{:keys [id]}]
  (action [{:keys [state]}]
    (letfn [(filter-item [list] (filterv #(not= (second %) id) list))]
      (swap! state
        (fn [s]
          (-> s
            (update :items dissoc id) ; remove the item from the db (optional)
            (update-in [:lists 1 :list/items] filter-item))))))) ; remove the item from the list of idents
```

The source of the components for this demo are below. Make note of the use of `computed`.

++++
<div class="example" id="parent-child-ownership-relations"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parent-child-ownership-relations').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parent-child-ownership-relations source"]
----
include::src/book/book/demos/parent_child_ownership_relations.cljs[]
----

=== Follow-on Reads

A *follow-on read* is a property listed in a transaction:

```
(transact! this `[(f) :person/name])
```

It indicates that the given data will have changed, and therefore any on-screen component that queries for
that particular data should also be refreshed when the transaction completes the optimistic update (and again
after the remote interaction, if there is one).

Follow-on reads allow the developer to reason more abstractly about non-local UI refresh. They need only
think about what data is changing, and not about what components might be displaying it. This allows the UI
to evolve without additional concerns that refresh will be slow (due to expensive data analysis) or will become
broken (because you didn't know a component needed refresh).

```
(defsc Right [this {:keys [db/id right/value]}]
  {:query         [:db/id :right/value]}
  (dom/div nil
    ; needs a follow-on read because it is updating something that is queried elsewhere...
    (dom/button #js {:onClick #(prim/transact! this `[(ping-left {}) :left/value])} "Ping Left")
    value))
```

This model was inherited from Om Next, and it is the correct model to use when the transaction might, for example,
modify opaque data that is not directly queried but which would cause a component to need a refresh; however,
since most transactions run a mutation that is really more aware of what data is changing
it makes quite a bit of sense for you to be able to declare this *on the mutation itself*.

=== Declarative Refresh

Fulcro 2.0+ supports a way of declaring follow-on reads that allows for better local reasoning: co-locate the
follow-on reads with the mutation itself. The mechanism is quite simple: add a `refresh` section on your mutation
and return the list of keywords for the data that changed:

```
(defmutation ping-left [params]
  (action [{:keys [state]}]
    (swap! state update-in [:left/by-id 5 :left/value] inc))
  (refresh [env] [:left/value]))
```

The above mutation just indicates what it changed: `:left/value`.

The UI can then drop the follow-on reads:

```
(defsc Right [this {:keys [db/id right/value]}]
  {:query         [:db/id :right/value] }
  (dom/div nil
    ; no longer need the :left/value as a follow-on read
    (dom/button #js {:onClick #(prim/transact! this `[(ping-left {})])} "Ping Left")
    value))
```

In this case the transaction is running on a component that doesn't query for the data being changed (it is pinging the
Left component). The built-in refresh list on the mutation takes care of the update!

The live example below is a full-stack demo of this. The buttons update data that the other button displays.
The `transact!`s on these would normally require follow-on reads or a callback to the parent to refresh properly.
With the refresh list on the mutation itself the UI designer is freed from this responsibility.

The right button uses data from the server in a pessimistic fashion (it does no optimistic update, and you can
increase the simulated delay on the server), so pinging it from the left actually reads a value from the server.
This demonstrates that the refresh is working for full-stack operations.

++++
<div class="example" id="declarative-mutation-refresh"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.declarative-mutation-refresh').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="declarative-mutation-refresh source"]
----
include::src/book/book/demos/declarative_mutation_refresh.cljs[]
----

== Recommendations About Writing Mutations

Mutations themselves are meant to be abstractions across the entire stack; however, the optimistic side of them are
really just functions on your application state. Components have nice clean abstractions,
and you will often benefit from writing low-level functions that represent the general operations on a component's data. As
you move towards higher-level abstractions you'll want to compose those lower-level functions. As such, it pays
to think a little about how this will look over time.

If you write the *actual logic* of a mutation into a `defmutation`, then composition is difficult because the
model does not encourage recursive calls to `transact!`. This will either lead to code duplication or other bad
practices.

To maximize code reuse, local reasoning, and general readability it pays to think about your mutations in the following manner:

1. A mutation is a function that changes the state of the application: `state -> mutation -> state'`
2. Within a mutation, you are essentially doing operations to a graph, which means you have operations that
work on some node in the graph: `node -> op -> node'`. These operations may modifiy a scalar or an edge to another node.

=== Node-Specific Mutation

You can run a node-specific operation with:

```
(swap! state update-in node-ident op args)
```

For example, say you want to implement a mutation that adds a person to another person's friend list. The data
representation of a person is: `{:db/id 1 :person/name "Nancy" :person/friends []}`.

The `ident` function can be coded into a top-level function and used by the component:

```
(defn person-ident [id-or-props]
  (if (map? id-or-props)
    (person-ident (:db/id id-or-props))
    [:person/by-id id-or-props]))

(defsc Person [this props]
  {:ident (fn [] (person-ident props))}
  ...)
```

and our desired operation on the general state of a person can also be written as a simple function (add an ident
to the :person/friends field):

```
(defn add-friend*
   "Add a friend to an existing person. Returns the updated person."
   [person target-person-id]
   (update person :person/friends (fnil conj []) (person-ident target-person-id)))
```

Note, in particular, that we always choose to put the item to be updated as the first argument so that functions
like `update` are easier to use with it.

Now `(add-friend* {:db/id 1 :person/name "Nancy"} 33)` results in
`{:db/id 1, :person/name "Nancy", :person/friends [[:person/by-id 33]]}`.

You can write a mutation to support this operation within Fulcro:

```
(defmutation add-friend [{:keys [source-person-id target-id]}]
  (action [{:keys [state]}]
    (swap! state update-in (person-ident source-person-id)
      add-friend* target-id)))
```

You could even take it a step further with a little more sugar by defining a helper that can turn a node-specific
op into a db-level operation (again note that the thing being updated is the first argument):

```
(defn update-person [state-map person-id person-fn & args]
  (apply update-in state-map (person-ident person-id) person-fn args))

(defmutation add-friend [{:keys [source-person-id target-id]}]
  (action [{:keys [state]}]
    (swap! state update-person source-person-id add-friend* target-id)))
```

If you find that a given entity is always modified in the context of the state map itself (a common
case) then it can be a bit shorter to just push the table logic (ident resolution) into the operation itself:

```
(defn add-friend**
   "Add a friend to an existing person in the client database."
   [app-state person-id friend-id]
   (update-in app-state [:person/by-id person-id field-name] (fnil conj []) (person-ident friend-id)))

(defmutation add-friend [{:keys [source-person-id target-id]}]
  (action [{:keys [state]}]
    (swap! state add-friend** source-person-id target-id)))
```

=== Composition in Mutations

Once you have your general operations written as basic functions on either the entire state (like `update-person`) or
targeted to nodes or the state map itself (like `add-friend*`), then it becomes much easier to create mutations that
compose together operations to accomplish any higher-level task.

For example, the `fulcro.client.routing/update-routing-links` function takes a state map, and changes all of the routers
in the application state to show that particular screen. So, say you wanted add-friend to also
take you to the screen that shows the details of that particular person. The top-level abstract mutation in the UI
might still be called `add-friend`, but the internals now have two things to do.

Having all of these functions on the graph database allows you to write this in a very nice form as
a sequence of operations on the state map itself through threading:

```
(defmutation add-friend
  "Locally add a friend, and show them. Full stack operation.
  [{:keys [source-id target-id]}]
  (action [{:keys [state]}]
    (swap! state
      (fn [s]
        (-> s
          (r/update-routing-links {:handler :show-friend :route-params {:person-id target-id}})
          ; Could use (add-friend** source-id target-id) or:
          (update-person source-id add-friend* target-id)))))
  (remote [env] true)
```

and your mutations become a thing of beauty!

Of course, this can also be overkill. It is true that it is often handy to be able to compose many db operations together
into one abstract mutation, but don't forget that more that one mutation can be triggered by a single call
to `transact!`:

```
(prim/transact! this `[(route-to {:handler :show-friend :route-params {:person-id ~target-id}})
                       (add-friend {:source-person-id ~my-id :target-id ~target-id})])
```

You'll want to balance your mutations just like you do any other library of code: so that
reuse and clarity are maximized. In the case of mutations the deciding factor is often
how you want to deal with remote mutations.

== Advanced Mutation Topics

This section covers a number of additional mutation techniques that arise in more advanced situations.
Almost all of these circumstances arise
from needing to modify your application database *outside* of the normal `prim/transact!` mechanism at the UI layer.

A lot of these things are handled for you with normal <<FullStack,full-stack operations>>, so you might want to skip this
section until you're comfortable with that material.

=== Saving a Reconciler

The first note is that `prim/transact!` can be used on the <<Reconciler,reconciler>>. If you've saved your Fulcro Application
in a top-level atom then you can run a transaction "globally" like this:

```
(prim/transact! (:reconciler @app) ...)
```

This should generally be used in cases where there is an abstract operation (e.g. you want `setTimeout` to update
a js/Date to the current time and have the screen refresh). Using `(prim/transact! (:reconciler @app) '[(update-time) :current-time])` is
much clearer and in the spirit of the framework than any other low-level data tweaking. That could also be done in
the context of a component to prevent an overall root re-render, though you'd want to be careful to use both sides of
the component lifecycle to install *and* remove a timer that triggers such an update.

=== Swapping on the State Atom?

Yes. There is a watch on Fulcro's state atom. Doing so will cause a refresh from the root of your UI.

`(let [{:keys [reconciler]} @app
       state-atom (prim/app-state reconciler)]
  (swap! state-atom ...))`

=== Leveraging `fulcro.client.primitives/tree->db`

In some cases you will have obtained some data (or perhaps invented it) and you need to integrate that data into the
database. If the data matches your UI structure (as a tree) and you have proper `Ident` declarations on those components
then you can simply transform the data into the correct shape via the `tree->db` function using a component's
query.

Unfortunately, you would then need to follow that transform by a sequence of operations on app state to merge those
various bits.

The function also requires a query in order to do normalization (split the tree into tables).

IMPORTANT: The general interaction with the world requires integration of external data (often in a tree format) with
your app database (normalized graph of maps/vectors). As a result, you almost always want a component-based query when
integrating data so that the result is normalized.

===  Using `integrate-ident`

When in a mutation you very often need to place an ident in various spots in your graph database. The helper
function `fulcro.client/integrate-ident` can by used from within mutations to help you do this. It accepts
any number of named parameters that specify operations to do with a given ident:

```
(swap! state
  (fn [s]
    (-> s
       (do-some-op)
       (integrate-ident the-ident
         :append [:table id :field]
         :prepend [:other id :field]))))
```

This function checks for the existence of the given ident in the target list, and will refuse to add it if it is
already there. The `:replace` option can be used on a to-one or to-many relation. When replacing on a to-many, you
use an index in the target path (e.g. `[:table id :field 2]` would replace the third element in a to-many `:field`)

=== Creating Components *Just* For Their Queries

If your UI doesn't have a query that is convenient for sending to the server (or for working on tree data like this),
then it is considered perfectly fine to generate components just for their queries (no render). This is often quite
useful, especially in the context of pre-loading data that gets placed on the UI in a completely different form (e.g. the
UI queries don't match what you'd like to ask the server).

```
(defsc SubQuery [t p]
  {:ident [:sub/by-id :id]
   :query [:id :data]})

(defsc TopQuery [t p]
  {:ident [:top/by-id :id]
   :query [:id {:subs (prim/get-query SubQuery)}]})
```

++++
<div class="example" id="tree-to-db"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.tree-to-db').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="tree-to-db source"]
----
include::src/book/book/tree_to_db.cljs[]
----

of course, you can see that you're still going to need to merge the database table contents into your main app state
and carefully integrate the other bits as well.

.Reminder
****
The *`ident`* part of the component is the magic here. This is why you *need* component queries for
this work work right. The `ident` functions are used to determine the table locations and idents to place into
the normalized database!
****

=== Using `fulcro.client.primitives/merge!`

Fulcro includes a function that takes care of the rest of these bits for you. It requires the reconciler (which
as we mentioned earlier can be obtained from the Fulcro App). The arguments are similar to `tree->db`:

```
(prim/merge! (:reconciler @app) ROOT-data ROOT-query)
```

The same things apply as `tree->db` (idents especially), however, the result of the transform will make it's way into
the app state (which is owned by the reconciler).

*IMPORTANT*: The biggest challenge with using this function is that it requires the data and query to be structured
from the ROOT of the database! That is sometimes perfectly fine, but our next section talks about a helper that
might be easier to use.")

=== Using `fulcro.client.primitives/merge-component!`

There is a common special case that comes up often: You want to merge something that is in the context of some particular UI component.

```
(prim/merge-component! app ComponentClass ComponentData)
```

Think of this case as: I have some data for a given component (which MUST have an ident). I want to merge into that
component's entry in a table, but I want to make sure the recursive tree of data also gets normalized
properly.

`merge-component!` also integrates the functionality of `integrate-ident!` to pepper the ident of the merged entity throughout
your app database, and can often serve as a total one-stop
shop for merging data that is coming from some external source.

This first argument can be an application or reconciler.

==== Merge-component! Demo

In the card below the button simulates some external event that has brought in data that
we'd like to merge (a newly arrived counter entity):

```
{ :counter/id 5 :counter/n 66 }
```

We'll want to:

- Add the counter to the counter's table (which is not even present because we have none in our initial app state)
- Add the ident of the counter to the UI panel so it's UI shows up

```
(defsc Counter [this {:keys [counter/id counter/n] :as props} {:keys [onClick] :as computed}]
  {:query [:counter/id :counter/n]
   :ident [:counter/by-id :counter/id]}
   ...

(defn add-counter
  "Merge the given counter data into app state and append it to our list of counters"
  [reconciler counter]
  (prim/merge-component! reconciler Counter counter
    :append [:panels/by-kw :counter :counters]))

...
(defsc Root ...
  (let [reconciler (prim/get-reconciler this)]  ; one way to get to the reconciler
    (dom/button #js {:onClick #(add-counter reconciler {:counter/id 4 :counter/n 22})} "Simulate Data Import")
   ...
```

Here is the full running example with source:

++++
<div class="example" id="merge-component"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.merge-component').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="merge-component source"]
----
include::src/book/book/merge_component.cljs[]
----

= Full Stack Operation [[FullStack]]

One of the most interesting and powerful things about Fulcro is that the model for server interaction is unified into
a clean data-driven structure. At first the new concepts can be challenging, but once you've seen the core primitive
(component-based queries/idents for normalization) we think you'll find that it dramatically simplifies everything!

In fact, now that you've completed the materials of this guide on the graph database, queries, idents, and
normalization, it turns out that the server interactions become nearly trivial!

Not only is the *structure* of server interaction well-defined, Fulcro come with pre-written server-side code
that handle all of the Fulcro plumbing for you. You can choose to provide as little or as much as you like. The easy
server code provides everything in a Ring-based stack, and you can also choose to hand-build your server using
a simple API handler for the Fulcro API route.

Even then, there are a lot of possible pitfalls when writing distributed applications. People often underestimate just how hard
it is to get web applications right because they forget that.

So, while the *API and mechanics* of how you write Fulcro server interactions are as simple as possible there is no getting
around that there are some hairy things to navigate in distributed apps independent of your choice of tools.
Fulcro tries to make these things apparent, and it also tries hard to make sure you're able to get it right without
pulling out your hair.

Here are some of the basics:

* Networking is provided.
 ** The protocol is EDN on the wire (via transit), which means you just speak clojure data on the wire, and can
 easily extend it to encode/decode new types.
* All network requests (queries and mutations) are processed sequentially unless you specify otherwise. This allows you
to reason about optimistic updates (Starting more than one at a time via async calls could
lead to out-of-order execution, and impossible-to-reason-about recovery from errors).
* You may provide fallbacks that indicate error-handling mutations to run on failures.
* Writes and reads that are enqueued together will always be performed in write-first order. This ensures that remote reads are
as current as possible.
* Any `:ui/` namespaced query elements are automatically elided when generating a query from the UI to a server, allowing you
to easily mix UI concerns with server concerns in your component queries.
* Normalization of a remote query result is automatic.
* Deep merge of query results uses <<ResultMerge,intelligent overwrite>> for properties that are already present in the client database.
* Any number of remotes can be defined (allowing you to easily integrate with microservices).
* Protocol and communication is strictly constrained to the networking layer and away from your application's core structure,
meaning you can actually speak whatever and however you want to a remote. In fact
the concept of a remote is just "something you can talk to via queries and mutations".
You can easily define a "remote" that reads and writes browser
local storage or a Datascript database in the browser. This is an extremely powerful generalization for isolating
side-effect code from your UI.

NOTE: To those of you with REST APIs. Fulcro can be <<RESTAPI,made to work with REST>>, but full
stack data-driven architectures are often at odds with REST. You will end up writing a network layer on your
client that translates graph queries to one or more REST calls, and then combines those results into a tree of response
data that you can pass back up the chain. The UI is wonderfully protected from this, but when possible you
will find the most leverage by writing the server to support the graph queries directly (consider your REST API a legacy
thing that your new UI doesn't want/need). Things like GraphQL are a different story. That is a much simpler translation
layer.

== General Theory of Operation

There are only a few general kinds of interactions with a server:

* Initial loads when the application starts
* Incremental loads of sub-graphs of something that was previously loaded.
* Event-based loads (e.g. user or timed events)
* Integrating data from other external sources (e.g. server push)

In standard Fulcro networking, *all* of the above have the following similarities:

* A component-based graph query needs to be involved (to enable auto-normalization). Even the server push (though in that case the client needs to know what **implied** question the server is sending data about.
* The data from the server will be a tree that has the same shape as the query.
* The data needs to be normalized into the client database.
* Optionally: after integrating new data there may be some need to transform the result to a form the UI needs
(e.g. perhaps you need to sort or paginate some list of items that came in).

**IMPORTANT**: Remember what you learned about the graph database, queries, and idents. This section cannot possibly be understood
properly if you do not understand those topics!

=== Integration of *ALL* new external data is just a Query-Based Merge

So, here is the secret: When external data needs to go into your database it all uses the exact same mechanism: a
query-based merge. So, for a simple load: you send a UI-based query to the server, the server responds with a tree
of data that matches that graph query, and then the query itself (which is annotated with the components and ident functions)
can be used to normalize the result. Finally, the normalized result can be merged into your existing client database.

----
Query --> Server --> Response + Original Query w/Idents --> Normalized Data --> Database Merge --> New Database
----

Any other kind of extern data integration just starts at the "Response" step by manually providing the query that
is annotated with components/idents:

----
New External Data + Query w/Idents --> Normalized Data --> Database Merge --> New Database
----

There is a primitive function `merge!` function that implements this, so that you can simplify the picture to:

----
Tree of Data + Query --> merge! --> New Database
----

=== The Central Functions: `transact!` and `merge!`

The two core functions that allow you to trigger abstract operations or data merges externally
(via a <<Reconciler,reconciler>>) are:

[Horizontal]
`prim/transact!`:: The central function for running abstract changes in the application. Can be run with a component
_or_ reconciler. If run with the reconciler, will typically cause a root re-render.
`prim/merge!`:: A function that can be run against the reconciler to merge a tree of data via a UI query. This is
the primary function that is used to integrate data in response to things like websocket server push.

These (and related/derived helpers) are the primary tools to use when trying to make your application respond to
external stimuli that is not triggered from the UI.

=== Query Mismatch

We have all sorts of ways we'd like to view data. Perhaps we'd like to view "all the people who've ever had a particular
phone number". That is something we can very simply represent with a UI graph, but may not be trivial to pull from
our database.

In general, there are a few approaches to resolving our graph differences:

. Use a query parser on the server to piece together data based on the graph of the query.
. Ask the server for exactly what you want, using an invented well-known "root" keyword, and hand-code the database
code to create the UI-centric view.
. Ask the server for the data in a format it can easily provide and morph it on the client.

The first two have the advantage of making the client blissfully unaware of the server schema. It just asks for what
it needs, and someone on the server programming team is stuck with satisfying the query. This is the down-side: the number
of possible UI-centric queries could become quite large. Theoretically a parser solution makes this *more* tractable
than a hand-coded variant, but in practice the parser is hard to make general in a way that allows UI developers to just
run willy-nilly queries and get what they want.

In the example of "people who've had a particular phone number", the graph would be phone-number centric. Maybe
`[:db/id :phone/number {:phone/historical-owners (prim/get-query Person)}]`. There probably isn't a graph edge in the
real database called `:phone/historical-owners`.  One could write parser code that understood this particular edge,
and did the logic. In this case, that really isn't even that hard and may be a good choice.

Fulcro gives you another easy-to-access option: morph something the server can easily provide (on the
real graph without custom code). We'll show you an example of this as we explore the data fetch options.

=== Server Interaction Order

Fulcro will serialize requests unless you mark queries as parallel (an option you can specify on `load`). Two different
*events* that queue mutations or loads will be processed in order. For example The user clicks on something and you trigger two loads
during *that event*, then both of those will be combined (if they don't conflict by querying for the same thing)
sent as one network request. If the user clicks on something else and that handler queues two more loads, then the latter two
loads will not start over the network until the first load sequence has completed.

This ensures that you don't get out-of-order
server execution. This is a distributed system, so it is possible for a second request to hit a less congested server (or even thread)
than the first and get processed out of order. That would hurt your ability to reason about your program, so the default behavior in
Fulcro is to ensure that server interactions happen on the server in the same order as they do on the client.

If you combine mutations and reads in the same event processing (before giving up the thread), then Fulcro *also* ensures
that remote *mutations* go over the wire and complete *before* reads. The idea being that you don't want to fetch data
and then immediately make it stale through mutations. This additional detail is also aimed at preventing subtle classes
of application bugs.

In Summary:

- Loads/transactions queued while "holding the UI thread" will be joined together in a single network request.
- Remote writes go before reads
- Loads/transactions queued at a later event "new UI thread event" are guaranteed to be processed after ones queued earlier.
- You can override this behavior with the `parallel` option of `load`.

=== Server Result Query Merging [[ResultMerge]]

There is a potential for a data-driven app to create a new class of problem related to merging data. The normalization
guarantees that the data for any number of *views* of the same thing are normalized to the same *node* in the graph
database.

Thus, your `PersonListRow` view and `PersonDetail` view should both normalize the same person data to
a location like `[:person/by-id id]`. Let's say you have a quick list of people on the screen that is paginated and
demand-loaded, where each row is a `PersonListRow` with query `[:db/id :person/name {:person/image (prim/get-query Image)}]`.
Now say that you can click on one of these rows and a side-by-side view of that person's `PersonDetail` is shown,
but the query for that is a whole bunch of stuff: name, age, address, phone numbers, etc. A *much* larger query.

A naive merge could cause you all sorts of nightmares. For example, Refreshing the list rows would load only name and image,
but if merge overwrote the entire table *entry* then the current detail would suddenly empty out!

Fulcro provides you with an advanced merging algorithm that ensures these kinds of cases don't easily occur. It does an
intelligent merge with the following algorithm:

- It is a detailed deep merge. Thus, the target table entry is updated, not overwritten.
- If the query *asks* for a value but the result *does not* contain it, then that value *is removed*.
- If the query *didn't ask* for a value, then the existing database value is untouched.

This reduces the problem to one of potential staleness. It is technically possible for an entity in the resulting client
database to be in a state that has never existed on the server because of such a partial update. This is considered
to be a better result than the arbitrary UI madness that a more naive approach would cause.

For example, in the example above a query for a list row will update the name and image. All of the other details (if already
loaded) would remain the same; however, it is possible that the server has run a mutation that also updated this person's
phone number. The detail part of the UI will be showing an updated name and image, but the old phone number. Technically
this "state of Person" has never existed in the server's timeline, but from a user's perspective it looks better than
the phone number disappearing.

In practice this isn't that big of a deal; however, if you are switching the UI to an edit mode it is generally a good practice to
on-demand load the entity being edited to help prevent user confusion and accidental overwrite based on stale values.

=== React Lifecycle and Load

React lifecycle and Load may not mix well. It is technically legal to issue transactions and loads from React Lifecycle,
methods, but it is recommended that you carefully check the state of the system in said mutations before actually
queuing network traffic.
Perhaps you wish to ensure something is loaded. To do that: trigger a mutation that checks state and optionally
submits a load. You'll learn how to do this in the sections on the <<DataFetch, data featch API>>.

== The Data Fetch API: `load` [[DataFetch]]

Let's say we want to load all of our friends from the server. A query has to be rooted somewhere, so we'll invent
a root-level keyword, `:all-friends`, and join it to the UI query for a `Person`:

```
[{:all-friends (prim/get-query Person)}]
```

What we'd like to see then from the server is a return value with the shape of the query:

```
{ :all-frields [ {:db/id 1 ...} {:db/id 2 ...} ...] }
```

If we combine that query with that tree result and were to manually call `merge!` we'd end up with this:

```
{ :all-frields [ [:person/by-id 1] [:person/by-id 2] ...]
  :person/by-id { 1 { :db/id 1 ...}
                  2 { :db/id 2 ...}
                  ...}}
```

The data fetch API has a simple function for this that will do all of these together (query derivation, server
interaction, and merge):

```
(ns my-thing
  (:require [fulcro.client.data-fetch :as df]))

...

  (df/load comp-reconciler-or-app :all-friends Person)
```

An important thing to notice is that `load` can be thought of as a function that loads normalized data into the
root node of your graph (`:all-friends` appears in your root node).

This is sometimes what you want, but more often you really want data loaded at some other spot in your graph. We'll
talk about this more in a moment, first, let's see how to handle that on the server.

=== Handling a Root Query

If you're using the standard server support of Fulcro, then the API hooks are already predefined for you and you
can use helper macros to generate handlers for queries. If your `load` specified a keyword then this is seen by
the server as a load targeted to your root node. Thus, the server macro is called `defquery-root`:

```
(ns api
(:require [fulcro.server :refer [defquery-root defquery-entity defmutation]]))

(defquery-root :all-friends
   "optional docstring"
   (value [env params]
      [{:db/id 1 :person/name ....} {:db/id 2 ...} ...]))
```

It's as simple as that! Write a function that returns the correct value for the query. The query itself will be available
in the `env`, and you can use libraries like `pathom`, `Datomic`, and `fulcro-sql` to parse those queries into the proper tree
result from various data sources. See the <<QueryParsing,Query Parsing>> chapter.

=== Entity Queries

You can also ask to load a specific entity. You do this simply by telling load the ident of the thing you'd like to
load:

```
(load this [:person/by-id 22] Person)
```

Such a load will send a query to the server that is a join on that ident. The helper macro to handle those
is `defquery-entity`, and is dispatched by the table name:

```
(defquery-entity :person/by-id
   "optional docstring"
   (value [env id params]
      {:db/id id ...}))
```

Note that this call gets an `id` in addition to parameters (in the above call, `id` would be 22). Again, the full query
is in `env` so you can process the data driven response properly.

=== A Loading Example

This example shows two very common ways that data is loaded (or reloaded) in an application.

On startup, the following loads are run via the started callback:

```
(fc/new-fulcro-client
  :started-callback
    (fn [app]
      (df/load app :load-samples/people Person {:target [:lists/by-type :enemies :people]
                                                :params {:kind :enemy}})
      (df/load app :load-samples/people Person {:target [:lists/by-type :friends :people]
                                                :params {:kind :friend}})))
```

In this demo we're loading lists of people (thus the keyword's name). There are two kinds of people available from the
server: friends and enemies. We use the `:params` config parameter to add a map of parameters to the network request
to specify what we want. The `:target` key is the path to the (normalized) entity's property under which the response
should be stored once received.

Since all components should be normalized, this target path is almost always 2 (loading a whole component into a table)
or 3 elements (loading one or more things into a property of an existing component).

The server-side code for handling these queries uses a global table on the server, and is:

```
(def all-users [{:db/id 1 :person/name "A" :kind :friend}
                {:db/id 2 :person/name "B" :kind :friend}
                {:db/id 3 :person/name "C" :kind :enemy}
                {:db/id 4 :person/name "D" :kind :friend}])

; incoming param (kind) is destructured from third arg
(server/defquery-root :load-samples/people
  (value [env {:keys [kind]}]
    (let [result (->> all-users
                   (filter (fn [p] (= kind (:kind p))))
                   (mapv (fn [p] (-> p
                                   (select-keys [:db/id :person/name])
                                   (assoc :person/age-ms (now))))))]
      result)))
```

Once started, any given person can be refreshed at any time. Timeouts, user event triggers, etc. There are two ways
to refresh a given entity in a database. In the code of `Person` below you'll see that we are using `load` again, but
this time with an `ident`:

```
(df/load this (prim/ident this props) Person)
```

All of the parameters of this call can be easily derived when calling it from the component needing refreshed, so
there is a helper function called `refresh!` that makes this a bit shorter to type:

```
(df/refresh! this)
```

The server-side implementation of refresh for person looks like this:

```
(server/defquery-entity :load-samples.person/by-id
  (value [{:keys [] :as env} id p]
    (let [person (first (filter #(= id (:db/id %)) all-users))]
      (assoc person :person/age-ms (now))))) ; include a timestamp so we can see refreshes change something
```

++++
<div class="example" id="loading-data-basics"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.loading-data-basics').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="loading-data-basics source"]
----
include::src/book/book/demos/loading_data_basics.cljs[]
----

=== Targeting Loads

A short while ago we noted that loads are targeted at the root of your graph, and that this wasn't always what you
wanted. After all, your graph database will always have other UI stuff. For example there might be the concept of
a "current screen" (join from root) that might currently point to a "friends screen", which in turn is where you want
to load that list of friends:

```
{ :current-screen [:screens/by-type :friends]
  ...
  :screens/by-type { :friends { :friends/list [] ... }}}
```

If you've followed our earlier recommendations then your application's UI is normalized and any given
spot in your graph is really just an entry in a top-level table. Thus, the path to the desired location
of our friends is usually just 3 deep. In this case: `[:screens/by-type :friends :friends/list]`.

If we were to merge the earlier load into that database we could get what we want by just moving graph edges (where
a to-one edge is an ident, and a to-many edge is a vector of idents):

```
{ :all-frields [ [:person/by-id 1] [:person/by-id 2] ...]  ; (1) MOVE this to (2)
  :person/by-id { 1 { :db/id 1 ...}
                  2 { :db/id 2 ...}
  :current-screen [:screens/by-type :friends]
  :screens/by-type { :friends { :friends/list [] ... }}} ; (2) where friends *should* be
```

Since the graph database is just nodes and edges, there really aren't many more operations to worry about!
You've essentially got to *normalize a tree*, *merge normalized data*, and *move graph edges*.

The load API supports several kinds of graph edge targeting to allow you to put data where you want it in your
graph.

WARNING: Technically data is always loaded into the root, then relocated. So, be careful not to name your top-level
edge after something that already exists there!

==== Simple Targeting

The simplest targeting is to just relocate an edge from the root to somewhere else. The `load` function can do
that with a simple additional parameter:

```
(df/load comp :all-friends Person {:target [:screens/by-type :friends :friends/list]})
```

So, the server will still see the well-known query for `:all-friends`, but your local UI graph will end up seeing the
results in the list on the friends screen.

==== Advanced Targets

You can also ask the target parameter to modify to-many edges instead of replacing them. For example, say you
were loading one new person, and wanted to append it to the current list of friends:

```
(df/load comp :best-friend Person {:target (df/append-to [:screens/by-type :friends :friends/list])})
```

The `append-to` function in the `data-fetch` namespace augments the target to indicate that the incoming items
(which will be normalized) should have their idents appended onto the to-many edge found at the given location.

NOTE: `append-to` will not create duplicates.

The other available helper is `prepend-to`. Using a plain target is equivalent to full replacement.

You may also ask the targeting system to place the result(s) at more than one place in your graph. You do this
with the `multiple-targets` wrapper:

```
(df/load comp :best-friend Person {:target (df/multiple-targets
                                              (df/append-to [:screens/by-type :friends :friends/list])})
                                              [:other-spot]
                                              (df/prepend-to [:screens/by-type :summary :friends]))})
```

Note that `multiple-targets` can use plain target vectors (replacement) or any of the special wrappers.

==== An Example of Targeting

In the example below, you'll see we've set up two panes in a panel, and each pane can render a person.

Initially, there are no people loaded (none in initial state). The load buttons in the root component
let you see entity loads targeted at one or both of them.

The main loader looks like this (and is called from root):

```
(defn load-random-person [component where]
  (let [load-target  (case where
                       (:left :right) [:pane/by-id where :pane/person]
                       :both (df/multiple-targets
                               [:pane/by-id :left :pane/person]
                               [:pane/by-id :right :pane/person]))
        person-ident [:person/by-id (rand-int 100)]]
    (df/load component person-ident Person {:target load-target :marker false})))
```

The server is rather simple. It just makes up a person for any given ID:

```
(server/defquery-entity :person/by-id
  (value [env id params]
    {:db/id id :person/name (str "Person" id)}))
```

++++
<div class="example" id="loading-data-targeting-entities"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.loading-data-targeting-entities').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="loading-data-targeting-entities source"]
----
include::src/book/book/demos/loading_data_targeting_entities.cljs[]
----

=== Refreshing the UI After Load

The component that issued the load will automatically be refreshed when the load completes. You may use the data-driven
nature of the app to request other components refresh as well. The `:refresh` option tells the system what data has
changed due to the load. It causes all live components that have queried those things to refresh.
You can supply keywords and/or idents:

```
; load my best friend, and re-render every live component that queried for the name of a person
(df/load comp :best-friend Person {:refresh [:person/name]})
```

=== Other Load Options [[LoadOptions]]

Loads allow a number of additional arguments. Many of these are discussed in more detail in later sections:

[horizontal]
`:post-mutation` and `:post-mutation-params`:: A mutation to run once the load is complete (local data transform only).
`:remote`:: The name of the remote you want to load from.
`:refresh`:: A vector of keywords and idents. Any component that queries these will be re-rendered once the load completes.
`:parallel`:: Boolean. Defaults to false. When true, bypasses the sequential network queue. Allows multiple loads to run at once, but causes you to lose any guarantees about ordering since the server might complete them out-of-order.
`:fallback`:: A mutation to run if the server throws an error during the load.
`:without`:: A set of keywords to elide from the query. Covered in Incremental Loading.
`:params`:: A map. If supplied the params will appear as the params of the query on the server.
`:initialize bool|map`:: If true, uses component's initial state as a basis for incoming merge. If a map, uses the map as the basis for incoming merge.

==== Parallel vs. Sequential Loading

The `:parallel` option of `load` bypasses the normal network sequential queue. Below is a simple live
example that shows off the difference between regular loads and those marked parallel. In
order to see the effect increase your server latency to something like 5 seconds.

Normally, Fulcro runs separate event-based loads in sequence, ensuring that your reasoning can be synchronous;
however, for loads that might take some time to complete, and for which you can guarantee order of
completion doesn't matter, you can specify an option on load (`:parallel true`) that allows them to proceed in parallel.

Pressing the sequential buttons on all three (in any order) will take
at least 3x your server latency to complete from the time you click the first one (since each will run after the other is complete).
If you rapidly click the parallel buttons, then the loads will not be sequenced and you will see them all complete in roughly
1x your server latency (from the time you click the last one).

++++
<div class="example" id="parallel-vs-sequential-loading"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parallel-vs-sequential-loading').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parallel-vs-sequential-loading source"]
----
include::src/book/book/demos/parallel_vs_sequential_loading.cljs[]
----

==== Initializing Loaded Items

WARNING: This support is not complete yet (in version 2.0.0). It should be considered ALPHA and subject to change.

On occasion you may find that your entities have `:ui/???` attributes that you would like to
default to something on a loaded entity. This is the purpose of the `:initialize` option to load.
If it is set to `true`, then `load` will call `get-initial-state` on the component of the
load, and merge the return value from the server into that before merging it to app state.

Alternatively, you can pass `:initialize` a map, and that will be used as the target for
the server response merge before normalizing the result into app state.

NOTE: The value of `:initialize` must either be `true` or a map *that matches the correct
shape of the component's sub-tree of data*. It must *not* be a normalized database fragment.

The steps are:

. Send the request
. Merge the response into the basis defined by `:initialize`.
. Merge the result of (2) into the database using the component's query (auto-normalize)


==== Post Mutations – Morphing Loaded Data

The targeting system that we discussed in the prior section is great for cases where your data-driven query gets you
exactly what you need for the UI. In fact, since you can process the query on the server it is entirely possible that
load with targeting is all you'll ever need; however, from a practical perspective it may turn out that you've got a
server that can easily understand certain shapes of data-driven queries, but not others.

For example, say you were pulling a list of items from a database. It might be trivial to pull that graph of data
from the server from the perspective of a list of items, but let's say that each item had a category. Perhaps you'd like to
group the items by category in the UI.

The data-driven way to handle that is to make the server understand the UI query that has them grouped by category; however,
that implies that you might end up embedding code on your server to handle a way of looking at data that is really
specific to one kind of UI. That tends to push us back toward a proliferation of code on the server that was a nightmare
in REST.

Another way of handling this is to accept the fact that our data-driven queries have some natural limits: If the
database on the server can easily produce the graph, then we should let it do so from the data-driven query; however,
in some cases it may make more sense to let the UI morph the incoming data into a shape that makes more sense to that
UI.

[ditaa,target=server-interactions]
----
Query Result from Server

          |
          v

auto merge/normalize

          |
          v

   Items with Categories
(natural shape from the server)

          |
          v

    post mutation

          |
          v

    Items by Category
(shape we want in the UI)
----

We all understand doing these kinds of transforms. It's just data manipulation. So, you may find this has some
distinct advantages:

* Simple query to the server (only have to write one query handler) that is a natural fit for the database there.
* Simple layout in resulting UI database (normalized into tables and a graph)
* Straightforward data transform into what we want to show

===== Using `defsc` For Server Queries

It is perfectly legal to use `defsc` to define a graph query (and normalization) for something like this that doesn't exactly
exist on your UI. This can be quite useful in the presence of post mutations that can re-shape the data.

Simply code your (nested) queries using `defsc`, and skip writing the body:

```
(defsc ItemQuery [this props]
  {:query [:db/id :item/name {:item/category (prim/get-query CategoryQuery)}]
   :ident [:items/by-id :db/id]})
```

```
(df/load this :all-items ItemQuery {:post-mutation `group-items})
```

NOTE: We know that the name `defsc` seems a bit of a misnomer for this, so feel free to create an alias for it.

===== Live Demo of Post Mutations

The example below simulates post mutations to show how a load of simple data could be morphed into something
that the UI wants to display. In  this case we're pretending that the load has brought in a number of items
(as a collection) and normalized it, but we'd prefer to show the items organized by category..

You can interact with it and view the database to A/B compare the before/after state.

++++
<div class="example" id="morphing-example"></div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.morphing-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="morphing-example source"]
----
include::src/book/book/server/morphing_example.cljs[]
----

== Augmenting the Ring Response

The Ring stack is supplied for you in the server code and most responses are simple EDN with the HTTP details taken care
of for you; however, there are times when you need to modify something about the low-level response itself (such
as adding a cookie).

If you're using the Fulcro server tools (handle API request or the easy server) then you can add a fully general
response transform to your EDN response as follows:

```
(fulcro.server/augment-response your-EDN-response
  (fn [ring-response]
     ...
     modified-ring-response))
```

For example, if you were using Ring and Ring Session, you could cause a session cookie to be generated, and user
information to be stored in a server session store simply by returning this from a query on user:

```
(server/augment-response user (fn [resp] (assoc-in resp [:session :uid] real-uid)))
```

== Full-Stack Mutations

You've already seen how to define local mutations on the client. In this chapter we're going to go into the details
of making mutations work against the server.

== Remote Mutations

Mutations are already plain data, so Fulcro can pass them over the network as-is when the client invokes them. All you
need to do to indicate that a given mutation should affect a given remote is add that remote to the mutation:

```
(defmutation add-friend [params]
  (action ...) ; optimistic update of client state
  (remote [env] true)) ; send the mutation to the remote known as :remote

; or using the multimethod directly:
(defmethod m/mutate `add-friend [env k params]
  {:action (fn [] ...)
   :remote true})
```

Now you can see why choosing the right real mutations and amount of composition on the client
can give you optimal server interaction: Anything that you run in `transact!` itself can stand
alone as a remote mutation call in the transaction on the wire.

=== Optimistic by Default

The `action` portion of a mutation is run immediately on the client. When there is _also_ a server interaction
then the client-side operation is known as an *optimistic update* because by default we assume that the server
will succeed in replicating the action. This gives the user immediate feedback and the ability to proceed quickly
even in the presence of a slow network. We'll discuss more on error handling shortly.

=== Mutations Revisited

A multi-method in Fulcro client (which is manipualted with `defmutation`) can indicate that a given mutation
should be sent to any number of remotes. The default remote is named `:remote`, but you can define new ones or even
rename the default one.

The technical structure of this looks like:

```
(require [fulcro.client.mutations :refer [mutate]])

(defmethod mutate 'some/mutation [env k params]
  ;; sends this mutation with the same `env`, `k`, and `params` arguments to the server
  {:remote true
   :action (fn[] ... )})
```

or preferably using the `defmutation` macro:

```
(defmutation do-thing [params]
  (action [env] ...)
  (remote [env] true))
```

Basically, you use the *name* of the remote as an indicator of which remote you want to replicate the mutation to. From
there you either return `true` (which means send the mutation as-is), or you may return an expression AST that represents
the mutation you'd like to send instead. The `fulcro.client.primitives` namespace includes `ast->query` and `query-ast`
for arbitrary generation of ASTs, but the original AST of the mutation is also available in the mutation's environment.

Therefore, you can alter a mutation simply by altering and returning the `ast` given in `env`:

```
(defmutation do-thing [params]
  (action [env] ...)
  ; send (do-thing {:x 1}) even if params are different than that on the client
  (remote [{:keys [ast]}] (assoc ast :params {:x 1})) ; change the param list for the remote

; or using the with-params helper
(defmutation do-thing [params]
  (action [env] ...)
  ; send (do-thing {:x 1}) even if params are different than that on the client
  (remote [{:keys [ast]}] (m/with-params ast {:x 1})) ; change the param list for the remote
```

or even change which mutation the server sees:

```
(defmutation some-mutation [ params]
  ;; Changes the mutation from the incoming client-side some-mutation to server-mutation
  (remote [{:keys [ast] :as env}] (assoc ast :key 'server-mutation :dispatch-key 'server-mutation)))
```

WARNING: The `state` is available in `remote`, but the `action` will run first. This means that you should not
expect the "old" values in state when computing anything for the remote because the optimistic
update of the `action` will have already been applied! If you need to rely on data as it existed at the time of
`transact!` then you *must* pass it as a *parameter* to the mutation so that the original data is closed over for the
duration of the mutation processing.

=== Writing The Server Mutations

Server-side mutations in Fulcro are written the same way as on the client: A mutation returns a map with a key `:action`
and a function of no variables as a value. The mutation then does whatever server-side operation is indicated. The `env`
parameter on the server can contain anything you like (for example database access interfaces). You'll see how
to configure that when you study how to <<BuildingAServer, build a server>>.

The recommended approach to writing a server mutation is to use the pre-written server-side parser and multimethods, which allow you
to mimic the same code structure of the client (there is a `defmutation` in `fulcro.server` for this).

If you're using this approach (which is the default in the easy server), then here are the client-side and server-side
implementations of the same mutation:

```
;; client
;; src/my_app/mutations.cljs
(ns my-app.mutations
  (:require [fulcro.client.mutations :refer [defmutation]]))

(defmutation do-something [{:keys [p]}]
  (action [{:keys [state]}]
    (swap! state assoc :value p))
  (remote [env] true))
```

```
;; server
;; src/my_app/mutations.clj
(ns my-app.mutations
  (:require [fulcro.server :refer [defmutation]]))

(defmutation do-something [{:keys [p]}]
  (action [{:keys [some-server-database]}]
     ... server code to make change ...))
```

It is recommended that you use the same namespace on the client and server for mutations so it is easy to find them,
but the macro allows you to namespace the symbol if you choose to use a different namespace on the server:

```
(ns my-app.server
  (:require [fulcro.server :refer [defmutation]]))

(defmutation my-app.mutations/do-something [{:keys [p]}]
  (action [{:keys [some-server-database]}]
     ... server code to make change ...))
```

The ideal structure for many people is to use a CLJC file, where they can co-locate the mutations in the same
source file. The only trick is that you have to make sure you use the correct `defmutation`!

```
(ns my-app.api
  (:require
    #?(:clj [fulcro.server :as server]
       :cljs [fulcro.client.mutations :refer [defmutation]])))

  #?(:clj (server/defmutation do-thing [params]
          (action [server-env] ...))
    :cljs (defmutation do-thing [params]
            (remote [env] true)))
```

NOTE: The server namespace includes support for defining a server mutation in the browser. This allows you to simulate a server
in the browser instead of having to have a real server.

Please see <<BuildingAServer, Building A Server>> for more information about setting up a server with injected components in the mutation
environment.

==== The Server Multimethods for Mutations

The `defmutation` macro on the server simply hits a multimethod. You can use `defmethod` on `fulcro.server/server-mutate` to define your mutations. The advantage of this is that you might want
to write your own wrappers, macros, or code around the low-level implementation.

In general, we recommend using `defmutation` because it is better supported by IDEs (for navigation, docstrings, etc)
and eliminates some classes of syntactic error.

=== New item creation – Temporary IDs

Fulcro has a built in function `prim/tempid` that will generate a unique temporary ID. This allows the normalization
and denormalization of the client side database to continue working while the server processes the new data and returns
the permanent identifier(s).

The idea is that these temporary IDs can be safely placed in your client database (and network queues), and will be
automatically rewritten to their real ID when the server has managed to create the real persistent entity. Of course, since
you have optimistic updates on the client it is important that things go in the correct sequence, and that queued operations
for the server don't get confused about what ID is correct!

WARNING: Because mutation code can be called multiple times (at least once + once per each remote),
you should take care to not call `fulcro.client.primitives/tempid` inside your mutation.
Instead call it from your UI code that builds the mutation params.

Fulcro's implementation works as follows:

. Mutations always run in the order specified in the call to `transact!`
. Transmission of separate calls to `transact!` run in the order they were called.
. If remote mutations are separated in time, then they go through a sequential networking queue, and are processed in order.
. As mutations complete on the server, they return tempid remappings. Those are applied to the application state *and* network
queue before the next network operation (load or mutation) is sent.

This set of rules helps ensure that you can reason about your program, even in the presence of optimistic updates that
could theoretically be somewhat ahead of the server.

For example, you could create an item, edit it, then delete it. The UI responds immediately, but the initial create might
still be running on the server. This means the server has not even given it a real ID before you're queuing up a request
to delete it! With the above rules, it will just work! The network queue will have two backlogged operations (the edit
and the delete), each with the same tempid that you currently know. When the create finally returns
it will automatically rewrite all of the tempids in state and the network queues, then send the next operation. Thus,
the edit will apply to the current server entity, as will the delete.

All the server code has to do is return a map with the special key `:fulcro.client.primitives/tempids`
(or the legacy `:tempids`) whose value is a map of `tempid->realid` whenever it sees an ID during persistence operations.
Here are the client-side and server-side implementations of the same mutation that create a new item:

```
;; client
;; src/my_app/mutations.cljs
(ns my-app.mutations
  (:require [fulcro.client.mutations :refer [defmutation]]))

(defmutation new-item [{:keys [tempid text]}]
  (action [{:keys [state]}]
    (swap! state assoc-in [:item/by-id tempid] {:db/id tempid :item/text text}))
  (remote [env] true))
```

```
;; server
;; src/my_app/mutations.clj
(ns my-app.mutations
  (:require [fulcro.client.primitives :as prim]
            [fulcro.server :refer [defmutation]]))

(defmutation new-item [{:keys [tempid text]}]
  (action [{:keys [state]}]
    (let [database-tempid (make-database-tempid)
          database-id (add-item-to-database database {:db/id database-tempid :item/text text})]
      {::prim/tempids {tempid database-id}})))
```

Other mutation return values are covered in Mutation Return Values.

=== Remote Reads After a Mutation

In earlier sections you learned that you can list properties with your mutation to indicate re-renders.
These follow-on read keywords are always local re-render reads, and nothing more:

```
(prim/transact! this '[(app/f) :thing])
; Does mutation, and re-renders anything that has :thing in a query
```

Fulcro will automatically queue remote reads *after* writes when they are submitted in the same thread interaction:

```
(prim/transact! this `[(f)])
(df/load this :thing Thing)
(prim/transact! this `[(g)])
```

will result in two network interactions. The first will run `[(f) (g)]`, and the second will be a load of `:thing`. This
is a defined and official behavior.

Thus, one way you can implement a sequence of mutation followed by learning a result is to run a mutation and a load.

=== Pessimistic Transactions [[PTransact]]

There are scenarios where the above behavior is not what you want. In particular are cases like form submission where
you might want to wait until the server completes, so that the user can be kept in the form until you've confirmed
the server isn't down or something.

Fulcro 2.0+ has support for pessimistic transactions that enable exactly this sort of behavior:

```
(prim/ptransact! this `[(a) (b)])
```

Will run `a`'s action, `a`'s remote, *then* `b`'s action and `b`'s remote.
This can be combined with analysis of <<ReturnValues, mutation return values>> to allow you to follow a remote operation with a UI one:

```
; assume submit-my-form blocks the UI, and leave-form-if-ok checks app state and moves on.
(prim/ptransact! this `[(submit-my-form) (leave-form-if-ok)])
```

WARNING: Use caution when using mutations with *conditional* remote behavior.
`ptransact!` detects which mutations are remote by pre-running them (they are side-effect free)
against the app state *as it is at the beginning of the transaction*. If you have a mutation in the middle
that relies on the state modifications of a prior mutation in the same transaction in order to *decide* if
it is remote then it will be mis-detected.

=== Using Loads as Mutations

There is technically nothing wrong with issuing a load that has side-effects on the server (though one could argue that
this is a bit sketchy from a design perspective). For example, one way to
implement login is to issue a load with the user's credentials:

```
(df/load :current-user User {:params {:username u :password p}})
```

The server query response can validate the credentials, set a cookie, and return the user info all at once! Your UI can
simply base rendering on the values in `:current-user`. If they're valid, you're logged in.

If you remember from the General Operations section, you can modify the low-level Ring response by associating a lambda
with your return value. If you were using Ring Session, then this might be how the query would be implemented on the server:

```
(ns my-api
  (:require [fulcro.server :as server :refer [defmutation defquery-root]]))

(def bad-user {:db/id 0})

(defquery-root :current-user
  (value [env params]
    (if-let [{:keys [db/id] :as user} (authenticate params)] ; look up the user, return nil if bad
      (server/augment-response user (fn [resp] (assoc-in resp [:session :uid] id)))
      bad-user)))
```

=== Running Mutations in the Context of an Entity

If you submit a transaction and include an ident:

```
(transact! reconciler [:person/by-id 4] `[(f)])
```

then the transaction will run as-if it were executed in the context of any live component on the screen that currently has
that ident. This will make the ident available in the mutation's environment as `:ref`, and will focus refresh at that
component sub-tree(s). This can be useful when you have out-of-band data that causes you to want to run a
transaction outside of the UI using the reconciler.

=== Mutations that Trigger one or more Loads

Mutations generally need not expose their full-stack nature to the UI. For
example a `next-page` mutation might trigger a load for the next page of
data or simply swap in some already cached data. The UI need not be
aware of the logic of this distinction (though typically the UI will
want to include loading markers, so it is common for there to be some
kind of knowledge about lazy loading).

Instead of coding complex "do I need to load that?" logic in the UI
(where it most certainly does *not* belong) one should instead write
mutations that abstract it into a nice concept.

Fulcro handles loads by placing load markers into a special place in the
application database. Whenever a remote operation is triggered, the
networking layer will check this queue and process it.

The `fulcro.client.data-detch/load` function simply runs a `transact!`
that does both (adds the load to the queue and triggers remote processing).

If you'd like to compose one or more loads into a mutation, there are helper
functions that will help you do just that: `df/load-action` and `df/remote-load`.

The basic pattern is:

```
(defmutation next-page [params]
  (action [{:keys [state] :as env}]
    (swap! state ...) ; local optimistic db updates
    (df/load-action env :prop Component {:remote :remote}) ; same basic args as `load`, except state atom instead of `this`
    (df/load-action env :other Other) {:remote :other-remote}) ; as many as you need...
  (remote [env]
    (df/remote-load env))) ; notifies back-end that there is some loading to do
```

IMPORTANT: The `remote-load` call need only be done for *any one* of the remotes you're talking to. It merely tells the
back-end code to process remote requests (which will hit all remote queues). Thus, the parameters to the `load-action`
calls are where you actually specify which remote a given load should actually talk to.

== Network Activity Indicators

Rendering is completely up to you, but Fulcro handles the networking (technically this is pluggable, but Fulcro still initiates
the interactions). That means that you're going to need some help when it comes to showing the user that something is happening on the network.

The first and easiest thing to use is a global activity marker that is automatically maintained at the root node of
your client database.

=== Global network activity marker

Fulcro will automatically maintain a global network activity marker at the top level of the app state under the
keyword `:ui/loading-data`. This key will have a `true` value when there are network requests awaiting a response from
the server, and will have a `false` value when there are no network requests in process.

You can access this marker from any component that composes to root by including a link in your component's query:

```
(defsc Item ... )
(def ui-item (prim/factory Item {:keyfn :id}))

(defsc List [this {:keys [title items ui/loading-data]}]
  {:query [:id :title {:items (prim/get-query Item)} [:ui/loading-data '_]]}
  ...
  (if (and loading-data (empty? items))
    (dom/div nil "Loading...")
    (dom/div nil
      (dom/h1 nil title)
      (map ui-item items))))
```

Because the global loading marker is at the top level of the application state, do not use the keyword as a follow-on
read to mutations because it may unnecessarily trigger a re-render of the entire application.

=== Mutation Activity

Mutations can be passed off silently to the server. You may choose to block the UI if you have reason to believe there
will be a problem, but there is usually no other reason to prevent the user from just continuing to use your application
while the server processes the mutation. Thus, only the global activity marker is available for mutations. See
<<PTransact, Pessimistic Transactions>> for a method of controlling UI around the network activity of remote mutations.

=== Tracking Specific Loads

Loads are a different story. It is very often the case that you might have a number of loads running to populate different
parts of your UI all at once. In this case it is quite useful to have some kind of load-specific marker that you
can use to show that activity.

In Fulcro 1.0+ this can be done as follows:

* The target of each load is replaced by a *load marker* until the load completed
* You can detect these load markers and show an alternate UI while they are loading.
** The component that is to be loaded *must* include `:ui/fetch-state` in its query (this is the key under which the marker is placed)
** The `data-fetch` namespace has utility functions for detecting the state of the marker, though usually just its presence is enough.
* When the data arrives the load marker is replaced by it.

==== A Live Example of 1.x Load Indicators

By default Fulcro places markers where the items will appear that are being loaded. These markers can be used to show progress indicators in
the UI.

In the demo below the first button triggers a load of a child's data from the server. Use the server latency controls to slow things down so you
can see the markers. Once the child is loaded, a button appears indicating items can be loaded into that child.

Once the items are loaded, each has a refresh button. Again, use the server delay so you can watch the
markers.

++++
<div class="example" id="legacy-load-indicators"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.legacy-load-indicators').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="legacy-load-indicators source"]
----
include::src/book/book/demos/legacy_load_indicators.cljs[]
----

This is still supported (and is still currently the default); however, it is deprecated because it was found to be less than ideal:

. It caused the old data to disappear. There was no place else to put the targeted load marker except *over* the old data.
This caused flicker and workarounds (such as mis-targeting the data and using post-mutations to put it in place at the end)
. The load markers are rather large. Looking at your component's app state during a load is kind of ugly.
. The load markers could not be queried from elsewhere, meaning activity indicators had to be local to the loaded data.
. Worst: you have to add `:ui/fetch-state` to the query of the component representing the thing being loaded, or the load marker
isn't available.

=== Normalized Load Markers

In Fulcro 2.0, it is recommended that you use a keyword (of your own invention) for the `:marker` option instead. This
has the following behavior:

. Load markers are placed in a top-level table (the var fulcro.client.data-fetch/marker-table holds the table name),
using your keyword as their ID. They are normalized!
. You can therefore explicitly query for them using an ident join

This solves all of the prior system's weaknesses.

==== Working with Normalized Load Markers

The steps are rather simple: Include the `:marker` parameter with load, and issue a query for the load marker on
the marker table. The table name for markers is stored in the data-fetch namespace in the var `df/marker-table`.

```
(defsc SomeComponent [this props]
  {:query [:data :prop2 :other [df/marker-table :marker-id]]} ; an ident in queries pulls in an entire entity
  (let [marker (get props [df/marker-table :marker-id])]
    ...)))

...

(df/load this :key Item {:marker :marker-id})
```

The data fetch load marker will be missing if no loading is in progress. You can use the following functions
to detect what state the load is in:

* `(df/ready? m)` - Returns true if the item is queued, but not yet active on the network
* `(df/loading? m)` - Returns true if the item is active on the network

The marker will disappear from the table when network activity completes.

The rendering is up to you, but that is really all there is to it.

===== Marker IDs for Items That Have Many Instances

The most confusing part of normalized load markers is that the IDs are keywords, but you may need a marker for a specific
entity. Say you have a list of people, and you'd like to show an activity marker on the one you're refreshing. You
have many on the screen, so you can't just use a simple keyword as the marker ID or they might all show a loading
indicator when only one is updating.

In this case you will need to generate a marker ID based on the entity ID, and then use a link query to pull the
entire load marker table to see what is loading.

For example, you might define the marker IDs as `(keyword "person-load-marker" (str person-id))`. Your person
component could then find its load marker like this:

```
(defn person-markerid [id] (keyword "person-load-marker" (str id)))

(defsc Person [this {:keys [db/id person/name] :as props}]
  {:query [:db/id :person/name [df/marker-table '_]]
   :ident [:person/by-id :db/id]}
  (let [marker-id   (person-markerid id)
        all-markers (get props df/marker-table)
        marker      (get all-markers marker-id)]
      ...))
```

the load might look something like this:

```
(df/load this [:person/by-id 42] Person {:marker (person-markerid 42)})
```

The example below uses these techniques to name load markers.

NOTE: Open up the DB view and turn your server's latency way up so you can watch the marker state.

++++
<div class="example" id="loading-indicators"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.loading-indicators').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="loading-indicators source"]
----
include::src/book/book/demos/loading_indicators.cljs[]
----

== Server Mutation Return Values [[ReturnValues]]

The server mutation is always allowed to return a value. Normally the only value that makes sense is the temporary ID
remapping as previoiusly discussed in the main section of full-stack mutations. It is automatically processed by the client
and causes the tempid to be rewritten everywhere in your state and network backlog:

```
; server-side
(defmutation new-thing [params]
  (action [env]
    ...
    {::prim/tempids {old-id new-id}}))
```

In some cases you'd like to return other details. However, remember that
any data merge needs a tree of data *and* a query. With a mutation *there is no query*!
As such, return values from mutations are **ignored by default** because there is no way to understand how to
merge the result into your database. Remember we're trying to eliminate the vast majority of callback hell and keep
asynchrony out of the UI. The processing pipeline is always: update the database state, re-render the UI.

If you want to make use of the returned values from the server then you need to add something to remedy the
lack of a query.

=== Using Mutation Joins [[MutationJoins]]

The solution might be obvious to you: include the query with the mutation! This is called a *mutation join*.
The explicit syntax for a mutation join looks like this:

```
`[{(f) [:x]}]
```

but you never write them this way because a manual query doesn't have ident information and cannot aid normalization. Instead,
you write them just like you do when grabbing queries for anything else:

```
`[{(f) ~(prim/get-query Item)}]
```

Running a mutation with this notation allows you to return a value from the server's mutation that exactly matches the graph
of the item, and it will be automatically normalized and merged into your database. So, if the `Item` query ended up being
`[:db/id :item/value]` then the server mutation could just return a simple map like so:

```
; server-side
(defmutation f [params]
  (action [env]
     {:db/id 1 :item/value 42})) ; ok to return one (a map) OR many (as a vector of maps)
```

NOTE: At the time of this writing the query must come from a UI component that *has an ident*. Thus, mutations joins
essentially normalize things into a specific table in your database (determined by the ID(s) of the return
value and the ident on the query's component). Newer versions may relax this restriction.

=== Mutation Joins: Simpler Notation [[ASTMutationJoins]]

Writing `transact!` using mutation joins is a bit visually noisy. It turns out there is a better way.
If you remember: the remote section of client mutations can return a boolean *or an AST*. Fulcro comes with helper functions that can
rewrite the AST of the mutation to modify the parameters or convert it to a mutation join! This can simplify how the
mutations look in the UI.

Here's the difference. With the manual syntactic technique we just described your UI and client mutation would look something like this:

```
; in the UI
(transact! this `[{(f) ~(prim/get-query Item)}])

; in your mutation definition (client-side)
(defmutation f [params]
  (action [env] ...)
  (remote [env] true))
```

However, using the helpers you can instead write it like this:

```
(ns api
  (:require [fulcro.client.mutations :refer [returning]]))

; in the UI
(transact! this `[(f)])

; in your mutation definition (client-side)
(defmutation f [params]
  (action [env] ...)
  (remote [{:keys [ast state]}] (returning ast state Item))
```

This makes the mutation join an artifact of the *network interaction*, and less for you to manually code (and read) in the UI.

The server-side code is the same for both: just return a proper graph value!

=== Targeting Return Values From Mutation Joins

If you use the <<ASTMutationJoins, AST with mutation joins>>, then Fulcro gives you an additional bonus:
A helper you can use with your mutation to indicate that the given mutation return value
should be *further integrated* into your app state. By default, you're just returning an entity. The data gets
normalized, but there is no further linkage into your app state.

You will sometimes want to pepper idents around your app state as a result of the return. You can add this
kind of targeting through the AST in the remote (not available at the UI layer):

```
(defmutation f [params]
  (action [env] ...)
  (remote [{:keys [ast state]}]
    (-> ast
      (m/returning state Item)
      (m/with-target [:path :to :field])))
```

Special targets are also supported:

```
(defmutation f [params]
  (action [env] ...)
  (remote [{:keys [ast state]}]
    (-> ast
      (m/returning state Item) ; Returns something of type Item, will merge/normalize
      (m/with-target           ; Place the ident pointing to the loaded item in app state at additional locations
        (df/multiple-targets
          (df/append-to [:table 3 :field])
          (df/prepend-to [:table-2 4 :field]))))))
```

==== Demo of Mutation Joins

The demo below cover the basics of using mutation joins.
It demonstrates:

* Targeting Raw Values
+
If you don't specify a component with `returning`, then your returned data can be targeted, but of course it
won't normalize. The error triggering mutation does this:
+
```
(defmutation  trigger-error
  "This mutation causes an unstructured error (just a map), but targets that value
   to the field `:error-message` on the component that invokes it."
  [_]
  (remote [{:keys [ast ref]}]
    (m/with-target ast (conj ref :error-message))))
```
+
and the server simply returns a raw value (map is recommended)
+
```
(server/defmutation trigger-error [_]
  (action [env]
    {:error "something bad"}))
```
* Targeting Graph Results
+
In the demo The bulk of the work is done in the `create-entity` mutation.
which is targeting to-many so we can demo more features.
+
```
(defmutation  create-entity
  "This mutation simply creates a new entity, but targets it to a specific location
  (in this case the `:child` field of the invoking component)."
  [{:keys [where?] :as params}]
  (remote [{:keys [ast ref state]}]
    (let [path-to-target (conj ref :children)
          ; replacement cannot succeed if there is nothing present...turn those into appends
          no-items?      (empty? (get-in @state path-to-target))
          where?         (if (and no-items? (= :replace-first where?))
                           :append
                           where?)]
      (cond-> (-> ast
                ; always set what kind of thing is coming back
                (m/returning state Entity)
                ; strip the where?...it is for local use only (not server)
                (m/with-params (dissoc params :where?)))
        ; Add the targeting...based on where?
        (= :append where?) (m/with-target (df/append-to path-to-target)) ; where to put it
        (= :prepend where?) (m/with-target (df/prepend-to path-to-target))
        (= :replace-first where?) (m/with-target (df/replace-at (conj path-to-target 0)))))))
```
+
The server mutation just returns the entity (mixed with tempid remappings, if you need them).
+
```
(server/defmutation create-entity [{:keys [db/id]}]
  (action [env]
    (let [real-id (swap! ids inc)]
      {:db/id        real-id
       :entity/label (str "Entity " real-id)
       :tempids      {id real-id}})))
```

++++
<div class="example" id="server-targeting-return-values-into-app-state"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.server-targeting-return-values-into-app-state').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="server-targeting-return-values-into-app-state source"]
----
include::src/book/book/demos/server_targeting_return_values_into_app_state.cljs[]
----

=== Augmenting the Merge

There is also a sledge-hammer approach to return values: plug into Fulcro's merge routines. This is an advanced technique
and is not recommended for most applications.

Fulcro gives a hook for a `mutation-merge` function that you can install when you're creating the application. If you
use a multi-method, then it will make it easier to co-locate your return value logic near the client-local mutation itself:

```
(defmulti return-merge (fn [state mutation-sym return-value] mutation-sym))
(defmethod return-merge :default [s m r] s)

(new-fulcro-client :mutation-merge return-merge ...)
```

Now you should be able to write your return merging logic next to the mutation that it goes with. For example:

```
(defmethod m/mutate 'some-mutation [env k p] {:remote true })
(defmethod app/return-merge 'some-mutation [state k returnval] ...new-state...)
```

Note that the API is a bit different between the two: mutations get the app state *atom* in an environment, and you
`swap!` on that atom to change state. The return merge function is *in an already running* `swap!` during the state merge
of the networking layer. So, it is a function that takes the application state as a *map* and must
return a new state as a *map*.

This technique is fully general in terms of handling arbitrary return values, but is limited in that your only recourse
is to merge the data into you app state. Of course, since your rendering is a pure function of app state this means you
can, at the very least, visualize the result.

This works, but is not the recommended approach because it is very easy to make mistakes that affect your entire
application.

NOTE: Mutation merge happens after server return values have been merged; however, it does happen *before* tempid remapping.
Just work with the tempids, and they will be rewritten once your merge is complete.

==== Live Example of a Mutation Merge

In the example below the displayed volume is coming from the server's mutation return value.
Use the server latency to convince yourself of this. Notice if you click too rapidly then the value doesn't increase
any faster than the server can respond (since it computes the new volume based on what the client sends).

The merge function is most easily dealt with as a multimethod so you can dispatch on the mutation symbol:

```
(defmulti merge-return-value (fn [state sym return-value] sym))
```

We're going to return a map with `:new-volume` in it from the server, so our merge can look like this:

```
(defmethod merge-return-value `crank-it-up
  [state _ {:keys [new-volume]}]
  (assoc-in state [:child/by-id 0 :volume] new-volume))
```

Our mutation asks a remote server to increase the volume. The client and server mutations are:

```
;; client-side
(m/defmutation crank-it-up [params]
  (remote [env] true))
```

```
(server/defmutation crank-it-up [{:keys [value]}]
  (action [env]
    {:new-volume (inc value)}))
```

The remainder of the setup is just giving the merge handler function to the application at startup:

```
(fc/new-fulcro-client :mutation-merge merge-return-value)
```

++++
<div class="example" id="server-return-values-manually-merging"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.server-return-values-manually-merging').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="server-return-values-manually-merging source"]
----
include::src/book/book/demos/server_return_values_manually_merging.cljs[]
----

== Loads From Within Mutations

It is often the case that a load results from user interaction with the UI. But it is also the case that the
load isn't everything you want to do, or that you'd like to hide the load logic or base it on current state that
the triggering component does not know.

=== Load Actions in Mutations

In reality `load` and `load-field` call `prim/transact!` under the hood, targeting fulcro's built-in `fulcro/load`
mutation, which is responsible for sending your request to the server.

There are similar functions: `load-action` and `load-field-action`
that **do not** call `prim/transact!`, but instead just push a load request into the load queue and can be used to
inside of one of your own client-side mutations.

Let's look at an example of a standard load. Say you want to load a list of people from the server:

```
(require [fulcro.client.data-fetch :as df])

(defsc Person [this props]
  {:query [:id :name]}
  ... )
(def ui-person (prim/factory Person))

(defsc PeopleList [this {:keys [people]}]
  {:query [:db/id :list-title {:people (prim/get-query Person}]
   :ident [:people-list/by-id :db/id]}
   (dom/div nil
     (if (seq people)
       (dom/button #js {:onClick #(df/load-field this :people)} "Load People")
       (map ui-person people))))
```

Since we are in the UI and not inside of a mutation's action thunk, we can use `load-field` to initialize the
call to `prim/transact!`.

The action-suffixed load functions are useful when performing an action in the user interface that must *both* modify
the client-side database *and* load data from the server.

NOTE: You must use the result of the
`fulcro.client.data-fetch/remote-load` funtion as the value of the `remote` in the mutation. The
`action` calls of `load-action` place the request on a queue. The `remote-load` returns the correct indicator to
Fulcro so that it knows you queued a load. If you forget it, then your load won't be processed until the next
operation causes remote interactions.

```
(require [fulcro.client.data-fetch :as df]
         [fulcro.client.mutations :refer [mutate]]
         [app.ui :as ui])

(defmutation change-view [{:keys [new-view]}]
  (action [{:keys [state] :as env}]
              (let [new-view-comp (cond
                                     (= new-view :main)  ui/Main
                                     (= new-view :settings) ui/Settings]
                (df/load-action env new-view new-view-comp)  ;; Add the load request to the queue
                (swap! state update :app/current-view new-view))}))
  (remote [env] (df/remote-load env))) ;; Tell Fulcro you did something that requires remote
```

This snippet defines a mutation that modifies the app state to display the view passed in via the mutation parameters
and loads the data for that view. A few important points:

. If an action thunk calls one or more `action`-suffixed load functions (which do nothing but queue the load
   request) then it MUST also call `remote-load` on the remote side.
. The `remote-load` function *changes* the mutation's dispatch key to `fulcro/load` which in turn triggers
   the networking layer that one or more loads are ready. IMPORTANT: Remote loading cannot be mixed with a mutation
   that also needs to be sent remotely. I.e. one could not send `change-view` to the server in this example.
. If you find yourself wanting to put a call to any `load-*` in a React Lifecycle method try reworking
   the code to use your own mutations (which can check if a load is really needed) and the use the action-suffixed
   loads instead. Lifecycle methods are often misunderstood, leading to incorrect behaviors like triggering loads
   over and over again.

=== Using the `fulcro/load` Mutation Directly (NOT recommended)

Fulcro has a built-in mutation `fulcro/load` (also aliased as `fulcro.client.data-fetch/load`).

The mutation can be used from application startup or anywhere you'd run a mutation (`transact!`). This covers almost
all of the possible remote data integration needs!

The helper functions described above simply trigger this built-in Fulcro mutation
(the `*-action` variants do so by modifying the remote mutation AST via the `remote-load` helper function).

You are allowed to use this mutation directly in a call to `transact!`, but you should never need to.

The arguments to this mutation include <<LoadOptions, most of the options that `load` can take>>, but you do
need to specify `query`. For most direct use-cases you'll probably skip using the `load-field` specific parameters
described in the docstring (`:field` and `:ident`). You can read the source of `load-field` if you'd like to simulate
it by hand.

For example:

```
(load reconciler :prop nil)
```

is a simple helper that is ultimately identical to:

```
(prim/transact! reconciler '[(fulcro/load {:query [:prop]}) :ui/loading-data])
```

(the follow-on read is to ensure load markers update).

== Incremental Loading [[IncrementalLoading]]

It is very common for your UI query to have a lot more in it than you want to load at any given time. In some cases,
even a specific entity asks for more than you'd like to load. A good example of this is a component that allows comments.
Perhaps you'd like the initial load of the component to not include the comments at all, then later load the comments
when the user, for example, opens (or scrolls to) that part of the UI.

Fulcro makes this quite easy. There are three basic steps:

. Put the full query on the  UI
. When you use that UI query with load, prune out the parts you don't want.
. Later, ask for the part you *do* want.

Step 2 sounds like it will be hard, but it isn't:

=== Pruning the Query

Sometimes your UI graph asks for things that you'd like to load incrementally. Let's say you were loading a blog
post that has comments. Perhaps you'd like to load the comments later:

```
(df/load app :server/blog Blog {:params {:id 1 }
                                :target [:screens/by-name :blog :current-page]
                                :without #{:blog/comments}})
```

The `:without` parameter can be used to elide portions of the query (it works recursively). The query sent to the
server will *not* ask for `:blog/comments`. Of course, your server has to parse and honor the exact details
of the query for this to work (if the server decides it's going to returns the comments, you get them...but this is why
we disliked REST, right?)

```
(server/defquery-root :server/blog
  (value [{:keys [query]} {:keys [id]}] ; query will be the query of Blog, without the :comments
     ; use a parser on query to get the proper blog result. See Server Interactions - Query Parsing
     (get-blog id query)))
```

=== Filling in the Subgraph

Later, say when the user scrolls to the bottom of the screen or clicks on "show comments" we can load the rest
from of this previously partially-loaded graph within the Blog itself using `load-field`, which does the opposite
of `:without` on the query:

```
(defsc Blog [this props]
  {:ident  [:blog/by-id :db/id]
   :query  [:db/id :blog/title {:blog/content (prim/get-query BlogContent)} {:blog/comments (prim/get-query BlogComment)}]}
  (dom/div nil
     ...
     (dom/button #js {:onClick #(load-field this :blog/comments)} "Show Comments")
     ...)))
```

The `load-field` function prunes everything from the query *except* for the branch
joined through the given key. It also generates an *entity rooted query* based on the calling component's ident:

```
[{[:table ID] subquery}]
```

where the `[:table ID]` are the ident of the invoking component, and subquery is `(prim/get-query invoking-component)`, but
focused down to the one field. In the example above, this would end up something like this:

```
[{[:blog/by-id 1] [{:blog/comments [:db/id :comment/author :comment/body]}]}]
```

This kind of query can be handled on the server with `defquery-entity` (which is triggered on these kinds of ident joins):

```
(server/defquery-entity :blog/by-id
  (value [{:keys [query]} id params]
    (get-blog id query))) ; SAME HANDLER WORKS!!!
```

== Full-Stack Error Handling [[FullStackErrorHandling]]

The first thing I want to challenge you to think about is this: why do errors happen, and what can we do about them?

In the early days of web apps, our UI was completely dumb: the server did all of the logic. The answer to these questions
were clear, because it wasn't even a distributed app: it was a *remote display* of an app running on a *remote machine*.
In other words, the context of the error handling was available at the same time as our request to do the operation.

So we often block the UI so that the user cannot get ahead of things (like
submit a form and move on before the server has confirmed the submission).
Over the years we've gotten a little more clever with our error handling, but largely our users (and our ability
to reason about our programs) has kept us firmly rooted to the block-until-we-know method of error handling because
it is actually *less like* a distributed system. Unfortunately, such UI interactions are doomed to feel sluggish
in congested or bandwidth-limited environments.

More and more code is moving to the client machine. In the world of single-page apps we want
things to "make sense" and we also want them to be snappy. Unfortunately, we still also have security concerns
at the server, so we get confused by the following fact: the server *has* to be able to
validate a request for security reasons. There is no getting around this. You cannot trust a client.

However, I think many of us take this too far: security concerns are often a lot easier to enforce than the full
client-level interaction _with_ these concerns. For example, we can say on a server that a field must be a number.
This is one line of code that can be done with an assertion.

The UI logic for this is much larger: we have to tell the user what we expected, why we expected it, constrain the UI
to keep them from typing letters, etc. In other words, almost all of the _real_ logic is _already on the client_, and unless
there is a bug, *our* UI *won't* cause a server error because it is pre-checking everything before sending it out.

So, in a modern UI, here are the scenarios for errors *from the server*:

. You have a bug. Is there anything you can really do? No, because it is a bug. If you could predict it going wrong, you would
have already fixed it. Testing and user bug reports are your only recourse.
. There is a security violation. There is nothing for your UI to do, because your UI didn't do it! This is an attack.
Throw an exception on the server, and never expect it in the UI. If you get it, it is a bug. See (1).
. There is a user perspective outage (LAN/WiFi/phone). These are possibly recoverable. You can block the UI, and allow the
user to continue once networking is re-established.
. There is an infrastructure outage. You're screwed. Things are just down. If you're lucky, it is networking and your
user is seeing it as (3) and is just blocked. If you're not lucky, your database crashed and you have no idea
if your data is even consistent.

So, I would assert that the only full-stack error handling *worth* doing in *any detail* is for case (3). If communications
are down, the client can retry. But in a distributed system this can be a little nuanced. Did that mutation partially complete?

If your application can assume reasonably reliable networking and you write your server operations to be atomic then
your error handling can be a relatively small amount of code. Unrecoverable problems will be rare and at worst
you throw up a dialog that says you've had an error and the user hits reload on their browser.
If this happens to users once or twice a year, it isn't going to hurt you.

But of course there is more to the story, and the devil is in the details.

=== Programming with Pure Optimism

The general philosophy of a Fulcro application is that optimistic updates are not even triggered on the client
unless they expect to succeed on the server. In other words, you write the application in such a way that operations cannot be triggered
from the UI unless you're certain that a *functioning server* will execute them. A server should not throw an exception
and trigger a need for error handling unless there is a real, non-recoverable situation.

If this is true, then a functioning server *does* need to do sanity checking for security reasons, but in general you
don't need to give friendly errors when those checks fail: you should assume they are attempted hacks. Other serious
problems are similar: there is usually nothing you can do but throw an exception and let the user contact support.
Exceptions to this rule certainly exist, but they are few and far between.

There are some cases where the server has to be involved in a validation interaction non-optimistically. Login is a great
example of this. However, invalid credentials on login *need not be treated as an error*! Instead they can be treated as
a response to a question. "Can I log in with these credentials?". Yes or no. This is a *query* and *response*, *not* an
error handling interaction. Thus, something like login can be handled with a query (to get the answer) and post-mutation
(to update the screen with a message or change the UI route).

This philosophy eases the overhead in general application programming. You need not write a bunch of code in the UI
that gives a nice friendly message for every kind of error that can possibly occur (nor does anyone really do that
anywhere anyhow). If an error occurs, you can pretty much assume
it is either a bug or a real outage. In both cases, there isn't a lot you can do that will work "well" for the user. If
it is a bug, then you really have no chance of predicting what will fix it, otherwise you would have already fixed the
bug. If it's an outage you might be able to do retries, but in many cases you have no way of knowing what has gone wrong.

So, one approach is to treat most error conditions as a rare problem that needs fairly radical recovery.
One such method is to use a global error handler that is configured during
the setup of your client application (you have to explicitly configure networking). This function could update application
state to show some kind of top-level modal dialog that describes the problem, possibly allows the user to submit
application history (for support viewer) to your servers, and then re-initializes the application in some way.

You can, of course, get pretty creative with the re-initialization. For example, say you write screens so that they will
refresh their persistent data whenever it is older than some amount of time, and write it so all entities have a timestamp.
You could walk the state and "expire" all of the timestamps, and then close the dialog. Your retry
could be set up to check for the expiration, which in turn would trigger loads. If the server is really having
problems then the worst case is that the dialog pops back up telling them there is still a problem.

=== Being a Bit More Pessimistic -- Flaky Network Operation

If your users are likely using your software from a phone on a subway then you have a completely different issue.

Fortunately, Fulcro actually makes handling this case relatively easy as well. Here is what you can do:

1. Write a custom networking implementation for the client that detects the *kind* of error, and retries recoverable ones
until they succeed. Possibly with exponential backoff. (If an infinite loop happens, the user will eventually hit reload.)
2. Make your server mutations idempotent so that a client can safely re-apply a transaction without causing data corruption.

The default fulcro networking does not do retries because it isn't safe without the idempotent guarantee.

The optimistic updates of Fulcro and the in-order server execution means that "offline" operation is actually quite
tractable. If programmed this way, your error handling becomes isolated almost entirely to the networking layer. Of course,
if the user navigates to a screen that needs server data, they will just have to wait. Writing UI code that possibly has
lifecycle timers to show progress updates will improve the overall feel, but the correctness will be there with a fairly
small number of additions.

However, even with these fancy tricks that make our applications better, there are times when we'd just like to
block until something is complete.

=== Detecting Errors From the Server

The built-in remote and networking in Fulcro has a few hooks for dealing with errors:

. A global network error handler for dealing with actual network errors (i.e. you can't talk to the server).
. A global root node value (at `:fulcro/server-error`) you can query that holds the last network error.
(You manually clear this if you wish to use it to track errors over time.)
. The ability to run a mutation if a load fails with an *application-level* error (load option `:fallback`). See <<Fallbacks, fallbacks>>.
. Mutation <<Fallbacks,fallbacks>> for responding to full-stack *application-level* mutation errors.

==== Global Error Handler

This is only available if you use the built-in remote with the Fulcro client. If you write your own networking then
you can handle errors at the network layer any way you want. To install a network error handler on the default
remote support simply write a function like this:

```
;; this function is called on *every* network error, regardless of cause
(defn error-handler "To be used as network-error-callback"
  [state status-code error]
  (log/warn "Global callback:" error " with status code: " status-code))
```

and install it:

```
(fc/new-fulcro-client :network-error-callback error-handler)
```

==== Server Error Demo

The live example below does various things to demonstrate various ways of reacting to errors.
There is a load that fails and uses a fallback to log a message.

The next button tries a mutation that fails (by throwing on the server in a way that propagates the
error back to the client). The final one tries a read that will fail, but does nothing with the error, though
you'll still see that the global indicator updates.

++++
<div class="example" id="server-error-handling"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.server-error-handling').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="server-error-handling source"]
----
include::src/book/book/demos/server_error_handling.cljs[]
----

=== UI Blocking

Fulcro defaults to optimistic updates, which in turn encourages you to write a UI that is very responsive. However,
as soon as you start writing remote mutations you start worrying about the fact that your user submitted some data
but you to let them go off and do other things (like leave the screen they're on) before the server has responded.
In effect, we've told the user "success", but we know we're kind of lying to them.

Another way of looking at it is: we're letting them leave the *visual context* of the information, but we know that if a
server error happens then we need to inform them about that error. We'd like to be sure they understand the error
by still seeing that context when it arrives.

This is a rather complicated way of saying something like "if their email change didn't work, then we'd like to
show the error next to the email input box".

There is nothing in Fulcro that prevents you from writing a blocking UI. You just have to remember that the UI is a
pure rendering of application state: meaning that if you want to block the UI, then you need a way to put a "block the ui"
marker in state (that renders in a way that prevents navigation), and remove that marker when the operation is complete.

Fulcro has a number of ways that you can accomplish this, but we'll cover the simplest and most obvious.

==== Blocking on Remote Mutations

This technique uses the following pattern:

1. We use the `prim/ptransact!` to submit a transaction, which will run each mutation in pessimistic mode (each element
runs only after the prior element has completed a round-trip to the server).
2. The first call in the tx will block the UI, and do the remote operation. We'll also leverage mutation return values
so the server can indicate success to us.
3. Once the first call finishes, the second call in the tx can choose to unblock the UI, or handle any problem it
sees. The mutation return value is merged (and visible) in app state.

Unlike normal mode, pessimistic transactions expect that you might have to nest another one within a mutation in order to retry a
prior call. This is a supported use, and you will find the reconciler in the mutation's `env` parameter to facilitate it as
shown in the example below.

To show how this all works we'll use an in-browser server emulation and show you a working example.

First, we need something to block our UI (which in the card measures 400x100 px). It is a simple div with some style
that will overlay the main UI and prevent further interactions while also showing some kind of feedback message. The CSS
sucks, but let's ignore that for now.

We define it, along with some helper functions that can manipulate its state. It does not have an ident, and we
plan to just place it in root at `:overlay`:

```
(defn set-overlay-visible* [state tf] (assoc-in state [:overlay :ui/active?] tf))
(defn set-overlay-message* [state message] (assoc-in state [:overlay :ui/message] message))

(defsc BlockingOverlay [this {:keys [ui/active? ui/message]}]
  {:query         [:ui/active? :ui/message]
   :initial-state {:ui/active? false :ui/message "Please wait..."}}
  (dom/div (clj->js {:style {:position        :absolute
                             :display         (if active? "block" "none")
                             :zIndex          65000
                             :width           "400px"
                             :height          "100px"
                             :backgroundColor "rgba(0,0,0,0.5)"}})
    (dom/div (clj->js {:style {:position  :relative
                               :top       "40px"
                               :color     "white"
                               :textAlign "center"}}) message)))
```

The main UI is just a simple one-field form and submission button. Note, however, that it submits the form
with `ptransact!`, which will force each call to complete before the next one can start. Thus the second call can
check the result and run whatever in response to it.

```
(defsc Root [this {:keys [ui/name ui/react-key overlay]}]
  {:query         [:ui/react-key :ui/name {:overlay (prim/get-query BlockingOverlay)}]
   :initial-state {:overlay {} :ui/name "Alicia"}}
  (dom/div #js {:key react-key :style (clj->js {:width "400px" :height "100px"})}
    (ui-overlay overlay)
    (dom/p nil "Name: " (dom/input #js {:value name}))
    (dom/button #js {:onClick #(prim/ptransact! this `[(submit-form) (retry-or-hide-overlay)])}
      "Submit")))
```

Now a bit of information about our "server". It has the following definition of the remote mutation:

```
(server/defmutation submit-form [params]
  (action [env]
    (if (> 0.5 (rand))
      {:message "Everything went swell!"
       :result  0}
      {:message "There was an error!"
       :result  1})))
```

As you can see it's just a stub that randomly responds with success or error. The client mutation looks like this:

```
(defmutation submit-form [params]
  (action [{:keys [state]}] (swap! state set-overlay-visible* true))
  (remote [{:keys [state ast] :as env}]
    (m/returning ast state MutationStatus)))
```

It just shows the overlay, and goes remote. Notice the remote part is  using `returning` from the mutations namespace
to indicate a merge of the result value of the mutation. For that we've defined a singleton component (for its query only):

```
(defsc MutationStatus [this props]
  {:ident (fn [] [:remote-mutation :status])
   :query [:message :result]})
```

This means that when this remote mutation is done, we should see a the return value of the server mutation
at `[:remote-mutation :status]` (which is the constant ident of `MutationStatus`).

Now for our second client mutation. First, we need a function that can look in state and see if the mutation
status looks ok:

```
(defn submit-ok? [env] (= 0 (some-> env :state deref :remote-mutation :status :result)))
```

Then we can leverage that to make something that reads well:

```
(defmutation retry-or-hide-overlay [params]
  (action [{:keys [reconciler state] :as env}]
    (if (submit-ok? env)
      (swap! state (fn [s]
                     (-> s
                       (set-overlay-message* "Please wait...") ; reset the overlay message for the next appearance
                       (set-overlay-visible* false))))
      (do
        (swap! state set-overlay-message* (str (-> state deref :remote-mutation :status :message) " (Retrying...)"))
        (prim/ptransact! reconciler `[(submit-form {}) (retry-or-hide-overlay {})])))))
```

It's the real work-horse. The optimistic side can assume the result is updated, so it looks for the result code via
`submit-ok?`. If things are OK, then it resets the overlay message and hides it.

If the submission had an error, then it

- Adds "retrying" to the server message and puts that on the overlay
- Does a new call to `ptransact!`.

You can try out the finished product in the example below. Try it a few times so you can see the error-handling in action.

++++
<div class="example" id="ui-blocking-example"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.ui-blocking-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="ui-blocking-example source"]
----
include::src/book/book/server/ui_blocking_example.cljs[]
----

=== Fallbacks [[Fallbacks]]

If you're running a mutation is likely to trigger server errors then you can explicitly encode a fallback behavior
with the mutation. Fallbacks are triggered the mutation on the server throws an error that is
detectable, or if there is a network error.

The requirement for a server mutation to trigger fallbacks is for it to throw an `ex-info` exception and
include `{:type :fulcro.client.primitives/abort}` in the data. Otherwise the server-side parser will swallow
the exception and continue with the transaction.

Defining a fallback for a transaction is done by including a special mutation in the transaction that names the
mutation to invoke on error:

```
(prim/transact! this `[(some/mutation) (fulcro.client.data-fetch/fallback {:action handle-failure})])
```

```
(require [fulcro.client.mutations :refer [mutate]]
         [fulcro.client.primitives :as prim)

(defmutation handle-failure [{:keys [error ::prim/ref] :as params}]
  ;; fallback mutations are designed to recover the client-side app state from server failures
  ;; THEY DO NOT CHECK FOR REMOTE. You cannot chain a remote interaction in a fallback.
  (action [{:keys [state]}]
    (swap! state undo-stuff error)))
```

Assuming that `some-mutation` is remote, then if the server throws a hard error (e.g. status code not 200)
then the fallback action's mutation symbol (a dispatch key for mutate) is invoked on the
client with params that include an `:error` key that includes the details of the server exception (error type, message,
and ex-info's data). Be sure to only include serializable data in the server exception!

If triggered due to a *mutation* fallback (not load), then the fallback will also receive the ident of the component
that invoked the original transaction in parameters under the key `fulcro.client.primitives/ref`.

You can have any number of fallbacks in a tx, and they will run in order if the transaction fails.

NOTE: It is not recommended that you rely on fallbacks for very much. They are provided for cases where you'd
like to code instance-targeted recovery, but we believe this to be a rarely useful feature.
You're much better off preventing errors by coding your UI to validate,
authorize, and error check things on the client before sending them to the server. The server should still verify
sanity for security reasons, but optimistic systems like Fulcro put more burden on the client code in order to
provide a better experience under normal operation. See the earlier discussion about <<FullStackErrorHandling,error handling>>.

If you do use fallback then you probably also need to clear the network queue so that additional queued
operations don't continue to fail.

=== Clearing Network Queue

If the server sends back a failure it may be desirable to clear any pending network requests from the client
network queue. For example, if you're adding an item to a list and get a server error you might have a mutation waiting
in your network queue that was some kind of modification to that (now failed) item. Continuing the network processing
might just cause more errors.

The FulcroApplication protocol (implemented by your client app) includes the protocol method
`clear-pending-remote-requests!` which will drain all pending network requests.

```
(fulcro.client/clear-pending-remote-requests! my-app)
```

A common recovery strategy from errors could be to clean the network queue and run a mutation that resets your application
to a known state, possibly loading sane state from the server.

=== Pessimistic Transaction Fallbacks

The fallback mechanism described for error handling works in `ptransact!`. Fallbacks are clustered to the remote they follow
up until the next remote mutation (with one exception: fallbacks at the beginning of the entire tx are clustered to the first remote mutation):

```
(ptransact! this `[(L) (df/fallback {...}) (L) (R) (df/fallback {...}) (L2) (R2) (L3) (df/fallback {...}) ])
```

will associate the first two fallbacks with remote call `R`, and the last one with `R2`.

= Building a Server [[BuildingAServer]]

In the Getting Started chapter you saw a little on how to build and use Fulcro's easy server. That server is acually
flexible enough for many production needs, but Fulcro also
comes with code to help you very quickly get a custom server for your
application up and running. In this chapter we'll give you more detail on these two main approaches to
the server-side of Fulcro:

- How to use the pre-built bits to manually build your own server.
- More details on the easy server.

== Rolling Your Own Server

If you're integrating with an existing server then you probably just want to know how to get things working without
having to use a Component library, and all of the other stuff that comes along with it.

It turns out that the server API handling is relatively light. Most of the work goes into getting things set up
for easy server restart (e.g. making components stop/start) and getting those components into your parsing environment.

If you have an existing server then you've mostly figured out all of that stuff already and just want to plug
a Fulcro API handler into it.

Here are the basic requirements:

. Make sure your Ring stack has transit-response and transit-params. You can see a sample Ring stack in
[Fulcro's source](https://github.com/fulcrologic/fulcro/blob/1.2.0/src/main/fulcro/easy_server.clj#L94)
. Check to see if the incoming request is for "/api". If so:
. Call [`handle-api-request`](https://github.com/fulcrologic/fulcro/blob/1.2.0/src/main/fulcro/server.clj#L354). Pass
a parser to it (recommend using `fulcro.server/fulcro-parser`), an environment, and the EDN of the request. It will
give back a Ring response.

You're responsible for creating the parser environment. I'd recommend using
the `fulcro.server/fulcro-parser` because it is already hooked to the server multimethods
like `defquery-root` and `defmutation`. Those won't work unless you use it, but any parser
that can deal with the query/mutation syntax is technically legal.

Here's a crappy little server with no configuration support, no ability to hot code reload, and no external
integrations at all. But it shows how little you need:

```
(ns solutions.tiny-server
  (:require
    [ring.middleware.content-type :refer [wrap-content-type]]
    [ring.middleware.gzip :refer [wrap-gzip]]
    [ring.middleware.not-modified :refer [wrap-not-modified]]
    [ring.middleware.resource :refer [wrap-resource]]
    [ring.util.response :as rsp :refer [response file-response resource-response]]
    [org.httpkit.server]
    [fulcro.server :as server]))

(defn not-found-handler []
  (fn [req]
    {:status  404
     :headers {"Content-Type" "text/plain"}
     :body    "NOPE"}))

(def parser (server/fulcro-parser))

(defn wrap-api [handler uri]
  (fn [request]
    (if (= uri (:uri request))
      (server/handle-api-request parser {} (:transit-params request))
      (handler request))))

(defn my-tiny-server []
  (let [port       9002
        ring-stack (-> (not-found-handler)
                     (wrap-api "/api")
                     (server/wrap-transit-params)
                     (server/wrap-transit-response)
                     (wrap-resource "public")
                     (wrap-content-type)
                     (wrap-not-modified)
                     (wrap-gzip))]
    (org.httpkit.server/run-server ring-stack {:port port})))
```

In a REPL, you could start this one up with:

```
solutions.tiny-server=> (my-tiny-server)
```

=== Configuration

Since you'll still need to configure your web server, it might be useful to note that the configuration used
by the easy server is a component you can inject into your own server. A number of add-on components for Fulcro
assume a `:config` keyed component will be in your system, so if you choose to use such components you can
create a config component via `fulcro.server/new-config`.

It supports pulling in values from the system environment, overriding configs with a JVM option, and more. See
the section in easy server about <<ServerConfig, configuration>>, and the docstrings on `new-config` for more details.

== The "Easy" Server [[EasyServer]]

The pre-built easy server component for Fulcro uses Stuart Sierra's Component library. The server has no
global state except for a debugging atom that holds the entire system, and can therefore be easily restarted
with a code refresh to avoid costly restarts of the JVM.

You should have a firm understanding of [Stuart's component library](https://github.com/stuartsierra/component), since
we won't be covering that in detail here.

=== Constructing a base server

The base server is trivial to create:

```
(ns app.system
  (:require
    [fulcro.easy-server :as server]
    [app.api :as api]
    [fulcro.server :as prim]))

(defn make-system []
  (server/make-fulcro-server
    ; where you want to store your override config file
    :config-path "/usr/local/etc/app.edn"

    ; The keyword names of any components you want auto-injected into the query/mutation processing parser env (e.g. databases)
    :parser-injections #{}

    ; Additional components you want added to the server
    :components {}))
```

=== Configuring the server [ServerConfig]

Server configuration requires two EDN files:

- `resources/config/defaults.edn`: This file should contain a single EDN map that contains
defaults for everything that the application wants to configure.
- `/abs/path/of/choice`: This file can be named what you want (you supply the name when
making the server). It can also contain an empty map, but is meant to be machine-local
overrides of the configuration in the defaults. This file is required. We chose to do this because
it keeps people from starting the app in an unconfigured production environment.

```
(defn make-system []
  (server/make-fulcro-server
    :config-path "/usr/local/etc/app.edn"
    ...
```

The only parameter that the default server looks for is the network port to listen on:

```
{ :port 3000 }
```

The configuration component has a number of built-in features:

- You can override the configuration to use with a JVM option: `-Dconfig=filename`
- The `defaults.edn` is the target of configuration merge. Your config EDN file must be a map, and anything
in it will override what is in defaults. The merge is a deep merge.
- Values can take the form `:env/VAR`, which will use the *string* value of that environment variable as the value
- Values can take the form `:env.edn/VAR`, which will use `read-string` to interpret the environment variable as the value
- Relative paths for the config file can be used, and will search the CLASSPATH resources. This allows you to package your config with you jar.

=== Pre-installed components

When you start a Fulcro server it comes pre-supplied with injectable components upon which your
component can depend and/or inject into the server-side parsing environment.

The most important of these, of course, is the configuration itself. The available components
are known by the following keys:

- `:config`: The configuration component. The actual EDN value is in the `:value` field
of the component.
- `:handler`: The component that handles web traffic. You can inject your own Ring handlers into
two different places in the request/response processing: before or after the API handler.
- `:server`: The actual web server.

The component library, of course, figures out the dependency order and ensures things are initialized
and available where necessary.

=== Making components available in the processing environment [[EasyParsingEnv]]

Any components in the server can be injected into the processing pipeline so they are
available when writing your mutations and query procesing. Making them available is as simple
as putting their component keyword into the `:parser-injections` set when building the server:

```
(defn make-system []
  (server/make-fulcro-server
    :parser-injections #{:config}
    ...))
```

=== Adding to the Ring Stack

The easy server has a hook in front of the API processing (pre-hook), and one at the end of the ring stack
after API processing and just before the not-found handler (post-hook). You can have a component join into
the stack by making it depend on `:handler`. Here is an example:

```
(defrecord Authentication [handler]
  c/Lifecycle
  (start [this]
    (log/info "Hooking into pre-processing to add user info")
    (let [old-pre-hook (fulcro.easy-server/get-pre-hook handler)
          new-hook     (fn [ring-handler] (fn [req] ((old-pre-hook ring-handler) (new-behavior req)))]
      (fulcro.easy-server/set-pre-hook! handler new-hook))
    this)
  (stop [this] this))

...

(def server (fulcro.easy-server/make-fulcro-server
               :components { :auth (component/using (map->Authentication {}) [:handler]))}))
```

The same pattern is used for post-hooks.

=== Handling Filesystem Resources

The easy server will serve any files that are placed in `resources/public`. The easy server does pre-map
URI "/" to "/index.html".

=== Modifying the `/api` route

The easy server (and client) default to using `/api` as the URI on which to handle traffic. If you are proxying multiple
Fulcro applications to a single server, you may want to place them under different URI paths (e.g. `/app-1/api` and `/app-2/api`.

```
; server API at "/app-1/api":
(def server (fulcro.easy-server/make-fulcro-server :app-name "app-1" ...))
```

The `:app-name` option of the easy server will add such a prefix to the API route. If you do that, then the client
will also need to have manual configuration of networking to ensure that it tries to contact the correct URI for
API calls.

```
(def client (fc/new-fulcro-client :networking {:remote (fulcro.client.network/make-fulcro-network :url "/app1/api" ...)}))
```

=== Adding Non-API Routes

The easy server also supplies a way to add in URI handlers via BIDI:

```
(defn page-handler [env bidi-match]
  (ring/response ...))

; define routes (see BIDI documentation)
(def my-routes ["/" {"page.html" :page}])

(def server (fulcro.easy-server/make-fulcro-server
               :extra-routes { :routes   my-routes
                               :handlers {:page page-handler}}))
```

The extra routes are processed right *after* the pre-hook, but just before the
resource (filesystem) serving. Thus, you can respond to any URI that isn't already
handled by your pre-hook.

= Dynamic Queries [[DynamicQueries]]

Fulcro fully support dynamic queries: the ability the change the query of a component at runtime. This feature is fully
serializable (works with the support viewer and other time-travel features), and is critical for features like code splitting
where you may need to compose in a query of an as-yet unloaded component tree of your application.

== Query IDs

For dynamic queries to work right they have to be stored in your application database and every aspect of them must
be serializable. Additionally, the UI must be able to look them up at the component level in order to do optimal refresh.
The solution to this is query IDs. A query ID is a simple combination of the the component's fully-qualified class name
combined with a user-defined qualifier (which defaults to the empty string).

Since this qualifier is needed both in the code that obtains queries (`get-query`) and in the UI rendering (the factory
that draws that component), it is easiest to locate the qualifier in the UI factory itself. This allows you
to have instances of a class that can have different queries:

```
(defsc Thing ...)
(def ui-thing (prim/factory Thing)) ; query ID is based solely on the class itself (with no qualifier)
(def ui-thing-1 (prim/factory Thing {:qualifier :a})) ; query ID is derived from Thing plus the qualifier :a

(defsc Parent [this props]
  {:query (fn [] [{:child (prim/get-query ui-thing-1)}])}
  ...)
```

In the above example one can now set the query for `Thing`, or "`Thing` with qualifier `:a`".

The following live demo shows dynamic queries in action:

++++
<div class="example" id="dynamic-queries"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.dynamic-queries').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="dynamic-queries source"]
----
include::src/book/book/queries/dynamic_queries.cljs[]
----

== Query Parameters

The dynamic query support allows you to use variables in your query to facilitate more easy modification of a component's query.
Setting the entire query can be tedious when the query has a lot of elements, only one or a few of which need modifications.

Query parameters are simply symbols you place in the query like so:

```
[:x ?p]
```

The symbol *must* start with a `?` to be a legal parameter.

The parameters start out with no value, meaning that the query above will be interpreted as just `[:x]` at first.

You can set the value of the parameter with `prim/set-query!`:

```
(prim/set-query! this Component {:params {:p :y}})
```

which in this case would cause the component's query to become `[:x :y]`. This is demonstrated in the
demo below:

++++
<div class="example" id="dynamic-query-parameters"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.dynamic-query-parameters').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="dynamic-query-parameters source"]
----
include::src/book/book/queries/dynamic_query_parameters.cljs[]
----

= Query Parsing

In the <<Loading, Loading>> and <<IncrementalLoading, Incremental Loading>> sections we showed you the central entry
points for responding to server queries:
`defquery-root` and `defquery-entity`. These are fine for simple examples and for getting into your
processing; however, to be truly data-driven you need to change how the server responds based
on what the client actually *asked* for (in detail).

So far, we've sort of been spewing entire entities back from the server without taking care to prune them down
to the actual query of the client.

Unless you modify the network stack all client communication will be in the form of Query/Mutation expressions,
which of course are recursive in nature. There is no built-in recursive processing, since Fulcro does not know
anything about your server-side storage; however, there is a parsing mechanism that you
can use to build processing to interface with it, and there are a number of libraries that can also help.

== Avoiding Parsing

If you're lucky, you can make use of a library to do this stuff for you. Here are some options we know about:

* https://github.com/wilkerlucio/pathom[Pathom]
+
A really nice library for building recursive Fulcro query parsers. It has a good model for building parsers that can
bridge everything from REST services to microservice architectures. In general if you need to interpret your UI queries,
this tool can be very useful.
+
* https://github.com/fulcrologic/fulcro-sql[Fulcro-SQL]
+
A library that can run Fulcro graph queries against SQL databases. This library lets you define your joins in relation
to the Fulcro join notion. It can walk to-one, to-many, and many-to-many joins in an SQL database in response to a
Fulcro join. This allows it to handle many Fulcro queries as graph queries against your SQL database with just a little
configuration and invocatin code.
+
* http://www.datomic.com[Datomic]
+
If you're lucky enough to be using Datomic, Fulcro's graph query syntax will run in their `pull` API

Of these, Pathom is the most general and allows you to easily process a query in a more abstract way. However, you
should know a little bit about parsing the queries yourself.

== Doing the Parsing Yourself

The expression parser needs two things: A function to dispatch reads to, and a function to dispatch mutations. Since
we're talking about query parsing we'll only be talking about the read dispatch function.

The signature of the read function is `(read [env dispatch-key params])`
where the `env` contains the `state` of your application, a reference to your `parser` (so you can
call it recursively, if you wish), a query root marker, an AST node describing the exact
details of the element's meaning, and *anything else* you want to put in there if
you call the parser recursively.

The most important item in the query processing is the received environment (`env`). On
the server it contains:

- Any components you've asked to be injected. Perhaps database and config components.
- `ast`: An AST representation of the item being parsed.
- `query`: The subquery (e.g. of a join)
- `parser`: The query expression parser itself (which allows you to do recursive calls). If you're using the built-in
   parser, this this will be that same parser that is already hooked into your dispatch mechanism (e.g. defquery-root).
- `request`: The full incoming Ring request, which will contain things like the headers, cookies, session, user agent info, etc.

The return value of your read must be the *value* for the `dispatch-key`. The parser assembles these back together and
returns a map containing those keys for all of the items for which you return a non-nil result.

If you understand that, you can probably already write a simple recursive parse of a query. If
you need a bit more hand-holding, then read on.

NOTE: When doing recursive parsing *You do not have to use the parser from `env`*. Parsers are cheap. If you want to
make one to deal with a particular graph, go for it! The `fulcro.client.primitives/parser` can make one.

Now, let's get a feeling for the parser in general. The example below
runs a parser on an arbitrary query that you supply, records the calls to the read emitter,
and shows the trace of those calls in order.

See the source code comments for a full description of how it works.

Try some queries like these:

- `[:a :b]`
- `[:a {:b [:c]}]` (note that the AST is recursively built, but only the top keys are actually parsed to trigger reads)
- `[(:a { :x 1 })]`  (note the value of params)

++++
<div class="example" id="parsing-trace-example"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parsing-trace-example').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parsing-trace-example source"]
----
include::src/book/book/queries/parsing_trace_example.cljs[]
----

=== Injecting some kind of database

In order to play with this on a server, you'll want to have some kind of state
available. The most trivial thing you can do is just create a global top-level atom
that holds data. This is sufficient for testing, and we'll assume we've done something
like this on our server:

```
(defonce state (atom {}))
```

One could also wrap that in a Stuart Sierra component and inject it into the
parser (for details on modifying the parser environment, see <<EasyParsingEnv, Making Components Available in the Parsing Environment>>).

Much of the remainder of this section assumes this.

== Read Dispatching

When building your server there must be a read function that can
pull data to fufill what the parser needs to fill in the result of a query. Fulcro supplies this by default
and gives you the `defquery-*` macros as helpers to hook into it, but really it is just a multi-method.

For educational purposes, we're going to walk you through implementing this read function yourself.

The parser understands the grammar, and is written to work as follows:

* The parser calls your `read` with the key that it parsed, along with some other helpful information.
* Your read function returns a value for that key (possibly calling the parser recursively if it is a join).
* The parser generates the result map by putting that key/value pair into
the result at the correct position (relative to the query).

Note that the parser only processes the query one level deep. Recursion (if you need it)
is controlled by *you* calling the parser again from within the read function.

The example below is similar to the prior one, but it has a read function that just records what keys it was
triggered for. Give it an arbitrary legal query, and see what happens.

Some interesting queries:

* `[:a :b :c]`
* `[:a {:b [:x :y]} :c]`
* `[{:a {:b {:c [:x :y]}}}]`


++++
<div class="example" id="parsing-key-trace"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parsing-key-trace').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parsing-key-trace source"]
----
include::src/book/book/queries/parsing_key_trace.cljs[]
----

In the example above you should have seen that only the top-level keys trigger reads.

So, the query:

```
[:kw {:j [:v]}]
```

would result in a call to your read function on `:kw` and `:j`. Two calls. No
automatic recursion. Done. The output value of the *parser* will be a map (that
parse creates) which contains the keys (from the query, copied over by the
parser) and values (obtained from your read):

```
{ :kw value-from-read-for-kw :j value-from-read-for-j }
```

Note that if your read accidentally returns a scalar for `:j` then you've not
done the right thing...a join like `{ :j [:k] }` expects a result that is a
vector of (zero or more) things *or* a singleton *map* that contains key
`:k`.

```
{ :kw 21 :j { :k 42 } }
; OR
{ :kw 21 :j [{ :k 42 } {:k 43}] }
```

Dealing with recursive queries is a natural fit for a recusive algorithm, and it
is perfectly fine to invoke the `parser` function to descend the query. In fact,
the `parser` is passed as part of your environment.

So, the read function you write will receive three arguments, as described below:

. An environment containing:
** `:ast`: An abstract syntax *tree* for the element, which contains:
*** `:type`: The type of node (e.g. :prop, :join, etc.)
*** `:dispatch-key`: The keyword portion of the triggering query element (e.g. :people/by-id)
*** `:key`: The full key of the triggering query element (e.g. [:people/by-id 1])
*** `:query`: (same as the query in `env`)
*** `:children`: If this node has sub-queries, will be AST nodes for those
*** others...see documentation
** `:parser`: The query parser
** `:query`: **if** the element had one E.g. `{:people [:user/name]}` has `:query` `[:user/name]`
** Components you requested be injected
. A dispatch key for the item that triggered the read (same as dispatch key in the AST)
. Parameters (which are nil if not supplied in the query)

It must return a value that has the shape implied by the grammar element being read.

NOTE: The following examples run various parsers against arbitrary queries. The `ParseRunner` component source looks like
this:

```
include::src/book/book/queries/parse_runner.cljs[]
```

=== Reading a keyword

If the parser encounters a keyword `:kw`, your function will be called with:

```clj
(your-read
  { :dispatch-key :kw :parser (fn ...) } ;; the environment: parser, etc.
  :kw                                   ;; the keyword
  nil) ;; no parameters
```

your read function should return some value that makes sense for
that spot in the grammar. There are no real restrictions on what that data
value has to be in this case. You are reading a simple property.
There is no further shape implied by the grammar.
It could be a string, number, Entity Object, JS Date, nil, etc.

Due to additional features of the parser, *your return value must be wrapped in a
map with the key `:value`*. If you fail to do this, you will get nothing
in the result.

Thus, a very simple read for props (keywords) could be:

```clj
(defn read [env key params] { :value 42 })
```

below is an example that implements exactly this `read` and plugs it into a
parser like this:

```
(defn read-42 [env key params] {:value 42})
(def parser-42 (prim/parser {:read read-42}))
```

The UI just passes your query off to the parser and shows the results.

Thus, the example returns the value 42 no matter what it is asked for. Run any query you
want in it, and check out the answer.

Some examples to try:

- `[:a :b :c]`
- `[:what-is-6-x-7]`
- `[{:a {:b {:c {:d [:e]}}}}]` (yes, there is only one answer)

++++
<div class="example" id="naive-read"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.naive-read').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="naive-read source"]
----
include::src/book/book/queries/naive_read.cljs[]
----

So now you have a read function that returns the meaning of life the universe and
everything in a single line of code! But now it is obvious that we need to build
an even bigger machine to understand the question.

If your server state is just a flat set of scalar values with unique keyword
identities, then a better read is similarly trivial:

```
(defn property-read [{:keys [state]} key params] {:value (get @state key :not-found)})
(def property-parser (prim/parser {:read property-read}))
```

It just assumes the property will be in the top-level of some injected state atom. Let's try
that out. The database we're emulating is shown at the bottom of the example.
Run some queries and see what you get. Some suggestions:

- `[:a :b :c]`
- `[:what-is-6-x-7]`
- `[{:a {:b {:c {:d [:e]}}}}]` (yes, there is only one answer)

++++
<div class="example" id="simple-property-read"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.simple-property-read').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="simple-property-read source"]
----
include::src/book/book/queries/simple_property_read.cljs[]
----

The result of those nested queries (the last suggestion above) is supposed to be a nested map. So, obviously we
have more work to do.

=== Reading a join

Your state probably has some more structure to it than just a flat
bag of properties. Joins are naturally recursive in syntax, and
those that are accustomed to writing parsers probably already see the solution.

First, let's clarify what the read function will receive for a join. When
parsing:

```
{ :j [:a :b :c] }
```

your read function will be called with:

```
(your-read { :state state :parser (fn ...) :query [:a :b :c] } ; the environment
           :j                                                 ; keyword of the join
           nil) ; no parameters
```

But just to prove a point about the separation of database format and
query structure we'll implement this next example
with a basic recursive parse, *but use more flat data* (the following is live code):

```
(def flat-app-state {:a 1 :user/name "Sam" :c 99})

(defn flat-state-read [{:keys [state parser query] :as env} key params]
  (if (= :user key)
    {:value (parser env query)}                             ; recursive call. query is now [:user/name]
    {:value (get @state key)}))                             ; gets called for :user/name :a and :c

(def my-parser (prim/parser {:read flat-state-read}))
```

The important bit is the `then` part of the `if`. Return a value that is
the recursive parse of the sub-query. Otherwise, we just look up the keyword
in the state (which as you can see is a very flat map).

Try running the query `[:a {:user [:user/name]} :c]`:

++++
<div class="example" id="parsing-simple-join"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parsing-simple-join').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parsing-simple-join source"]
----
include::src/book/book/queries/parsing_simple_join.cljs[]
----

The first (possibly surprising thing) is that your result includes a nested
object. The parser creates the result, and the recursion naturally nested the
result correctly.

Next you should remember that a join implies there could be one OR many results.
The singleton case is fine (e.g. putting a single map there). If there are
multiple results it should be a vector.

In this case we're just showing calling the parser recursively. Notice that
it in turn will call your read function again.
In a real application your data will not be this flat so you
will almost certainly not do things in quite this
way.

Let's put a little better state in our application and write a more realistic parser.

=== A Non-trivial, recursive example

Let's start with the following hand-normalized application state:

```
(def app-state (atom {
                      :window/size  [1920 1200]
                      :friends      [[:people/by-id 1] [:people/by-id 3]]
                      :people/by-id {
                                     1 {:id 1 :name "Sally" :age 22 :married false}
                                     2 {:id 2 :name "Joe" :age 22 :married false}
                                     3 {:id 3 :name "Paul" :age 22 :married true}
                                     4 {:id 4 :name "Mary" :age 22 :married false}}}))
```

Our friend `db->tree` could handle queries against this database,
but let's implement it by hand.

Say we want to run this query:

```
(def query [:window/size {:friends [:name :married]}])
```

From the earlier discussion you see that we'll have to handle the
top level keys one at a time.

For this query there are only two keys to handle: `:friends`
and `:window-size`. So, let's write a case for each:

```
(defn read [{:keys [state query]} key params]
  (case key
    :window/size {:value (get @state :window/size)}
    :friends (let [friend-ids (get @state :friends)
                   get-friend (fn [id] (select-keys (get-in @state id) query))
                   friends (mapv get-friend friend-ids)]
               {:value friends})
    nil))
```

The default case is `nil`, which means if we supply an errant key in the query no
exception will happen.

You can try it out below:

++++
<div class="example" id="parsing-recursion-one"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parsing-recursion-one').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parsing-recursion-one source"]
----
include::src/book/book/queries/parsing_recursion_one.cljs[]
----

Those of you paying close attention will notice that we have yet to need
recursion. We've also done something a bit naive: `select-keys` assumes
that query contains only keys! What if query followed an ident link to
`:married-to`:

```
[:window/size {:friends [:name :age {:married-to [:name]}]}]
```

and the database was:

```
{:window/size  [1920 1200]
               :friends      [[:people/by-id 1] [:people/by-id 3]]
               :people/by-id {
                              1 {:id 1 :name "Sally" :age 22 :married false}
                              2 {:id 2 :name "Joe" :age 33 :married false}
                              3 {:id 3 :name "Paul" :age 45 :married true :married-to [:people/by-id 1]}
                              4 {:id 4 :name "Mary" :age 19 :married false}}}
```

Now things get interesting, and I'm sure more than one reader will have an
opinion on how to proceed. My aim is to show that the parser can be called
recursively to handle these things, not to find the perfect structure for the
parser in general, so I'm going to do something simple.

The primary trick I'm going to exploit is the fact that `env` is just a map, and
that we can add stuff to it. When we are in the context of a person, we'll add
`:person` to the environment, and pass that to a recursive call to `parser`.

The example below (with source) shows the result:

++++
<div class="example" id="parsing-recursion-two"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parsing-recursion-two').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parsing-recursion-two source"]
----
include::src/book/book/queries/parsing_recursion_two.cljs[]
----

It can be a little bit of work to build these parsers for the queries (which is why libraries exist so you don't have to); however,
we hope you can see that it is actually pretty tractable to build them once you understand the basics.

Now we'll move on to another thing that servers typically need in their queries: parameters!

== Parameters

The Fulcro query grammar accept parameters on most elements. These are intended
to be combined with dynamic queries that will allow your UI to have some control
over what you want to read from the application state (think filtering, pagination,
sorting, and such).

As you might expect, the parameters on a particular expression in the query
are just passed into your read function as the third argument.
You are responsible for both defining and interpreting them.
They have no rules other than that they are maps.

To read the property `:load/start-time` with a parameter indicating a particular
time unit you might use a query like:

```
[(:load/start-time {:units :seconds})]
```

this will invoke read with:

```
(your-read env :load/start-time { :units :seconds})
```

the implication is clear. The code is up to you. Let's add some quick support for this
in our read so you can try it out.

The parser below understands the following queries:

```
[(:load/start-time {:units :seconds})]

[(:load/start-time {:units :minutes})]

[(:load/start-time {:units :ms})]
```

++++
<div class="example" id="parsing-parameters"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.parsing-parameters').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="parsing-parameters source"]
----
include::src/book/book/queries/parsing_parameters.cljs[]
----

== Using a Completely Custom Parser

Most of this book has assumed you'll be using Fulcro's predefined server parser. Note that you can still do that
and switch out to an alternate (custom) parser at any phase of parsing. You can even install a custom parser in your server
(though then the macros for defining mutations and query handlers won't work for you).
Parsers can be constructed using the `prim/parser` function.

== Parsing on the Client

Fulcro allows you to augment the built-in query parser *for local reads* on the client. It uses the exact same techniques
discussed above, and it is similar in that you must be able to start at the root of the query
(even though you may only want to augment something rather deep in the query tree).

Actually, there are two cases that such a custom read *must* be able to do:

* Handle the path from root to the point of interest (it can hand off uninteresting side branches to `db->tree`.
* Handle (or safely ignore) ident-based queries for any "virtual" entities that are purely parser-generated.

The first is a limitation of how queries are processed. Fulcro normally runs the query through `db->tree`, which attempts to
fill the entire result. If you supply a `:read-local` function during client construction, then your `:read-local` will
get first shot at *each element* of the query that was submitted. Note that the query *can start* at an ident.
If your `read-local` function returns `nil` for an element, then the normal Fulcro
processing takes place on that sub-query. If your `read-local` returns a value, then that is *all of the processing* that
is done for the sub-tree rooted at that key. Thus, custom client parsing always requires you to process sub-trees of the query, not just
individual elements.  Of course, you can use `db->tree` at any time to "finish out" some subquery against real data.

This has the advantage of letting you dynamically fill queries without having to have a concrete representation of the
graph in your database. This can be helpful if you have some rapidly changing data (e.g. updated by a web worker) and
some views of that data that would otherwise be hard to keep up-to-date.

It is also useful if you're trying to port from Om Next.

= UI Routing [[UIRouting]]

UI Routing is a *very* important task in Fulcro. It is the primary means by which you keep your application
running quickly. You see, in Fulcro your query is run from root. If your entire application's query runs on every
render frame things can get slow indeed.

The solution is easy: use union queries with to-one relations to ensure only the portions of your
query that are active on the UI are processed.

Unfortunately many people find hand-writing union components a litle challenging. Fulcro provides a nice
pre-written facility that can write much of the code for you, making the process more conceptual as UI Routing.

== A Basic Router [[BasicRouter]]

A basic router looks like this:

```
(defsc Index [this {:keys [db/id router/page]}]
  {:query         [:db/id :router/page]
   :ident         (fn [] [page id])
   :initial-state {:db/id 1 :router/page :PAGE/index}}
  ...)

(defsc Settings [this {:keys [db/id router/page]}]
  {:query         [:db/id :router/page]
   :ident         (fn [] [page id])
   :initial-state {:db/id 1 :router/page :PAGE/settings}}
  ...)

(defrouter RootRouter :root/router
  ; OR (fn [t p] [(:router/page p) (:db/id p)])
  [:router/page :db/id]
  :PAGE/index Index
  :PAGE/settings Settings)
```

The important points are:

. The ident generator for the components and router must all work the same. The router uses the first element of the
ident to pick the screen.
. The list of screens to route to in the router are keyed by that first element of the ident.
. The components that act as screens should:
.. Have initial state that will work with ident
.. Use an ident function that returns the same thing that the router will extract.

The router itself then works like any other Fulcro component. You make a factory for it, join it into your query, and render it
by passing the queried props to it.

WARNING: The `defrouter` macro allows you to specify a vector for the ident argument where *both* keys are looked up in
the component's props; However, the `defsc` macro assumes that a vector shorthand for idents contains a table name and
something to look up. This is the most convenient behavior for both, but since it does not match use this rule: If you're
using `defsc` to make a screen component that will be used with a router then you *always* want the lambda form, not
the vector template in that `defsc`.

++++
<div class="example" id="simple-router-1"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.simple-router-1').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-simple-router-1 source"]
----
include::src/book/book/simple_router_1.cljs[]
----

Be sure to look at the database view in the example above. Notice that all that has to happen is a change
of a single ident. This as the effect of switching the rendering, and choosing the
subquery for the remainder of the visible UI.

It is very easy from here to compose together as many of these as you'd like in order to
build a more complicated UI. For example, the settings could have several subscreens as in this
example:

++++
<div class="example" id="simple-router-2"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.simple-router-2').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-simple-router-2 source"]
----
include::src/book/book/simple_router_2.cljs[]
----

This allows you to build up a tree of routers that keeps your query minimal, and allows for very nice dynamic
structuring of the applicataion at runtime.

If you have screens that could have different instances (for example, different reports), then each report could
have an ID, and routing would involve selecting the screen's table, as well as a distinct ID.

The problem, of course, is that managing all of these routers in your application logic becomes
somewhat of a chore. Also, it is common to want to mix UI routing with HTML5 history, where only a single
"route" is spelled out, but you may need to logically "switch" any number of these UI routers to reach
the indicated screen.

For example, one could imagine wanting to go to `/settings/colors` as a URI for the previous example. That single
URI *as a concept* is a single route to a screen, but the transaction you'd trigger would be to `set-route` on
two different routers.

== Routing Tree Support

Fulcro includes some routing tree primitives to do the mapping from single conceptual "routes" like `/settings/colors`
to a set of instructions that you need to send to your UI routers. There is an additional concern as well: route
parameters. It is quite common to want to interpret URIs like `/user/436` as a route that populates a given screen
with some data.

Thus, the tree support is based on the concept of a Route Handler and Route Parameters.

Defining routes requires just a few steps:

. Define routers as shown in <<BasicRouter, the prior section>>, giving each router a distinct ID.
. Give each *routable screen (i.e. URI)* in your tree a handler name.  The example below shows two routers with
5 conceptual target screen. The screens have *handler names* `:main`, `:login`, etc.
+
----
              (top-router w/id :top-router)
                 ----------------------
                /     /     |          \
           :main  :login  :new-user    (report router w/id :report-router)
                                             |
                              (reports shared content screen)
                                             |
                                            / \
                                      :status  :graph
----
+
. Define your routing tree. This is a data structure that gives instructions to one-or-more routers that are necessary to
 display the screen with a given handler name. In the above example you need to tell *both* the top router and report router
 to change what they are showing in order to get a `:status` or `:graph` onto the screen.
+
```
(def routing-tree
  "A map of route handling instructions. A given route has a handler name (e.g. `:main`) which is
  thought of as the target of a routing operation (i.e. interpretation of a URI). It also has a vector
  of `router-instruction`s, which say

  1. which router should be changed
  2. What component instance that router should point to (by ident)

  The routing tree for the diagram above is therefore:
  "
  (r/routing-tree
    (r/make-route :main [(r/router-instruction :top-router [:main :top])])
    (r/make-route :login [(r/router-instruction :top-router [:login :top])])
    (r/make-route :new-user [(r/router-instruction :top-router [:new-user :top])])
    (r/make-route :graph [(r/router-instruction :top-router [:report :top])
                          (r/router-instruction :report-router [:graphing-report :param/report-id])])
    (r/make-route :status [(r/router-instruction :top-router [:report :top])
                           (r/router-instruction :report-router [:status-report :param/report-id])])))
```
+
. Compose the application as normal, placing the routers as shown in <<BasicRouter, the prior section>>.

== Using the Routing Tree

The routing namespace includes a Fulcro mutation for triggering the routing tree handler.
It takes a `:handler` (e.g. `:main`)  and an optional `:route-params` argument:

```
; assumes you've aliased fulcro.client.routing to r
(prim/transact! `[(r/route-to {:handler :main})])
```

Running this mutation will run all of the `router-instruction`, and will also do route parameter substitution on the
resulting idents.

=== Route Parameters

Anything you pass in the `:route-params` map will get plugged into the parameter placeholders in your
routing tree instructions. By default anything that looks like an integer (only digits) will
be coerced to an integer. Anything that contains only letters will map to a keyword.

If the default coercion isn't sufficient, then you can customize it.

==== Parameter Coercion

The default coercion converts integer-looking things to integers, and string-looking things to keywords.

There is a multimethod `r/coerce-param` that dispatches on `:param/X` and replaces the value with
whatever you return. You customize coercion simply by adding your own coercion for
a parameter by name:

```
(defmethod r/coerce-param :param/NAME [k incoming-string-value] (transform-it incoming-string-value))
```

Of course, be sure that your namespace with the `defmethod` is loaded so that your methods get installed.

== Examining Routes in UI and Mutations

Your UI will often want to rely on knowing the "current" route of a given router in order to give
user navigation feedback. You cannot embed *your* router in the query, because that would often
make the query have a circular reference and blow the stack.

The only real bit of information in a router that is useful is the current route
The `current-route` function can be used in a mutation or component (by querying for the router
table) to check the route:

```
(ns x
  (:require [fulcro.client.routing :as r]
            [fulcro.client.primitives :as prim]))

(r/defrouter SomeRouter :top-router
  (ident [this props] ...)
  :home-page HomePage
  :about-page AboutPage
  ...)

(defmutation do-something-with-routes [params]
  (action [{:keys [state]}]
    (let [current (r/current-route state :top-router)] ; current will be an ident of a screen of :top-router
    ...)))

(defsc NavBar [this props]
  {:query (fn [] [ [r/routers-table '_] ])
   :initial-state (fn [p] {})}
  (let [current (current-route props :top-router)] ; current will be an ident of a screen of :top-router
     ...))
```

== A Complete UI Routing Example

The following shows the example routing tree in a complete running demo:

++++
<div class="example" id="ui-routing"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.ui-routing').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="ui-routing source"]
----
include::src/book/book/ui_routing.cljs[]
----

== Combining Routing with Data Management

Of course you can compose this with other mutations into a single transaction. This is common when you're trying
to switch to a screen whose data might not yet exist:

```
(prim/transact! `[(ensure-report-loaded {:report-id :a}) (r/route-to {:graph :a})])
```

here we're assuming that `ensure-report-loaded` is a mutation that ensures that there is at least placeholder data in
place (or the UI rendering might look a bit odd or otherwise fail from lack of data). It may also do things like trigger background
loads that will fufill the graph's needs, something like this:

```
(defmutation ensure-report-loaded [{:keys [report-id]}]
  (action [{:keys [state] :as env}]
    (let [when-loaded (get-in @state [:reports/by-id report-id :load-time-ms] 0)
          is-missing? (= 0 when-loaded)
          now-ms (.getTime (js/Date.))
          age-ms (- now-ms when-loaded)
          should-be-loaded? (or (too-old? age-ms) is-missing?)]
      ; if missing, put placeholder
      ; if too old, add remote load to Fulcro queue (see data-fetch for remote-load and load-action)
      (when is-missing? (swap! state add-report-placeholder report-id))
      (when should-be-loaded? (df/load-action env [:reports/by-id report-id] StatusReport)))})
  (remote [env] (df/load-action env)))
```

Additional mutations might do things like garbage collect old data that is not in the view. You may also need to
trigger renders of things like your main screen with follow-on reads (e.g. of a keyword on the root
component of your UI). Of course, combining such things into functions adds a nice touch:

```
(defn show-report!
  [component report-id]
  (prim/transact! component `[(app/clear-old-reports)
                              (app/ensure-report-loaded {:report-id ~report-id})
                              (r/route-to {:graph ~report-id})
                              :top-level-key]))
```

which can then be used more cleanly in the UI:

```
(dom/a #js {:onClick #(show-report! this :a)} "Report A")
```

== Mutations with Routing

In some cases you will find it most convenient to do your routing within a mutation itself. This will let you
check state, trigger loads, etc. If you trigger loads, then you can also easily defer the routing until the
load completes. Of course, in that case you may want to do something in the state to cause your UI to indicate
the routing is in progress.

There is nothing special about this technique. There are several functions in the `routing` namespace
that can be used easily within your own mutations:

- `update-routing-links` - For standard union-based `defrouter` (does not support dynamic code loading routers): Takes
the state map and a route match (map with :handler and :route-params) and returns a new state map with the routes updated.
- `route-to-impl!` - For all kinds of routers (including dynamic): Takes the mutation `env` and a bidi-style match {:handler/:params}.
 Works with dynamic routes. Does swaps against app state, but is safe to use within a mutation.
- `set-route` - Changes the current route on a *specific* `defrouter` instance. Takes a state map, router ID, and a target ident.
Used if *not* using routing trees or dynamic routers.

== HTML5 Routing

Hooking HTML5 or hash-based routing up to this is relatively simple using, for example, `pushy` and `bidi`.

We do not provide direct support for this, since your application will need to make a number of decisions that
really are local to the specific app:

* How to map URIs to your leaf screens. If you use bidi then `bidi-match` will return exactly what you need from
a URI route match (e.g. `{:handler :x :route-params {:p v}}`).

* How to grab the URI bits you need. For example, `pushy` lets you hook up to HTML5 history events.

* If a routing decision should be deferred/reversed? E.g. navigation should be denied until a form is saved.

* How you want to update the URI on routing. You can define your own additional mutation to do this (e.g. via `pushy/set-token!`)
and possibly compose it into a new mutations with `route-to`. The function `r/update-routing-links` can be used for
such a composition:

```
; in some defmutation
(swap! state (fn [m]
                (-> m
                    (r/update-routing-links { :handler :h :route-params p })
                    (app/your-state-updates)))
(pushy/set-token! your-uri-interpretation-of-h)
```

See the fulcro-template on github. It supports HTML5 routing with a demo tree.

= Forms Overview

On the surface forms are trivial: you have DOM input fields, users put stuff in them, and you submit that to a server.
For really simple forms you already have sufficient tools and you can simply code them however you see fit.

The next most critical thing you'll want is some help with managing the meta-state that goes with most form
interactions:

* When is the content of a field valid?
* When should you show a validation error message? E.g. you should not tell a user that they made a mistake
on a field they have yet to touch.
* How do you "reset" the form if the user changes their mind or cancels an edit?
* How do you ensure that just the data that has changed is sent to the server?

These more advanced interactions require that you track a few things:

* The validation rules
* Which fields are "complete" (ready for validation)?
* What was the state of the form fields *before* the user started interacting with it?
* How do you transition states (e.g. indicate that the updated form is now the new "real state"?

You will also commonly need a way to deal with the fact that a form may cross several entities in your database,
generating a more global top-level form concern: are all of the entities in this form valid?

Again, you can certainly code all of this by hand, but Fulcro includes two different namespaces of helpers that
can make dealing with these aspects of forms a little easier. The reason there are two is that the older
version was not easy to change without breaking existing code, so new functions were written in a new namespace
as an alternative.

The <<FormState, form state>> support concentrates just on providing utilities to manage the data, and has validation
that is based on Clojure Spec but is completely pluggable. The <<FullForm, full form management>> support is the older
version that attempts to isolate your components a bit more from the event and state management, but at the expense of some
added complexity.

Both are fully supported, though the form state support is considered the cleaner implementation.

= Form State Support [[FormState]] (version 2.1.4+)

The namespace `fulcro.ui.form-state` (aliased to `fs` in this chapter) includes functions and mutations for
working with your entity as a form. This support brings functions for dealing with common state storage and form transitions
with minimal opinion or additional complexity.

Your UI is still built and rendered identically to what you're already used to. The form state support simply
adds some additional state tracking that can help you manage things like field validation and minimal delta
submissions to the server.

== Defining the Form Component

A component that wishes to act as a form must have an ident and a query.
There are two additional steps you must do to prepare your component to work with form state management:

. Add a form configuration join to your query.
. Declare which of your props/joins are part of the form.

So, a minimal form-state-compatible component looks like this:

```
(defsc NameForm [this props]
  {:query [:id :name fs/form-config-join] ; fs is fulcro.ui.form-state
   :ident [:name-form/by-id :id]
   :form-fields #{:name}} ; MUST be a set of keywords from your query
  ...)
```

Technically this adds a protocol to the generated component. If you're using `defui`, it looks like this:

```
(defui NameForm
  static fs/IFormFields
  (form-field [this] #{:name})
  ...)
```

next, you'll want to populate your state with some data. Of course during this step you'll need to populate that
form configuration data.

== Form Configuration

Form state is stored in a form configuration entity in your app state database. This configuration entity includes:

* The "pristine" state of your entity.
* Which properties (and joins) of your entity are part of the form.
* Which properties are "complete" (ready for validation).
* A map of which parts of the form come from which declared component.

The form state is normalized into your state database. There are two ways of adding this configuration:

. Add it to a tree of initial (or incoming) state, and merge that (which will normalize it all).
. Add it directly to your state database.

both methods are supported:

=== Initializing a Tree of Data

This case occurs when you have either some initial state or a function on the client side that generate a new
entity (i.e. with a tempid) and you want to immediately use it with a form. Forms can be nested into
a group, and the functions automatically support initializing the configuration recursively for a given form set.

Say you have a person with multiple (normalized) phone numbers. You want to make a new person and set them up
with an initial phone number to fill out. The tree for that data might look like this:

```
(def person-tree
  { :db/id (prim/tempid)
    :person/name "Joe"
    :person/phone-numbers [{:db/id (prim/tempid) :phone/number "555-1212"}]})
```

with components like:

```
(defsc PhoneForm [this props]
  {:query [:db/id :phone/number fs/form-config-join]
   :ident [:phone/by-id :db/id]
   :form-fields #{:phone/number}}
  ...)

(defsc PersonForm [this props]
  {:query [:db/id :person/name {:person/phone-numbers (prim/get-query PhoneForm)}
           fs/form-config-join]
   :ident [:person/by-id :db/id]
   :form-fields #{:person/name :person/phone-numbers}}
  ...)
```

Normally you might throw this into your application state with something like:

```
(prim/merge-component! reconciler Person person-tree)
```

which will insert and normalize the person and phone number.

You can first augment the form with form configuration like so:

```
(def person-tree-with-form-support (fs/add-form-config Person person-tree))
(prim/merge-component! reconciler Person person-tree-with-form-support)
```

IMPORTANT: `add-form-config` will look at all of the form (and subforms reachable from that form), but it will
only add config to the ones that are missing it. This means the current form state is *not* reset by this call.

=== Initializing in a Mutation

The other very common case is this: You've loaded something from the server, and you'd like to use it as the basis
for form fields. In this case the data is already normalized in your state database, and you'll need to work on
it via a mutation.

The `add-form-config*` function is your helper for that. The common pattern for using it is:

```
(defmutation use-person-as-form [{:keys [person-id]}]
  (action [{:keys [state]}]
    (swap! state (fn [s]
                   (-> s
                     (fs/add-form-config* Person [:person/by-id person-id]) ; this will get phone as well
                     (assoc-in [:component :person-editor :person-to-edit] [:person/by-id person-id]) ; hook it into an editor?
                     ...))))) ; other setup code
```

IMPORTANT: `add-form-config*` will look at all of the form (and subforms reachable from that form), but it will
only add config to the ones that are missing it. This means the current form state is *not* reset by this call.

== Validation

Validation is completely customizable. There is built-in support for working with Clojure Spec as your validation
layer. In order for this to be effective you should be sure to namespace all of your properties in a globally-unique
way, and then simply write normal specs for them. The section on <<CustomValidators, custom validators>> describes
the other supported mechanism for validation.

The central function for using specs is `fs/get-spec-validity`, which can be used on an entire form or a single field.
This function returns one of `#{:valid, :invalid, :unchecked}`.
Initially, a form's fields are marked as incomplete. When in this state the validity will *always* be `:unchecked`.

Some additional helpers are useful for concise UI code:

* `(invalid-spec? form field)` - Field is optional. Returns true if the form (field) is complete *and* invalid.
* `(valid-spec? form field)` - Field is optional. Returns true if the form (field) is complete *and* valid.
* `(checked? form field)` - Field is optional. Returns true if the form (field) is complete. This function works no matter
what validator you're using.
* `(dirty? form field)` - Field is optional. Returns true if the pristine copy of the form (field) doesn't match the current entity.

```
(defsc PersonForm [this {:keys [person/name] :as props}]
   ...
   (dom/input #js { :value name :onBlur #(prim/transact! this `[(fs/mark-complete ...)]) ...})
   (when (fs/invalid-spec? props :person/name)
      (dom/span nil "Invalid username!")
   ...)
```

and the error message won't show until the user has "blurred" out of that field, and then only if the field's value
does not match the spec for `:person/name`.

As you can see, the idea of "complete" is important to validation.

=== Completing Fields

Initially the form config will not consider *any* of the form fields to be complete. The idea of field "completion" is
so that you can prevent validation on a field until you feel it is a good time. No one wants to see error messages about
fields that they have yet to interact with!

However, depending on what you are editing, you may have different ideas about when fields should be considered complete.
For example, if you just loaded a saved entity from a server, then all of the fields are probably complete by definition,
meaning that you need a way to mark all fields (recursively) complete.

When you *first* add form config to an entity, all fields are "incomplete". You can iteratively mark fields
complete as the user interacts with them, or trigger a completion "event" all at once. There is a support function
and a mutation for this.

The `mark-complete*` is meant to be used from within mutations against the app state database. It requires the
state map (not atom), the entity's ident, and which field you want to mark complete.  If you omit the field, then
it marks everything (recursively) complete form that form down.

So, in our earlier example of loading a person for editing, we'd augment that mutation like so:

```
(defmutation use-person-as-form [{:keys [person-id]}]
  (action [{:keys [state]}]
    (swap! state (fn [s]
                   (-> s
                     (fs/add-form-config* Person [:person/by-id person-id]) ; this will get phone as well
                     (fs/mark-complete* [:person/by-id person-id]) ; MUST come after config is added!
                     (assoc-in [:component :person-editor :person-to-edit] [:person/by-id person-id]))))))
```

this will cause all validations to immediately apply in the UI.

The `mark-complete!` mutation can be used for the exact same purpose from the UI. Typically, it is used in things like
`:onBlur` handlers to indicate that a field is ready for validation. It takes an `:entity-ident` and `:field`, but the
`:entity-ident` is optional if the transaction is invoked on the form component of that field:

```
(defsc PersonForm [this {:keys [db/id person/name]}]
  ... ; as before
  (dom/input #js {:value name
                  :onBlur #(prim/transact! this `[(fs/mark-complete! {:entity-ident [:person/by-id ~id]})])})
  ...)
```

The inverse operations are `clear-complete!` and `clear-complete*`.

=== Using non-spec Validators [[CustomValidators]]

You may not wish to use the longer names of properties that are required in order to get stable Clojure Spec support
simply for form validation. In this case you'd still like to use the idea of field completion and validation, but
you'll want to supply the mechanism whereby validity is determined.

The form traversal code for validation is already in the form state code, and a helper function is provided so
you can leverage it to create your own form validation system. It is quite simple:

. Write a function `(fn [form field] ...)` that returns true if the given field (a keyword) is valid on the given form
(a map of the props for the form that contains that field).
. Generate a validator with `fs/make-validator`

The returned validator works identically to `get-spec-validity`, but it uses your custom function instead of specs to
determine validity.

For example, you might want to make a simple new user form validation that looks something like this:

```
(defn new-user-form-valid [form field]
  (let [v (get form field)]
    (case field
      :username (and (string? v) (seq (str/trim v))) ; not empty
      :password (> (count v) 8)                      ; longer than 8
      :password-2 (= v (:password form)))))          ; passwords match

(def validator (fs/make-validator new-user-form-valid))

(defsc NewUser [this {:keys [username password password-2] :as props}]
   ...
   (dom/input #js {:name "password-2" :value password-2 :onBlur #(prim/transact! this `[(fs/mark-complete ...)]) ...})
   (when (= :invalid (validator props :password-2))
      (dom/span nil "Passwords do not match!")
   ...)
```

As before: you won't see the error message on an invalid entry until your code has marked the field complete. This moves
a decent amount of clutter out of the primary UI code and into the form support itself.

== Submitting Data

Once your form is valid and the user indicates a desire to save your interest of course is to send that data to the
server. The `dirty-fields` function should be used from the UI in order to calculate this and pass it as a parameter
to a mutation. The mutation can then update the local pristine state of form config and indicate a remote operation.

The `dirty-fields` function returns a map from ident to fields that have changed. If the ident includes a temporary ID,
then all fields for that form will be included. If the ID is not a temp id, then it will only include those fields that
differ from the pristine copy of the original. This will include subform references as to-one or to-many idents (to
indicate the addition or removal of subform instances).

You can ask `dirty-fields` to either send the explicit new values (only), or a before/after picture of each field. The
latter is particularly useful for easily deriving the addition/removal of references, but is also quite useful if you
would like to do optimistic concurrency (e.g. not apply a change to a server where the old value wasn't still in the
database).

```
(defmutation submit-person [{:keys [id]}]
  (action [{:keys [state]}]
    (swap! state fs/entity->pristine* [:person/by-id id])) ; updates form state to think the form is now in pristine shape
  (remote [env] true)) ; diff goes over the network as a parameter from the UI layer

(defsc Person [this props]
   ... ; as before
   (dom/button #js {:onClick #(prim/transact! this `[(submit-person ~{:id id :diff (fs/dirty-fields props true)})])} "Submit")
   ...)
```

If you'd like to wait until the server indicates everything is ok, then you can use `ptransact!` and `returning` to get back
some submission information, and move the `entity->pristine*` step to a later mutation:

```
(defmutation submit-person [{:keys [id]}]
  (remote [{:keys [ast state]] (fulcro.client.mutations/returning ast @state SubmissionStatus))

(defmutation finish-person-submission [{:keys [id]}]
  (action [{:keys [state]}]
     (if (= :ok (get-in @state [:submission-status/by-id id :status]))
       (swap! state fs/entity->pristine* [:person/by-id id])
       ...)))

...

(ptransact! this `[(submit-person ~{:id id :diff (fs/dirty-fields props true)})
                   (finish-person-submission ~{:id id})])
```

See <<PTransact, pessimistic transactions>> for more details.

== Form State Demos

The following two fully-functional demos show you complete code for two scenarios.

=== Selecting an Entity for Edit

A very common use case is the scenario where the entities are already loaded and are displayed in the UI. The user
clicks on an entry, and you take them to a form where they can edit the item.

This demo lists some phone numbers. Clicking on one:

* Adds form configuration to the entity
* Switches the UI to the form editor
* Switches back to the (updated) list on save

++++
<div class="example" id="form-state-demo-1"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.form-state-demo-1').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="form-state-demo-1 source"]
----
include::src/book/book/forms/form_state_demo_1.cljs[]
----



=== Loading or Creating Something New

This example shows the case where a graph of entities (a person and multiple phone numbers) are to be
created in a UI, or are to be loaded from a server. This is a full-stack example, though it doesn't actually persist
the data (it just prints what the server receives in the Javascript console).

There are two buttons. One will load an existing entity into the editor, and of course submissions will send a minimal
delta. The other button will create a new person, and submissions will send all fields.

The load case, as you can see in the code, is very similar to the prior example, but just includes some extra
code to show you how to put it together with a load interaction.

++++
<div class="example" id="form-state-demo-2"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.form-state-demo-2').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="form-state-demo-2 source"]
----
include::src/book/book/forms/form_state_demo_2.cljs[]
----


= Full Form Management (Older Support) [[FullForm]]

Fulcro includes support for working with forms. The core purpose of the support is to help you with
the fact that you usually need roughly the same pattern for each form:

* A place to store what the form was before the user started editing
* A way to indicate validation for fields
* A way to calculate and submit the changes the user has made (ideally as a minimal diff)
* A way to relate joined entities as sub forms of a form.
* A way to do file uploads, possibly with progress updates.

All of these things can be written with the primitives that you already have
at your disposal, but the `fulcro.ui.forms` namespace gives you something to start out with
that may very well fit your needs.

== The Basics

Generic form support is a primary rapid application development feature. Fortunately, the overall structure of
Fulcro makes it relatively simple to write form support in a general-purpose, composeable manner. This library
defines form support that has:

- Declarative forms
- An extensible set of form fields
- Extensible validation
- Separation of form UI from form logic
- Remote integration between the form and entity
- Local integration with entities in the browser database

The following `requires` define the namespaces used in the examples:

```
(ns your-ns
  (:require
    [fulcro.client.cards :refer [defcard-fulcro]]
    [clojure.string :as str]
    [com.stuartsierra.component :as component]
    [fulcro.client.dom :as dom]
    [fulcro.client.primitives :as prim :refer [defui defsc]]
    [fulcro.client :as fc]
    [fulcro.client.mutations :as m]
    [fulcro.ui.forms :as f]
    [fulcro.i18n :refer [tr]]))
```

NOTE: When we use the parameter `form` or the word 'form' in the descriptions below, we mean the data
of the entire entity from a table that normally represents something in your application (like a person, phone number, etc).
This library *augments* your database entry with form support data (your 'person' becomes a 'person' AND a 'form'). In
raw technical terms, the `build-form` function takes a map, and adds a `f/form-key { ... }` entry *to it*. The only
implication for your UI is that your component queries must be expanded to include queries for this additional support
data.

== Your Component as a Form

Components that wish to act as forms must meet the following requirements (here `f` is an alias for the forms namespace):

* Must implement the `f/IForm` protocol.
** The `fields` method must return a list of fields that includes an `id-field`
* Must have an ident.
* Must have a query that includes `f/form-key` (an opaque entry the holds the pristine state and definition of the form).
* Entity must be initialized via `f/build-form` (e.g. using a mutation or app initialization).
* Render the form fields using `f/form-field`.

=== Step 1: Declare the Form Fields

Form fields are declared on the ui component that will render the form via a `static f/IForm` protocol. The fields themselves
are declared with function calls that correspond to the field type:

[horizontal]
`id-field`:: A (meant-to-be-hidden) form field that corresponds to the attribute that uniquely identifies the entity being edited. Required for much of the interesting support.
`text-input`:: An optionally validated input for strings.
`dropdown-input`:: A menu that allows the user to choose from a set of values.
`checkbox-input`:: A boolean control
your-input-here!:: Form support is extensible. Whatever interaction you can imagine can be added to a form.

Form fields are really just simple maps of attributes that describe the configuration of the specified input.

The built-in support for doing form logic expects the fields to be declared on the component that will
render the form.

You can use the `:protocols` option of `defsc` to add the IForm to your component:

```
(defsc MyForm [this props]
  {:protocols [static f/IForm
               (form-spec [this] [(f/id-field :db/id)
                                  (f/text-input :person/name)
                                 ...])]}
  ...)
```

The `defsc` macro supports adding this protocol through the `:form-fields` option:

```
(defsc MyForm [this props]
  {:form-fields [(f/id-field :db/id)
                 (f/text-input :person/name)]}
  ...)
```

== Step 2: Rendering the Form Fields

The form fields themselves are rendered by calling `(f/form-field form field-name)`. This method **only** renders
the simple input itself.

```
(f/form-field my-form :name) ;; results in: (dom/input #js { ... })
```

This is the minimum we can do to ensure that the logic is correctly connected, while not interfering with your
ability to render the form however you please.

You'll commonly write some functions of your own that combine other DOM markup with this, such as the function
`field-with-label` shown in the example. Additional functions like `f/invalid?` can be used to make decisions about
showing/hiding validation messages.

```
(defn field-with-label
  "A non-library helper function, written by you to help lay out your form."
  ([comp form name label] (field-with-label comp form name label nil))
  ([comp form name label validation-message]
   (dom/div #js {:className (str "form-group" (if (f/invalid? form name) " has-error" ""))}
     (dom/label #js {:className "col-sm-2" :htmlFor name} label)
     ;; THE LIBRARY SUPPLIES f/form-field. Use it to render the actual field
     (dom/div #js {:className "col-sm-10"} (f/form-field comp form name))
     (when (and validation-message (f/invalid? form name))
       (dom/span #js {:className (str "col-sm-offset-2 col-sm-10" name)} validation-message)))))
```

The rendering of the form is up to you! Thus, your forms can be as pretty (or ugly) as you care to make
them. No worrying about figuring out how we render them, and then trying to make *that* look good.

That said, there is nothing preventing you (or us) from supplying a library function that can produce reasonable looking
reusable form rendering.

== Step 3: Setting Up the Form State

A form can augment any entity in an app database table in your client application. The `f/build-form` function
can take any such entity and add form support to it (under the special key `f/form-key` as an opaque value in state).
The result is perfectly compatible with the original entity. You can do this in `initial-state` if you
know at application startup that a form needs to work on some entity, but more likely
you will compose `f/build-form` into a mutation (for example, a mutation that is changing the UI to display
the form can simultaneously initialize the entity to-be-edited at the same time.

IMPORTANT: If you're doing server-side rendering you should not use `build-form` via initial state. The server cannot
do that properly. There is a mutation that can be run from a component's React `componentWillMount` to recursively
initialize the form support on a specific form with its subforms:

```
(defsc MyForm [this props]
  {:query (fn [] [f/form-key ...])
   :componentWillMount (fn [] (when-not (f/is-form? (prim/props this)) (prim/transact! this `[(f/initialize-form {})])))
   ...}
  ...)
```

Note that this mutation derives all the info it needs by being run on the top-level entity of the form.

== A Complete Form Component

Below is a simple form component (with source) that you can interact with:

++++
<div class="example" id="forms-demo-1"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.forms-demo-1').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="forms-demo-1 source"]
----
include::src/book/book/forms/forms_demo_1.cljs[]
----

== Validation

There is a multimethod `(f/form-field-valid? [symbol value args])`
that dispatches on symbol (symbols are allowed in app state, lambdas are not). Form fields that support validation
will run that validation at their configured time (typically on blur).
Validation is therefore completely extensible. You need only supply a dispatch for your own validation symbol, and
declare it as the validator on a field (by symbol).

Validation is tri-state. The allowed states are `:valid` (checked and correct), `:invalid` (checked and incorrect),
and `:unchecked`.

You can trigger full-form validation (which you should do as part of your interaction with the form) by calling
`(f/validate-entire-form! component form)`. This function invokes a transaction that will update the validation
markings on all declared fields (which in turn will re-render your UI).

If you want to check if a form is valid (without updating the markings in the app state...e.g. you want an inline
answer), then use `(f/valid? (f/validate-fields form))` to get an immediate answer. This is more computationally
expensive, but allows you to check the validity of the form without triggering an actual validation transaction against
the application state.

For example, the definition of a validator for US phone numbers could be:

```
(defvalidator us-phone?
  [sym value args]
  (seq (re-matches #"[(][0-9][0-9][0-9][)] [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]" value)))
```

The only change in your UI would be to add the validator to the form field declaration, along with a validation message.
The result (with source) is in the example below:

++++
<div class="example" id="forms-demo-2"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.forms-demo-2').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="forms-demo-2 source"]
----
include::src/book/book/forms/forms_demo_2.cljs[]
----

== State Evolution

A form will initially record the pristine state of field values during `build-form`. As you interact with
the form the entity data will change (locally only). This allows the library to support:

- The ability to compare the original entity state with the current (edited) state
- Reset the entity state from the pristine condition
- Commit *just* the actual changes to the entity to a remote

**This, combined with a little server code, makes the form support full stack!**

You can trigger the following operations on a form:

- `(f/commit-to-entity! comp)` : Commit the current edits to the entity (no-op if the form doesn't validate)
- `(f/commit-to-entity! comp true)` : Commit the current edits to the entity AND the server (is a no-op if the form doesn't validate)
- `(f/reset-from-entity! comp)` : Undo the changes on the form (back to the pristine state of the original), (triggers validation after the reset)

IMPORTANT: The pristine state is the copy. Editing the fields is identical to editing your entity. A common
question is "Why isn't it the other way around?" The answer is "because of nested forms". Joining together entities
requires a query join and destructuring of props. You already know how to do that with Fulcro. If you were editing
some "hidden" thing, then you would not know how to write, query, or render your nested form components.

=== State evolution within your own transactions

Any changes you make to your entity after `build-form` are technically considered form edits (and make the form *dirty*
and possibly *invalid*).  The built-in form fields just change the state of the entity, and you can too.

Commits will copy the entity state into the form's pristine holding area, and resets will copy from this pristine area
back to your entity.

The primary concern is that any custom fields that you create should be careful to only populate the value of fields
with things that are serializable via transit, since their updated values will need to be transmitted across the wire
for full-stack operation.

== Form Composition

Form support augments normalized entities in your app database. This makes it possible for them to be easily composed!
They are UI components, and have nothing special
about them other than the `f/form-key` state that is added to the entity (through your call of `build-form`).
You can convert any entity in your database to a form using the `build-form` function, meaning that you can load
entities as normal, and as you want to edit them in a form:

. First mutate them into form-compatible entities with `build-form` (which will not touch the original
properties of the entity, just add `f/form-key` data).
. Render them with a UI component (that has the correct entity Ident) with a render method that renders the form
  fields with `form-field`.

=== Example: A More Complete, Nested Form

Here is a running example with source for an application that renders a Person form. The person can have any number of phone numbers,
each represented by a nested phone number entity/form. Note the use of `:initial-state` in Root to build out sample
data. It also includes validation of fields, and some optional rendering based on the checkbox value.

++++
<div class="example" id="forms-demo-3"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.forms-demo-3').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="forms-demo-3 source"]
----
include::src/book/book/forms/forms_demo_3.cljs[]
----

The elements of this demo are discussed in the following sections.

=== Composition and Rendering Refresh

The one caveat is that when forms are nested the mutations on the nested fields cannot (due to the design of Fulcro) refresh
the parent automatically. To work around this, all built-in form mutations will trigger follow-on reads of
the special property `f/form-root-key`. So, if you add that to your parent form's query, rendering of the top-level
form elements (e.g. buttons that control submission) will properly update when any element of a subform changes.

=== Adding Sub-form Elements

Adding a phone number (which acts as a sub-form) is done via the `add-phone` mutation, which looks like this:

```
(defmutation add-phone [{:keys [id person]}]
  (action [{:keys [state]}]
    (let [new-phone    (f/build-form ValidatedPhoneForm {:db/id id :phone/type :home :phone/number " "})
          person-ident [:people/by-id person]
          phone-ident  (prim/ident ValidatedPhoneForm new-phone)]
      (swap! state assoc-in phone-ident new-phone)
      (fc/integrate-ident! state phone-ident :append (conj person-ident :person/phone-numbers)))))
```

Notice that there is nothing really special going on here. Just add an additional item to the database (which is
augmented with `f/build-form`) and integrate it's ident!

For example, the button to run a transaction to add a phone number to
a person creates a tempid for the phone number and passes it as a parameter in the transaction:

```
  (dom/button #js {:onClick #(prim/transact! this
                               `[(add-phone ~{:id     (prim/tempid)
                                              ...})])}
    "Add Phone")
```

=== Compositional Dirty-Checking, Validation, and Submission

The code also shows how you would compose the checks. The `dirty?` function combines the results of the nested forms
together with the top form. You could do the same for validations.

The save button in the example above does a similar thing: it submits the phone numbers, and then the top.
Note that Fulcro combines
mutations that happen in the same thread sequence (e.g. you have not given up the thread for rendering). So, all of
those commits will be sent to the server as a single transaction (if you include the remote parameter).

== Adding Form Field Types

Adding a new kind of form field is simple:

* Create a method that returns a map of input configuration values
* Add a multimethod that can render your field with appropriate hooks into the logic

The built-in text input field is implemented like this:

```
(defn text-input
  "Declare a text input on a form. The allowed options are named parameters:

  :className nm    Additional CSS classnames to include on the input (as a string)
  :validator sym   A symbol to target the dispatch of validation
  :validator-args  Arguments that will be passed to the validator
  :placeholder     The input placeholder. Supports a lambda or string
  :default-value   A value to use in the field if the app-state value is nil
  :validate-on-blur? Should the field be validated on a blur event (default = true)
  "
  [name & {:keys [validator validator-args className default-value placeholder validate-on-blur?]
           :or   {placeholder "" default-value "" className "" validate-on-blur? true}}]
  (cond-> {:input/name              name
           :input/default-value     default-value
           :input/placeholder       placeholder
           :input/css-class         className
           :input/validate-on-blur? validate-on-blur?
           :input/type              ::text}
    validator (assoc :input/validator validator)
    validator-args (assoc :input/validator-args validator-args)))
```

The keys in an input's configuration are:

* `:input/name` : Required. What you want to call the field. Must match an entity property (e.g. :person/name).
* `:input/type` : Required. Usually namespaced. This should be a unique key that indicates what kind of input you're making
* `:input/validator` : Optional. Specifies a symbol (dispatch of the form-field-valid? multimethod).
* `:input/validator-args` : Optional. If there is a validator, it is called with the validator symbol, the questionable value, and these args.
* Any additional keys you want to define : The representation of an input is just a map. Put whatever else you want in this map to help with rendering (e.g. placeholder text,
 class names, style, etc).

and its renderer looks like this:

```
(defn- render-input-field [component htmlProps form field-name type
                           field-value->input-value
                           input-value->field-value]
  (let [id          (form-ident form)
        input-value (field-value->input-value (current-value form field-name))
        input-value (if (nil? input-value) "" input-value)
        attrs       (clj->js (merge htmlProps
                               {:type        type
                                :name        field-name
                                :value       input-value
                                :placeholder (placeholder form field-name)
                                :onBlur      (fn [_]
                                               (prim/transact! component
                                                 `[(validate-field
                                                     ~{:form-id id :field field-name})
                                                   ~@(get-on-form-change-mutation form field-name :blur)
                                                   ~form-root-key]))
                                :onChange    (fn [event]
                                               (let [value      (input-value->field-value (.. event -target -value))
                                                     field-info {:form-id id
                                                                 :field   field-name
                                                                 :value   value}]
                                                 (prim/transact! component
                                                   `[(set-field ~field-info)
                                                     ~@(get-on-form-change-mutation form field-name :edit)
                                                     ~form-root-key])))}))]
    (dom/input attrs)))

(def allowed-input-dom-props #{:id :className :onKeyDown :onKeyPress :onKeyUp :ref :alt :accept :align :autocomplete
                               :autofocus :dirname :disabled :height :max :min :maxLength :pattern
                               :name :size :step :width})

(defmethod form-field* ::text [component form field-name & {:keys [id className] :as params}]
  (let [i->f   identity
        cls    (or className (css-class form field-name) "form-control")
        params (assoc params :className cls)
        f->i   identity]
    (render-input-field component (select-keys params allowed-input-dom-props) form field-name "text" f->i i->f)))
```

You can retrieve a field's current form value with `(f/current-value form field-name)`, and you can obtain
your field's configuration (map of :input/??? values) with `(f/field-config form field-name)`.

The `form-field*` multimethod should, in general, return as little as possible, but you are allowed to do whatever you want.
You are free to make form field renderers that render much more complex DOM, an SVG, etc.

The following built-in mutations can (and should) be used in your event handlers:

- `(fulcro.ui.form/validate-field {:form-id [:ident/by-x n] :field :field-name})` - Run validation on the given form/field. Marks the form state for the field to `:invalid` or `:valid`. Fields without validators
will be marked `:valid`.
- `(fulcro.ui.form/set-field {:form-id [:ident/by-x n] :field :field-name :value raw-value})` - Set the raw-value (you can use any type) onto the form's placeholder state (not on the entity)
- Others listed elsewhere, like those that commit, validate, etc.

== Other Functions of Interest

Since the `form` is also your entity, you may of course pull any entity data from the `form` map. (E.g. you can
for example directly access `(:person/name person-form)`). The form attributes are stored under the `f/form-key` key
and are intended to be opaque. Do not sneak access into the data structure, since we may choose to change the structure
in future versions. Instead, use these:

- `f/current-value` : Get the most recent value of a field from a form
- `f/current-validity` : Get the most recent result of validation on a field
- `f/valid?` : Test if the form (or a field) is currently marked valid (must run validation separately)
- `f/invalid?` : Test if the form (or a field) is currently marked invalid (must run validation separately)
- `f/field-names` : Get the field names on a form
- `f/form-id` : returns the Ident of the form (which is also the ident of the entity)
- `f/validate-fields` : returns a new version of the form with the fields marked with validation. Pure function.
- `f/validate-entire-form!` : Transacts a mutation that runs and sets validation markers on the form (which will update UI)

== Form State and Lifecycle

Form support is meant to track the state of one or more entities throughout
the process of editing. It is important to remember the general
model of Fulcro is one where the application moves from
state to state over time, and the components themselves have (ideally)
no local state.

This means that your form will not change states unless a mutation
of some sort runs.

Many of the form fields *do* run mutations on events, which in turn
change the state of the form or the fields.

A form can have any number of child forms (which themselves can dynamically change
over time).

The lifecycle is as follows:

----
Regular Persisted Entity
      |
      | build-form
      v
Pristine Form <------------+
      |                    |
      | edits/additions    ^
      v                   /|
 Dirty Form -------------/ |
            reset/commit>  +------+
                                  |
Locally Created (tempid)          |
      |                           |
      | build-form                |
      v                           | (server tempid remap)
 Dirty Form                       |
  ^    |                         _|_
  |    | edits/additions/reset/commit
  +----+
----

A form need not be full stack, but if it is then
server interactions would typically occur when you transition from a dirty form
to a pristine one due to a commit.

You are responsible for coding the transactions to ensure that your
concept of a pristine vs. dirty form are consistent in a distributed sense. The
default behavior for the full-stack commit is to optimistically mark the client
form pristine and submit the data to the server. See <<PTransact,
pessimistic transactions>> for details on how to do blocking server interactions.

=== Is my Form Dirty?

A form is considered `dirty?` when:

- Any field of the form or its declared subforms has a value different from
the initial (or most recently committed) value.
- Any form or subform in a set has a tempid (e.g. server remaps have not
yet taken effect)

NOTE: If you're writing forms on a UI that has
no server interaction then you will probably want to generate your own
numeric unique IDs for any new entities to prevent permanently dirty forms.

== Is my Form/Field Valid?

Form fields that support validation will typically run validation on the field when that
field is manipulated. Full-form validation can be done at any time by composing `validate-fields`
into your own mutation (see also `on-form-change`). The system is fully flexible, and for the
most part validation is composable, extensible, configurable, and happens at transaction
boundaries in whatever ways you define.

Validation is tri-state. All fields start out `:unchecked`. If you wish your form to start out
`:valid` then you can compose a call to `f/valiate-fields`:

```
;; NOTE: non-recursive validation. You'd have to use this explicitly on each declared subform state as well.
(let [initial-form (f/validate-fields (f/build-form MyForm my-entity-props))
      ...
```

The functions `valid?` and `invalid?` honor the tri-state nature of forms (e.g. `invalid?` returns
true if and only if at least one field is `:invalid`, and `valid?` returns true if and only if all fields are
`:valid`). The `:unchecked` state thus allows you to prevent error messages from
appearing on fields until you're actually ready to validate them:

```
;; only emits if the field is actually marked :invalid (not :unchecked)
(when (invalid? this-form :field) (dom/span nil "Invalid!"))

;; Disables submit button unless all fields are marked `:valid` (none are :unchecked or :invalid)
(dom/button #js {:disabled (not (valid? form)) :onClick submit} "Submit!")
```

The tricky part is that global validation is never triggered by built-in field interaction because
that would not allow you to control your form UI very well (e.g. fields might show validation errors when
the user hasn't even interacted with them yet).

Thus, you have a few ways of dealing with validation checking:

1. Trigger a `f/validate-form` mutation. Such a mutation will recursively walk your form and
subforms and mark all fields with `:invalid` or `:valid`. This will have the effect of
showing validation messages that are defined in the examples above.
2. Compose the `f/validate-forms` helper function into your own mutation. This function works against
an app state map and recursively updates a form/subforms. (see the source for `defmutation validate-form`)
3. Use the `would-be-valid?` function on the forms props (e.g. in the UI). This function returns true
if the supplied form (and subforms) would be valid if validation was run on it. It essentially runs
validation in a pure functional way.

If using (1) or (2), then the methods `valid?` and `invalid?` can recursively test the validity. Note that
as fields are changed the state of those fields may return to unchecked (which is neither valid or invalid).

== Server Integration

A form (and associated subforms) have support for saving state to the
server. This support takes the best view it possibly can of the possible
things a user can do to an entity via a form:

A user should be able to:

. Change the value of one or more fields.
. Add a completely new entity (with tempid) to the database (e.g. new form or new subform)
. Link an existing form to an instance of a subform. The subform might have been looked up (by your code)
or created (via 2).
. Remove the linkage from a form to a subform.

=== Handling Submission of a Form

Form submission has some general helpers. In general, *it is recommended that you write your own
custom mutation to do a form submission*, but there is a general-purpose mutation that can also do it
for you.

The advantage of using the general-purpose mutation is that it is already written, but the disadvantage is that
all of your form submissions become centralized into a single point of entry in the server and more significantly
become difficult to distinguish from each other in the actual transaction logs.

Thus, when getting started you might choose to play with the built-in mechanism, but as you progress we highly
recommend you customize form submission, which is actually quite simple to do.

==== Built-in Form Submisssion – `commit-to-entity`

A form submission can be done via the `commit-to-entity` function/mutation with the inclusion
of a `:remote` flag. The function version `commit-to-entity!` is a simple wrapper of a
`transact!` that invokes the `f/commit-to-entity` mutation (where `f` is the forms namespace).
The former is a convenience, and the latter is more useful when you want to compose commit with
other transaction actions (such as navigation away from the form).

The wrapper function must be called using the `this` of the component that is the top-level of the form,
and the mutation must be called with the `props` of the top-level form.

Both default to a local commit (where you can deal with persistence in some other way), but if you supply
them with a remote argument they will send the *changes* to the data in the form to the server. Of course,
new entities will be completely sent.

Of course to handle this mutation you must implement a server-side mutation with the fully-namespaces
`fulcro.ui.forms/commit-to-entity` name.

==== Custom Form Submission

Custom form submission allows you to do a number of custom things:

* Choose optimistic *or* response-driven form submission.
* Combine submission with other form checking logic and UI updates.
* Name your submit mutation so that you can easily keep them separate.

The primary utility functions in `fulcro.ui.forms` for implementing such mutations are:

* `(f/diff-form form-root-props)`: This function calculates a diff of the form (and subforms). Only new and changed
data will be included (see later sections). You must pass this function the tree version of a form (e.g. pass the form-props
as an arg to the mutation). It is important to calculate the diff outside of the mutation, because of the multi-pass nature
of mutation bodies (e.g. you'll need the delta in remote, but action may have already done an optimistic local commit).
* `(f/entity-xform state-map ident f)` Recursively walks a form set starting at `ident` in `state-map` running `f` on each (sub)form.
* `(f/commit-state form-props)`: This is a non-recursive function that copies form data from the edited area to the
pristine area locally. Typically called as `(swap! state f/entity-xform form-ident commit-state)`.
(which must be sent from the UI invocation of transact as a parameter or reconstituted as a tree with `db->tree`). It
copies the new state to the pristine state, making the form appear complete and clean (submitted) on the client.
* `(f/reset-entity form-props)`: The opposite of `commit-state`, but called via `entity-xform` as well.
* `(f/would-be-valid form-props)` : Requires a tree of form props (e.g. from the UI or `db->tree`). Returns true if
the given form would be considered valid if a validation mutation were run on it. Useful in form submission logic where
pushing validation data to the UI can be bypassed because you can tell it is OK.
* `(f/dirty? form-props)`: Requires tree of props (from UI). Returns true if the form has changes (needs a submit)
* `(f/validate-forms state-map form-ident)`: Used from *within* mutations. Causes form validation mutation on the
recursive form, which will cause UI updates. Use this if you decide not to submit the form and want to show why on the UI.

Notice that a lot of these functions are meant to be usable at the UI (they work on a tree of form props). The reason
there are not two versions is that because of optimistic updates and how mutations work, it is advisable to pass your
form's tree of props through to the mutation, so that your mutation closes over the form state at the time of user
interaction. This allows you to properly calculate your form delta and have a consistent snapshot for the remote
interaction.

It is useful to study the code of the built-in commit, and mimic parts of the behavior for your own mutations:

The `commit-to-entity!` function calls transact, but note how it pulls props and constructs the mutation to
include that tree. It also triggers validation, to ensure that the UI shows updated validation messages (clearing
errors or adding new ones). It also includes the `f/form-root-key` to ensure the entire form set will re-render:

```
(defn commit-to-entity!
  [component & {:keys [remote rerender fallback fallback-params] :or {fallback-params {} remote false}}]
  (let [form          (prim/props component)
        fallback-call (list `df/fallback (merge fallback-params {:action fallback}))]
    (let [is-valid? (valid? (validate-fields form))
          tx        (cond-> []
                      is-valid? (conj `(commit-to-entity ~{:form form :remote remote}))
                      (and is-valid? (symbol? fallback)) (conj fallback-call)
                      (not is-valid?) (conj `(validate-form ~{:form-id (form-ident form)}))
                      (seq rerender) (into rerender)
                      :always (conj form-root-key))]
      (prim/transact! component tx))))
```

The mutation itself now has all of the data it needs to calculate a diff and such. Here is its implementation:

```
(defmutation commit-to-entity
  [{:keys [form remote]}]
  (action [{:keys [state]}] (swap! state entity-xform (form-ident form) commit-state))
  (remote [{:keys [state ast target]}]
    (when (and remote target)
      (assoc ast :params (diff-form form)))))
```

Note that the local optimistic update just copies the edited state over top of the pristine (this mutation
isn't run if the form doesn't validate...see the earlier function).

The remote side modified the parameters so that instead of sending the form's UI tree to the server, it instead
sends a calculated diff. See below for how to deal with this diff.

=== What Your Server Must Do

On the server, you must provide a mutation handler for your mutation or the `f/commit-to-entity` symbol.
If you're using multimethods on the server, this might look like:

```
(ns amazing-server.mutations
  (:require
    [fulcro.server :as server]))

(server/defmutation fulcro.ui.forms/commit-to-entity [params]
  (action [env] ...))
```

The complete form delta will be in the incoming `params`. The description of the entries in `params`
is below.

==== Processing a Form's Diff [[FormDiff]]

The incoming parameters is a map. This map will contain up to four different keys to indicate
what changed on the client.

===== Form Field Updates

Field updates are sent under the following conditions:

* The entity of the form has a real id (not a temp id)
* One or more fields have values different from those at the time of `build-form` or the last commit.

The parameters sent to the `commit-to-entity` mutation on the server will include the key
`:form/updates` whose value will be a map. The map's keys will be client-side idents of
the entities that changed, and the values will be maps of k-v pairs of the data the changed.

Examples:

```
{:form/updates { [:thing 1] {:field-a 1 }
                 [:thing 2] {:field-b 55 }}}
```

NOTES:

* Updates will *never* include referential updates (e.g. A references subform element B). See
New Relations and Removed Relations below.
* Fields on the entity in the UI that are *not* declared as form fields *will never* appear in
an update.

===== New Entities

When a form (and/or subforms) is submitted that has a primary ID whose value is a tempid then
the incoming commit parameters will include the `:form/new-entities` key. The value of this entry is just like
that of `:form/updates`, but the ID in the ident will be a tempid (which you must send remaps
back for), and the map of data will include all attributes of that entity that were declared as part
of the form.

```
{:form/new-entities { [:thing tempid-1] {:field-a 1 :field-b 55 }
                      [:thing tempid-2] {:field-a 8 :field-b 42 }}}
```

It is important that you remember to return a map to remap the incoming tempids:

```
(defmethod my-mutate `f/commit-to-entity [env k params]
  {:action (fn []
         ...
         {:tempids {tempid-1 realid-1 tempid-2 realid-2}})})
```

Some additional notes:

* New entity properties include only the columns declared in the form support. Remember that you can
declare fields without rendering them.
* New entity entries *do not include* references! Any reference changes are always expressed
with linkage change entries, as described below.

===== New Relations

If a subform is explicitly declared, then new linkage between a form and the subforms will
be expressed via the `:form/add-relations` entry. The value will be a map whose keys are idents of the
referring object and whose values are a single ident (in the to-one case) or vectors of the idents (in the to-many
case) of the new targets. This is a delta. This is
not meant to be interpreted as all of them, just the ones that were added since the form was considered
clean.

Examples:

Two different to-one relationship additions:

```
{:form/add-relations { [:thing tempid-1] {:thing/child [:thing tempid-2] }
                       [:thing tempid-2] {:thing/parent [:thing tempid-1] }}}
```

A to-many parent-child relationship with two new children:

```
{:form/add-relations { [:people/by-id 1] {:person/number [[:phone/by-id 2] [:phone/by-id 3]] }}}
```

===== Removed Relations

If a subform is explicitly declared, then removal of linkage between a form and the subforms will
be expressed via the `:form/remove-relations` entry. The value will be a map whose keys are idents of the
referring object and whose values are just like in the new linkage. This is also a delta.

Examples:

Removal of a to-one relation:

```
{:form/remove-relations { [:thing 1] {:thing/child [:thing 2] }}}
```

Removal of a single child in a to-many relation:

```
{:form/remove-relations { [:people/by-id 1] {:person/number [[:phone/by-id 3]] }}}
```

=== Updating a forms-based Entity From the Server

Since your app state is normalized, any reads of an entity will end up being merged over top of
the entity you already have. This means that your active form fields on such an entity would
update.

There are some caveats to doing this, since the *remembered* state of your form will now be out
of sync with what you read (or pushed) from the server.

Typically what you'll want to do when (re)reading an entity that is being actively used on a form is:

. Issue a Fulcro load for that entity. The incoming state will cause the UI of the form to update
(since you're always editing/rendering active state of the entity). Unfortunately, the pristine state
of the form now thinks the newly loaded entity is *dirty*!
. Include a post mutation, which should:
** `dissoc` the form state via `(update-in app-state form-ident dissoc f/form-key)`
** Run `build-form` on the form
** Optionally use the `validate-fields` or `validate-forms` function to update the validation markers.

A non-remote (local-only) commit-to-entity (still as a post-mutation) could also be used to accomplish (2).

== Forms – Whole Form Logic

Many forms need logic that updates the UI in some non-local way as form interactions take place.
Simple field validations can be local to a field, but some UI changes require whole-form reasoning
or cross-field interactions.

Some simple examples:

* Verification fields (two fields must contain the same data to ensure they typed it correctly)
* Triggering a server-side check of a value (e.g. is that username in use?)
* Making other UI elements appear/disappear according to field changes

We accomplish these things in the form support by allowing you to declare an entry in your
`IForm` list that names a Fulcro mutation to run as changes are detected in the form/subform
set.

The mutation given is just a normal mutation that can do anything you need done: remoting, global
reasoning, etc.

Only one (the last if more than one) `on-form-change` can be declared on a form. Use other composition
techniques to make a single mutation if you'd like multiple operations on the form change.

```
(defsc Person [this props]
  {:initial-state [params] (fn [params] (f/build-form this (or params {})))
   :form-fields [(f/id-field :db/id)
                 (f/on-form-change `check-username-available)
                 (f/text-input :person/name)
                 (f/integer-input :person/age)]}
  ...
```

=== The Events

The form change support can send events on change and on blur. The latter is useful for regular
input fields (as opposed to checkboxes, for example). Your mutation will be passed parameters
as a map that has:

[Horizontal]
`:form-id`:: The ident of the form that generated the event
`:kind`:: Either :blur or :edit
`:field`:: The name of the field affected

Your mutation can do anything a normal mutation can do.

=== An Example

In this example, we'll use remoting to ask the server (on field blur) if a given username is
already in use (in our code, 'sam' and 'tony' are taken). The client-side mutation looks like this:

```
(defmutation check-username-available
  [{:keys [form-id kind field]}]
  (action [{:keys [state] :as env}]
    (when (and (= kind :blur) (= :person/name field)) ; only do things on blur
      (let [value (get-in @state (conj form-id field))] ; get the value of the field
        (swap! state assoc-in (conj form-id :ui/name-status) :checking) ; set a UI state to show progress
        (df/load-action env :name-in-use nil {:target  (conj form-id :ui/name-status) ; trigger a remote load
                                                :refresh [f/form-root-key] ; ensure the forms re-render
                                                :marker  false ; don't overwrite our marker with a loading marker
                                                :params  {:name value}})))) ; include params on the query
  (remote [env] (df/remote-load env))) ; trigger eval of network queue to see if there is anything remote to do
```

and a server-side query function would satisfy the `:name-in-use` query with something like this
(users is just a set of existing usernames in our sample code):

```
(def users #{"tony" "sam"})

(defquery-root :name-in-use
  (value [env [{:keys [name]}]]
    (if (contains? users name) :duplicate :ok)))
```

Now, the sequence of interactions is as follows:

. The user blurs on the username field (we could also debounce edit events)
. The mutation places a marker in the app state that allows the UI to show the 'checking' message
. The mutation causes a remote query targeted to the marker location
. When the server query completes, it overwrites the marker from (2) with the server response

The main catch is the `:refresh` argument to the `load-action`. This ensures that the form gets
re-rendered when the request completes. Of course, this could have just as easily been any keyword
queried by Person.

The general Person form UI looks like this:

```
(defsc Person [this {:keys [ui/name-status] :as props}]
  {:initial-state (fn [params] (f/build-form this (or params {})))
   :query         [f/form-root-key f/form-key :db/id :person/name :person/age :ui/name-status]
   :ident         [:person/by-id :db/id]
   :form-fields   [(f/id-field :db/id)
                   (f/on-form-change `check-username-available)
                   (f/text-input :person/name)
                   (f/integer-input :person/age)]}
  (dom/div #js {:className "form-horizontal"}
    (field-with-label this props :person/name "Username:"
      (case name-status
        :duplicate (b/alert {:kind :warning}
                     "That username is in use." (i/icon :error))
        :checking (b/alert {:color :neutral}
                    "Checking if that username is in use...")
        :ok (b/alert {:color :success} "OK" (i/icon :check))
        ""))
    (field-with-label this props :person/age "Age:")
    (dom/div #js {:className "button-group"}
      (dom/button #js {:className "btn btn-default"
                       :disabled  (not (f/dirty? props))
                       :onClick   #(f/commit-to-entity! this :remote true)}
        "Save!"))))
```

Note, in particular, that the query includes `:ui/name-status` and rendering code for the possible
values of status. The UI is completely disconnected from the fact that remoting is being used
to verify the username.

The complete running example with source is below.

++++
<div class="example" id="whole-form-logic"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.whole-form-logic').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="whole-form-logic source"]
----
include::src/book/book/forms/whole_form_logic.cljs[]
----

== Full Stack Form Demo

In this demo we're still using a simulated server. We're also using browser local
storage to make sure the changes you make look like they get persisted, so you should see your edited
data on page reloads.

=== Application Load

When the application loads it uses `data-fetch/load` to query the server for
`:all-numbers`.

```
(df/load app :all-numbers PhoneDisplayRow {:target [:screen/phone-list :tab :phone-numbers]})
```

We have a very simple database that looks like this on the server:

```
(defn make-phone-number [id type num]
  {:db/id id :phone/type type :phone/number num})

(defonce server-state (atom {:all-numbers [(make-phone-number 1 :home "555-1212")
                                           (make-phone-number 2 :home "555-1213")
                                           (make-phone-number 3 :home "555-1214")
                                           (make-phone-number 4 :home "555-1215")]}))
```

The server query handler is just:

```
(defquery-root :all-numbers
  (value [env params]
    {:value (get @server-state :all-numbers)} ))
```

=== The UI

We're using a UI router via defrouter to create two screens: A phone list and phone editor screen.

The basic UI tree looks like this:

----
           Root
             |
       TopLevelRouter
         /          \\
  PhoneEditor     PhoneList
      |               / | \\
  PhoneForm       PhoneDisplayRow...
----

The UI starts out showing PhoneList. Clicking on an element leads to editing.

=== The Mutations

Note: PhoneForm and PhoneDisplayRow share the same ident since they render two differing views
of the same entity in our database.

==== Editing

Since the phone numbers were loaded from raw data on a server, they are not form capable yet.

Thus, the application must do a few things in order for editing to work:

* It must add form state to the entity using `build-form`. We create a quick helper function
to do this against app state (the function `phone-ident` just returns the ident of a phone
number based on the simple ID):
+
```
(defn- initialize-form [state-map form-class form-ident]
  (update-in state-map form-ident #(f/build-form form-class %)))
```
+
* The form itself needs to link up to the thing it should edit. In order words we need to write
an ident into PhoneEditor to point it to the (newly initialized) PhoneForm instance. We write
another helper to do this against app state (as a map). Note the path is just the ident of the
PhoneEditor combined with the field name.
+
```
(defn- set-number-to-edit [state-map phone-id]
  (assoc-in state-map [:screen/phone-editor :tab :number-to-edit] (phone-ident phone-id)))
```
+
* Tell the top UI router to change UI routes. We can do this with the built-in `route-to` mutation.
* Indicate what data changed. We can do this with a follow-on read at the call site, or just declare the
refresh list in the mutation.

Our final `edit-phone` mutation is thus:

```
(defmutation edit-phone
  [{:keys [id]}]
  (action [{:keys [state]}]
    (swap! state (fn [state-map]
                   (-> state-map
                     (initialize-form PhoneForm (phone-ident id))
                     (set-number-to-edit id)
                     (r/update-routing-links {:route-params {}
                                              :handler      :route/phone-editor})))))
  (refresh [env] [:main-ui-router]))
```

=== Commit and Reset

Commit and reset are a built-in mutations.  They both have a function and mutation-composable version (the former
just calls transact for you). Often you'll want to combine other operations with a commit or
reset, as is shown in the form editor.

The Save button runs a commit operation with a remote flag. This causes the changes to not only be sync'd with
the form's pristine state, it also causes a network (in this case simulated) request to have the server update
its copy.

See the <<FormDiff, form diff section>> for the full possible items in such a request. For this example we'll describe
just the one we're supporting: Updates.

The parameters passed to the server on update have
a `:form/updates` key with a map whose keys are the idents of things that changed, and whose values are maps
of the field/value updates. For example:

```
{:form/updates {[:phone/by-id 1] {:phone/number "444-5421"}}}
```

would be sent to indicate that phone number with id 1 had just its `:phone/number` attribute changed to the
new value "444-5421".

So, a really naive implementation of this update handler looks like this:

```
(defn update-phone-number [id incoming-changes]
  (log/info "Server asked to updated phone " id " with changes: " incoming-changes)
  (swap! server-state update-in [:all-numbers (dec id)] merge incoming-changes)
  ;; simulate saving to "disk"
  (.setItem js/localStorage "/" (pr-str @server-state)))
```

The server commit handler is pretty simple as well:

```
(server/defmutation fulcro.ui.forms/commit-to-entity [p]
  (action [env]
    (let [updates (-> p :form/updates)]
      (doseq [[[table id] changes] updates]
        (case table
          :phone/by-id (update-phone-number id changes)
          (log/info "Server asked to update unknown entity " table)))) ) )
```

You can see the full source and play with the demo below:

++++
<div class="example" id="full-stack-forms-demo"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.full-stack-forms-demo').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="full-stack-forms-demo source"]
----
include::src/book/book/forms/full_stack_forms_demo.cljs[]
----

= Server-side Rendering

Single-page applications have a couple of concerns when it comes to how they behave on the internet at large.

The first is size. It is not unusual for a SPA to be several megabytes in size. This means that users on
slow networks may wait a while before they see anything useful. Network speeds are continually on the rise
(from less than 1kbps in the 80's to an average of about 10Mbps today). This is becoming less and less of an issue,
and if this is your only concern, then it might be poor accounting to complicate your application just to shave
a few ms off the initial load. After all, with proper serving you can get their browser to cache the js file
for all but the first load of your site.

The second more important concern is SEO. If you have pages on your application that do not require login and you
would like to have in search engines, then a blank HTML page with a javascript file isn't going to cut it.

Fortunately, Fulcro has you covered! Server-side rendering not only works well in Fulcro, the central mechanisms of
Fulcro (a client-side database with mutations) and the fact that you're writing in one language actually make
server-side rendering shockingly simple, even for pages that require data from a server-side store! After all,
all of the functions and UI component queries needed to normalize the tree that you already know how to generate on
your server can be in CLJC files and can be used without writing anything new!

== Recommendations

In order to get the most out of your code base when supporting server-side rendering, here are some general recommendations
about how to write your application. These are pretty much what we recommend for all applications, but they're particularly
important for SSR:

=== Use Initial State on Components That Appear on Client Start

This is true for every application. We always encourage it. It helps with refactoring, initial startup, etc. When
doing server-side rendering you won't need this initial state on the client (the server will push a built-up state);
however, the server does need the base minimum database on which it will build the state for the page that will
be rendered.

IMPORTANT: For SSR you will *move* initial state from *just* your `Root` node to a function. The reason for this
is that Fulcro ignores explicit application state at startup if it can find initial state on the root node, and
we want to force state into the client.

This will become clearer when we get to examples.

=== Write Mutations via Helper Functions on State Maps

When writing a mutation, first write a helper function. Perhaps end it's name with `-impl` or even `*`. The
helper function should take the application database state map (*not* atom) and any arguments needed to accomplish the
task. It should then return the updated state map:

```
; in a CLJC file!
(defn todo-set-checked-impl [state-map todo-id checked?]
   (assoc-in state-map [:todo/by-id todo-id :item/checked?] checked?))
```

Then write your mutation using that function:

```
; CLJS-only, either separate file or conditionally in CLJC
(defmutation todo-set-checked [{:keys [id checked?]}]
  (action [{:keys [state]}]
    (swap! state todo-set-checked-impl id checked?)))
```

This has a very positive effect on your code: composition and re-use!

```
; composition
(defmutation do-things [params]
  (action [{:keys [state]}]
    (swap! state (fn [s] (-> s
                             (do-thing-1-impl)
                             (do-thing-2-impl)
                             ...))))
```

Of course composition is re-use, but now that your client db mutation implementation is available in clj and cljs you
can use it to initialize state for your server-side render!

NOTE: The new mutation `^:intern` support also gives you a way to get a function that applies the mutations actions
on a state atom.

=== Use HTML5 Routing

You have to be able to detect the different pages via URL, and your application also needs to respond to them. As a
result you will need to make all of the pages that are capable of server-side also have some distinct URI representation.

== Overall Structure

Here's how to structure your application to support SSR:

. Follow the above recommendations for the base code
. The server will use the client initial app state plus a sequence of mutation implementations to build a normalized database
. The server will serve the same basic HTML page (from code) that has the following:
    * The CSS and other head-related stuff and the div on which your app will mount.
    * A div with the ID of your SPA's target mount, which will contain the HTML of the server-rendered application state
    * A script at the top that embeds the normalized db as a transit-encoded string on `js/window`.
    * A script tag at the bottom that loads your client SPA code
. The client will look for initial state via a var set on `js/window` (transit-encoded string) and start
. The client will do an initial render, which will cause react to hook up to the existing DOM

=== Building the App State on the Server

The `fulcro.server-render` namespace has a function called `build-initial-state` that takes the root component
and an initial state tree. It normalizes this and plugs in any union branch data that was not in the tree itself
(by walking the query and looking for components that have initial state and are union branches). It returns
a *normalized* client application db that would be what you'd have on the client at initial startup if you'd
started the client normally.

So, now all you need to do is run any combination of operations on that map to bring it to the proper state. Here's the
super-cool thing: your renderer is pure! It will render exactly what the state says the application is in!

```
(let [base-state (ssr/build-initial-state (my-app/get-initial-state) my-app/Root)
      user       (get-current-user (:session req))
      user-ident (util/get-ident my-app/User user)]
   (-> base-state
     (todo-check-item-impl 3 true) ; some combo of mutation impls
     (assoc :current-user user-ident) ; put normalized user into root
     (assoc-in user-ident user)))
```

So now you've got the client-side db on the server. Now all you need to do is pre-render it, and also
get this generated state to the client!

=== Rendering with Initial State

Of course, the whole point is to pre-render the page. Now that you have a complete client database this is
trivial:

```
(let [props                (prim/db->tree (prim/get-query app/Root normalized-db)
      root-factory         (prim/factory app/Root)]
  (dom/render-to-str (root-factory props)))
```

will generate a string that contains the current HTML rendering of that database state!

=== Send The Completed Package!

Now, while you have the correct initial look, you will still need to get this database state into the client.
While you could technically try loading your UI's initial state, it would make the UI flicker because when React
mounts it needs to see the exact DOM that is already there. So, you must pass the server-side generated-database
as initial-state to your client.
The function `fulcro.server-render/initial-state->script-tag` will give you a `<script>` tag that includes
a string-encoded EDN data structure (using transit).

We now combine what we learned about generating the application's rendering with this to get the overall
response from the server:

```
(defn top-html [normalized-db root-component-class]
  (let [props                (db->tree (get-query root-component-class) normalized-db normalized-db)
        root-factory         (factory root-component-class)
        app-html             (dom/render-to-str (root-factory props))
        initial-state-script (ssr/initial-state->script-tag normalized-db)]
    (str "<!DOCTYPE) html>\n"
      "<html lang='en'>\n"
      "<head>\n"
      "<meta charset='UTF-8'>\n"
      "<meta name='viewport' content='width=device-width, initial-scale=1'>\n"
      initial-state-script
      "<title>Home Page</title>\n"
      "</head>\n"
      "<body>\n"
      "<div id='app'>"
      app-html
      "</div>\n"
      "<script src='js/app.js' type='text/javascript'></script>\n"
      "</body>\n"
      "</html>\n")))
```

Now let's move on to the client.

=== Client-Side – Use Initial State

When creating your client, you will now be explicit about initial state and use a helper function (provided)
to decode the server-sent state:

```
(defonce app (atom (fc/new-fulcro-client :initial-state (fulcro.server-render/get-SSR-initial-state))))
```

Of course, you could use `:started-callback` to do various other bits (like start your HTML5 routing), but this
completes the essential pattern. No other client modifications need to be made!

== A Complete Working Example

There is a complete working example of these techniques (including the HTML5 routing) in the
[fulcro-template](https://github.com/fulcrologic/fulcro-template).

* [Server-side logic](https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/server.clj)
* [HTML5 Routing](https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/ui/html5_routing.cljc)
* [Client-side Initial State Generation and Modifications](https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/ui/root.cljc) (see `initial-app-state-tree`)
* [Client Start-up](https://github.com/fulcrologic/fulcro-template/blob/master/src/main/fulcro_template/client.cljs) Note this example tolerates a failure of the server to send
initial state, so it runs initial startup steps if it detects that.

== True Isomorphic Support with Nashorn (JVM Javascript engine)

If you use external Javascript libraries of React components then you have two choices.

. Write wrappers in cljs that can output something reasonable for them in SSR, and them make
cljc wrappers that use the JS when on the client, and your placeholder dom on the server.
. Use Nashhorn on the server to actually run a render in a Javascript engine on the server.

Using placeholders can work very well, and is the *recommended approach*.

If you're willing to work just a little bit harder then you can maintain a true isomorphic application using Java
8+ and the Nashorn ECMA scripting engine.

Some notes:

* Server-side use of the compiled Javascript works best with advanced-optimized builds. Figwheel and other development
builds of the javascript won't work right, and we've even seen problems with builds that don't use advanced optimizations.
* (1) means that your SSR is going to be hard to work with if you're in dev (figwheel) mode. The recommendation is that
you test SSR as a separate step (where you can have an auto incremental build with advanced compilation). Figwheel hot loads
code updates anyhow, so not having SSR when working in development mode isn't really a big loss.

The basics are:

* Start a Nashorn instance
* Run a script that defines console and global
* Run the compiled script of your program to define everything
* Use a render to string call to get the initial HTML output

The js script to defined console and global is just:

```
var global = this;

var console = {};
console.debug = print;
console.warn = print;
console.error = print;
console.log = print;
var usingNashorn = true;
```

Client main (which does the mount) becomes:

```
(when-not (exists? js/usingNashorn)
 (reset! app (core/mount @app root/Root "app")))
```

Server rendering (client-side cljs) is:

```
(def ui-root (prim/factory root/Root))

(defn ^:export server-render [props-str]
 ; incoming data will come from JVM as transit-stringified EDN
 (if-let [props (some-> props-str util/transit-str->clj)]
   (js/ReactDOMServer.renderToString (ui-root props))
   (js/ReactDOMServer.renderToString (ui-root (prim/get-initial-state root/Root nil)))))
```

And the server-side code holds a script engine in an atom or something (a component would be best), and
accomplishes the rendering of a given tree of UI props via:

```
(defn ^String nashorn-render
[props]
(try
 (start-nashorn)
 (let [string-props  (util/transit-clj->str props)
       script-engine ^NashornScriptEngine @nashorn
       ; look up the object that holds the defs of the server-render function (using js naming)
       namespc       (.eval script-engine "namespace.of.server_render")
       ; invoke the server-render function, and pass in a transit-stringified EDN version of props
       ; invokeMethod is varargs, which is what the into-array is about
       result        (.invokeMethod script-engine namespc "server_render" (into-array [string-props]))
       html          (String/valueOf result)]
   html)
 (catch ScriptException e
   (timbre/debug "Server-side render failed. This is an expected error when not running from a production build with adv optimizations.")
   (timbre/trace "Rendering exception:" e))))
```

There is a `nashorn` branch on the github `fulcro-template` project that demonstrates the setup and rendering code.


= Client Networking with Fulcro HTTP Remote (version 2.3+) [[Networking]]

Fulcro 2.3 and above has an implementation that uses Google's XhrIO to implement a networking layer for Fulcro that is
much easier to extend than earlier Fulcro versions.

This new version also brings a few new features:

* It uses middleware for the request and response so you can customize the entire communication pipeline without having to deal with
low-level networking. A remote can now manipulate everything from the request headers to the URL and even the raw data on the wire.
* It allows you to give network requests and ID, and later abort them if desired.
* It includes support for progress updates on mutations, which are commonly used for things like file uploads.

== Creating a Remote

A remote with these new features requires very little code:

```
(fc/new-fulcro-client :networking {:remote (net/fulcro-http-remote {})})
```

This will give you support for the abort and progress features.

You may include a `:url` parameter to specify what the server endpoint is (defaults to "/api").

== Aborting a Request

The first thing you need to do is assign an abort ID to the request. The `load` API allows an `:abort-id` parameter.
Mutations use the AST mechanism of the mutation API:

```
(load this :thing Thing {:abort-id :thing})

...

(defmutation do-something [params]
   ...
   (remote [{:keys [ast]}]
     (m/with-abort-id ast :SOME-ID)))
```

The API for aborting a request is on the `FulcroApplication` protocol (networking is coordinated at the
application level), which means you need access to the applcation in order to run aborts.
The recommended way to deal with aborts is:

* Hold your mounted app in an atom, say in your `client` namespace.
* Write a mutation in your client namespace that can access this `app` atom.

```
(ns my-client
  (:require [fulcro.client :as fc]
            [fulcro.client.mutations :refer [defmutation]]
            [loading.ui.root :as root]
            [fulcro.client.network :as net]))

(defonce app (atom nil))

(defn abort* [id]
  (when @app
    (fc/abort-request! @app id)))

(defmutation abort [{:keys [id]}]
  (action [env]
    (abort* id)))
```

Then you can either directly call the `abort*` function (if it does not create a circular require) or
just invoke the mutation from anywhere (since mutations are just symbol data):

```
(transact! component `[(my-client/abort {:id :ID})]`)
```

Aborting a request that has yet to start networking results in no change to app state. It simply removes the
request from the queue.

Aborting an active request stops the network transaction and acts as if the requested data resulted in an
empty map from the server (so that load merge will overwrite the target with nothing). If this is a problem
then target the load to a placeholder location and use a post-mutation to move it when load
completes.

== Progress Updates

Obtaining progress updates on mutations are requested the same way as abort IDs: through AST manipulation on the mutation:

```
(defmutation some-mutation [params]
  (remote [{:keys [ast]}]
     (m/with-progressive-updates ast `(progress-mutation {:x 1}))))
```

Progress updates are sent to the given mutation (which will always receive the parameters you specified). The parameters
will be augmented with information about the current progress:

* `:progress-phase` - will be one of :sending, :receiving, :complete, or :failed.
* `:progress-event` - the raw XhrIO event (which has loading progress data)
* `:transaction` - The transaction that is running
* `:body` - The current low-level body (out or in). Body is processed through the middleware, and could be partial.
* `:status-code` - The HTTP status code if receiving.

The `fulcro.client.network/progress%` function can be used to convert this into a number between 0 and 100.

Progress updates are currently supported on mutations. Support for progress directly on loads is possible,
but not yet implemented. The workaround for the moment to get progress for a load is to use <<MutationJoins,mutation joins>>
to return a value from a mutation:

```
(defmutation some-mutation [params]
  (remote [{:keys [ast state]}]
    (-> ast
      (m/with-progressive-updates `(progress {}))
      (m/returning state Thing))))
```

where `Thing` is some component that defines the query for the data being returned from the mutation.

In general progress updates are only really useful for larger requests, such as file uploads. Triggering
downloads to the user's machine should probably be done using tricks that force the item into the
normal browser download mechanisms (external to Fulcro).

File uploads also require that you augment the new client network middleware, since there is no
reliable way to encode an image of arbitrary size into a transaction.

== Request Middleware

The request will, by default, be sent through pre-written middleware `fulcro.client.network/wrap-fulcro-request`. This
middleware will convert the body to a json-encoded transit form and add content-type headers. If you specify request
middleware you will want to compose that middleware in or normal API requests won't work.

Additional middleware can do any number of things:

* Re-route requests to an alternate URI
* Change the content type and encode the body
* Short-circuit the result of the middleware stack

Middleware is just a function `(fn [handler] (fn [req] ...))`. The inner function can choose to modify the request
and pass it through the remaining `handler`, or just return a request as the final thing to process. This is
similar to Ring middleware on the server.

Fulcro will supply the middleware with a request that contains:

* `:body` - The EDN transaction to send (query or mutations).
* `:headers` - An empty map.
* `:url` - The default URL this remote talks to.
* `:method` - The HTTP verb as a keyword. All Fulcro requests default to `:post`.

Middleware should return a map with the same keys that is passed on to the next layer. It may
add any keys it wishes. The final result of the middleware stack will be used as follows:

* `:body` - The raw data that will be given to XhrIO send
* `:headers` - A clj map from string to string. It will be converted to a jsobj and given as the headers to the request.
* `:url` - The network target. Can be relative or a complete URL, assuming you have security set to allow you to talk to the given server.
* `:method` - Converted to an upper-case HTTP verb as a string.

=== File Uploads

Fulcro will soon include pre-written middleware to accomplish file upload encoding for you.

The basic scheme is as follows:

* Attach a `js/File` object to a mutation's parameters (typically as metadata to avoid various tool overhead)
   * Include a tempid in the parameters
* The mutation should using an altered network object that has custom middleware
   * The local side of the mutation puts the file information into app state with a tempid
* The remote's middleware encodes the headers/body into a proper multipart form upload, and
includes the tempid
* Progress reports are handled as usual. The parameters of the progress mutation should include the tempid so that
  progress can be written to the file's state.
* The remote uses normal Fulcro response middleware (which can decode tempid remappings)
* The server accepts the file, assigns it a real ID, and returns a transit response with tempid
  remapping to that real ID.

When complete, the UI has an ID for the uploaded file, and can interact with the server via that ID
(e.g. for generating file serving URLs for images, send delete mutations, etc.).

Something like this is close:

```
; params will automatically include progress data
(defmutation upload-progress [{:keys [id] :as params}]
  (action [{:keys [state]}]
    (swap! assoc-in [:file/by-id id] (net/progress% params))))

(defmutation upload-file [{:keys [id file]}]
  (action [{:keys [state]}]
     (swap! state assoc-in [:file/by-id id] {:db/id id ...}))
  (file-upload [{:keys ast}]
    (m/with-progressive-updates ast `(upload-progress {:id ~id})))

(defn wrap-file-upload []
  (fn [req]
    (let [mutation (some-> req :body prim/query->ast1)
          params   (:params mutation)
          id       (:id params)
          js-file  (some-> params :file meta :js-file)
          form (js/FormData.)]
      (.append form "file" js-file)
      (.append form "id" (util/transit-clj->str id))
      (asoc req :body form :headers {} :method :post))))

(def file-upload-middleware (wrap-file-upload))

; client creation
(fc/new-fulcro-client :networking {:remote (net/fulcro-http-remote {})
                                   :file-upload (net/fulcro-http-remote {:url "/file-uploads"
                                                                         :request-middleware file-upload-middleware})})

; an input triggering upload(s)
(let [onChange (fn [evt]
                 (let [js-file-list (.. evt -target -files)]
                   (prim/transact! this
                     (mapv (fn [file-idx]
                             (let [fid     (prim/tempid)
                                   js-file (with-meta {} {:js-file (.item js-file-list file-idx)})]
                               `(upload-file ~{:id fid :file js-file})))
                       (range (.-length js-file-list))))))]
  (dom/input #js {:multiple true :onChange onChange}))
```

The server for this would need middleware watching for file uploads at `/file-uploads`, that
returns a transit+json encoded map for the mutation:

```
{`upload-file {:tempids {file-temp-id newly-assigned-id}}}
```

== Response Middleware

The response will, by default, be sent through the pre-written middleware function `fulcro.client.network/wrap-fulcro-response`
which contains the logic to properly decode an API response (which is essentially just a transit decode). If you specify
response middleware you will want to compose that middleware in or normal API responses won't work.

Raw responses from the remote will include:

* `:body` - The data that will be given back to Fulcro as the response from the server
* `:transaction` - The transaction that body is a response to. If you modify this for queries you can manipulate the final merge.
* `:status-code` - The HTTP status code
* `:status-text` - The HTTP status text
* `:error` - An error code. Typically one of `:network-error`, `:http-error`, `:timeout`, etc.
* `:error-text` - A string describing the error
* `:outgoing-request` - The request that this is a response to.

The final response body and transaction combo will be given to Fulcro for merge. If you modify
the transaction be sure to use a query from components so that normalization is done properly.

Response middleware is allowed to rewrite an errant response to an OK one (by clearing the error fields and
setting :status-code to 200). This would allow you, for example, to merge
specific errors into state as you see fit instead of relying on Fulcro's built-in error handling model.

= The Client Network Layer (DEPRECATED)

== Adding Additional Remotes

When you create a client you can pass the `:networking` option. This is a map whose keys are remote "names" and whose values are objects that
implement the `FulcroNetworking` protocol. Each remote that you add will be usable
through the `:remote` parameter of loads, and that remote's name in mutations:

```
(def app (new-fulcro-client :networking {:custom-remote (map->MyNetworking {})}))

...

(load this :thing Things {:remote :custom-remote})

...

(defmutation something [params]
  (custom-remote [env] true))
```

Loads must be queued to a single remote at a time, but mutations can technically list as many as you'd like (though there
is no built-in coordination of them).

=== Optional Sequential Operation

When you create a networking component you can optionally implement the `NetworkBehavior` protocol
which has a single method `(serialize-requests? [this])`.
The default (without this protocol) is to serialize them, but if you implement this
protocol and return false from the method then Fulcro's plumbing will not manage request queuing at all and will just
call `send` any time there is anything in the queue.

=== Implementing Send

The send method of the `FulcroNetwork` protocol is given `[this edn done-callback error-callback]`. `this` is just
the instance of your network implementation. The `edn` is the raw Fulcro query/mutation that was issued. The two callback
functions are what you call when the request is complete. You must call one (and only one) of them exactly once
with the response (or error).

The error callback, if called, will trigger and fallbacks, will update the (optional) load markers for the
request with an error state.

The done callback, if called, expects to be given a response that matches the shape of the request. This is always
a map that contains the top-level keys that were in the query/mutation. Mutations are keyed by the symbol of the mutation.

So, a query like this `[:a]` should call done with a map like `{:a 1}`. A mutation like `[(f)]` should call
the done callback with something like `{'f 42}`. The only automatically-handled return value from mutations
are tempid remappings.

=== Merging State

Fulcro remembers the query that was used when calling `send`. Therefore it can auto-normalize the server's tree-like
response to a graph query. It is perfectly legal to alter this by passing a UI query to the `done-callback` as
an additional argument. Doing so will cause the back-end to use the *specified query* for normalization instead of
the original (remembered) outgoing query.

=== Network Progress Updates

The networking layer of Fulcro will, by default, place load markers at the target location for any data that is
scheduled to be loaded or is currently loading. It also updates a global loading marker. This gives you ample
opportunities to give the user feedback about network activity.

However, many applications have custom desires beyond showing a busy indicator in place of the data being loaded.

For example, one might like to show the progress of a file upload. Fulcro includes an additional protocol
to enable progress updates:

```
(defprotocol ProgressiveTransfer
  (updating-send [this edn done-callback error-callback update-callback] "Send EDN. The update-callback will merge the state
  given to it. The done-callback will merge the state given to it, and indicates completion. See
  `fulcro.client.ui.file-upload/FileUploadNetwork` for an example."))
```

If you implement this protocol (in addition to `FulcroNetwork`), then you will be given a callback that can be called
at any time to merge data into the app state:

```
(update-callback data query)
```

for example, say you're doing progress updates on a file upload represented in your app state by a `File` component:

```
; on network update event for file 1:
(let [ident (prim/get-ident File {:id 1})
      file  ...] ; file would be a map containing the data for a File
  (update-callback {ident file} {ident (prim/get-query File)}))
```

The `fulcro.ui.fule-upload` namespace contains networking and UI for exactly this scenario. You could also use this
sort of networking component to deal with things like incoming streaming data.

=== Interfacing with REST Servers

See the <<RESTAPI, REST API>> section of the Getting Started chapter for an example of working with REST.

= Websockets [[Websockets]]

Fulcro includes support for using https://github.com/ptaoussanis/sente[Sente] to set up websockets as a remote
for your applications. The support documented here is relatively new, and supercedes a prior version as of 2.2.0.

== Server Side

There are two protocols in `fulcro.websockets.protocols` on the server side:

```
(defprotocol WSNet
  (add-listener [this ^WSListener listener] "Add a `WSListen` listener")
  (remove-listener [this ^WSListener listener] "Remove a `WSListen` listener")
  (push [this cid verb edn] "Push from server"))

(defprotocol WSListener
  (client-added [this ws-net cid] "Listener for dealing with client added events.")
  (client-dropped [this ws-net cid] "listener for dealing with client dropped events."))
```

`WSNet` is implemented by the `Websockets` component.

`WSListener` is for you to implement. It allows for listening to client added and dropped (closed) actions. An example might look like this:

```
(ns app
  (:require
    [com.stuartsierra.component :as component]
    [fulcro.websockets.protocols :as wp :refer [WSListener WSNet add-listener remove-listener client-added client-dropped]]))

(defrecord ChannelListener [websockets]
  WSListener
  (client-dropped [this ws-net cid]
    (println "Client disconnected " cid))
  (client-added [this ws-net cid]
    (println "Client connected " cid))

  component/Lifecycle
  (start [component]
    (add-listener websockets component)
    component)
  (stop [component]
    (remove-listener websockets component)
    component))

(defn make-channel-listener []
  (component/using
    (map->ChannelListener {})
    [:websockets]))
```

These encompass the core interface that is usable from the server.

The following sections show how to set up a server.

=== Easy Server

If you're using the easy server you need only add two components, and then inject the websockets wherever you need
to do client push from:

```
(ns app
  (:require
    [fulcro.server :as server]
    [fulcro.websockets :as fw]
    [fulcro.easy-server :as easy])

(defn build-easy-server [path]
  (easy/make-fulcro-server
    :config-path path
    :components {:websockets       (fw/make-websockets (server/fulcro-parser))
                 :channel-listener (make-channel-listener)
                 :broadcaster      (make-broadcaster)      ; See below
                 :ws-adapter       (fw/make-easy-server-adapter)}))
```

If you need push access from the parser, simply inject the websockets component and call `push` on it.

NOTE: The parsing environment does *not* support parser injections of easy server. See <<WSComponent, server details>> below
for more information on how to customize your API parsing environment with web sockets and easy server.

=== Custom Server

A custom server is similarly simple. You'll have some kind of component system with a web server (http-kit is the
default sente adapter), middleware, etc.

The websockets component is the same, you just need to place it into your middleware like so:

```
(defrecord Middleware [ring-stack websockets]
  component/Lifecycle
  (start [this]
    (assoc this :ring-stack
                (-> (not-found-handler)
                  (fulcro.websockets/wrap-api websockets)
                  (wrap-keyword-params) ;required
                  (wrap-params) ; required
                  ...
                  (wrap-not-modified)
                  (wrap-gzip))))
  (stop [this]))

(defn make-middleware []
  (component/using (map->Middleware {})
    [:websockets]))
```

where your component system map includes the websockets component:

```
(defrecord WebServer [config middleware stop-fn]
  component/Lifecycle
  (start [this]
    (let [port (get-in config [:value :port] 0)
          [port stop-fn] (let [stop-fn (http-kit/run-server (:ring-stack middleware) {:port port})]
                           [(:local-port (meta stop-fn)) (fn [] (stop-fn :timeout 100))])
          uri  (format "http://localhost:%s/" port)]
      (println "Web server running at " uri)
      (assoc this :stop-fn stop-fn)))
  (stop [this]
    (when stop-fn
      (stop-fn))
    this))

(defn make-server []
  (component/using
    (map->WebServer {})
    [:middleware :config]))

(defn build-server
  [{:keys [config] :or {config "config/dev.edn"}}]
  (component/system-map
    :config (server/new-config config) ; from fulcro server
    :middleware (make-middleware) ; see above
    :websockets (fw/make-websockets (server/fulcro-parser))
    :channel-listener (make-channel-listener) ; see above
    :broadcaster (make-broadcaster) ; see below
    :web-server (make-server))) ; see above
```

=== The Websockets Component [WSComponent]

The component implements the `WSNet` protocol, so you can call `push` directly on it. It wraps Sente's operations and
internals, but quite a bit of those are easily accessible, and some of them are necessary for most features
you'd want to write.

You can pass the contruction method three arguments:

* `parser` - A fulcro parser (usually `(server/fulcro-parser)`)
* `adapter` - A sente HTTP adapter (See Sente docs). Defaults to http-kit.
* `sente-options` - A map of options that is passed directly to the sente websocket channel construction.

NOTE: If you supply a packer in the sente options you'll need to make sure tempids are supported (this is done by default, but if you override it, it is up to you.
The default user id mapping is to use the internally generated UUID of the client. Use sente's `:user-id-fn` option
to override this.

The web sockets component has a couple of useful fields that you can also access anywhere you inject it:

[Horizontal]
`parser`:: The Fulcro API parser you installed.
`connected-uids`:: The Sente connected IDs atom. This is a read-only atom of user IDs (which defaults to the client UUID). See Sente docs for how to customize this.

The web socket component is also responsible for running your API parser, and you may want custom things to
be in your parsing environment.

WARNING: Easy server's `:parser-injections` *will not work!*.

However, anything injected as a dependency of this component will be added to your parser environment (in addition to the parser itself).
Thus, if you'd like some other component (like a database) to be there, simply add something like this to do your component entry:

```
...
   :websockets (component/using (make-websockets (fulcro.server/fulcro-parser)) [:sql-database :sessions])
   :sql-database (some-db-component)
   :sessions (some-session-component)
...
```

and when the system starts it will inject those components in and make them part of the parsing `env`.

NOTE: It is a good idea to use namespaced keywords for your component identifiers to prevent data collisions.

Additionally, the parser environment will include:

[Horizontal]
`:websockets`:: The channel server component itself
`:push`::          A function that can send push messages to any connected client of this server. (just a shortcut to send-fn in websockets)
`:parser`::        The parser you supplied
`:sente-message`:: The raw sente event. This will include things like the client and user ID of the source message. See Sente documentation for complete details.

The most useful items in the sente message are:

[Horizontal]
`:client-id`::      The unique websocket client connection ID (typically a UUID)
`:connected-uids`:: The sente connected client ID list.
`:uid`::            The client's user ID (will be same as client ID unless you override it)
`:ring-req`:: The ring request of the websocket.

=== Push Notifications

You can send push notifications to clients by injecting the websockets in other components and using the
`push` method. Here's a sample component that broadcasts server time updates:

```
(defrecord Broadcaster [websockets ^Thread thread]
  component/Lifecycle
  (start [this]
    (let [t (new Thread (fn []
                          (Thread/sleep 1000)
                          (let [cids (some-> websockets :connected-uids deref :any)]
                            (doseq [cid cids]
                              (wp/push websockets cid :time-change {:time (Date.)})))
                          (recur)))]
      (.start t)
      (assoc this :thread t)))
  (stop [this] (.stop thread)))

(defn make-broadcaster []
  (component/using
    (map->Broadcaster {})
    [:websockets]))
```

The server `push` method takes a `topic` and an EDN `message`. It sends both to the client, and they're received
as a map with keys `:topic` and `:msg` for the message.

See the Sente documentation for information on connected UIDs.

== Client Side

Installing websockets on the client is equally trivial:

```
(fc/new-fulcro-client
   :networking {:remote (fw/make-websocket-networking "/chsk"
                :push-handler push-handler
                :state-callback state-callback
                :global-error-callback (fn [& args] (apply println "Network error " args)))})
```

The `push-handler` is a function that will receive server push notifications (as a map with `:topic` and `:msg` keys),
and `state-callback` is a function that will be told with the networking of the client is connected or not.

Usually you'll want to transact against your application on push and state changes, so if you save your app to
an atom you can easily write the callbacks to use it:

```
(defonce app (atom nil))

(defn push-handler [msg]
  (when-let [reconciler (some-> app deref :reconciler)]
    (prim/transact! reconciler `[(process-push {:message ~msg})])))

(defn state-callback
  [_ {:keys [open?] :as new-state}]
  (when-let [reconciler (some-> app deref :reconciler)]
    (prim/transact! reconciler `[(set-network-status {:up? ~open?})])))

(defn mount []
  (reset! app (fc/mount @app root/Root "app")))

(defn ^:export init []
  (reset! app (fc/new-fulcro-client
                ; replace the default remote with websockets
                :networking {:remote (fw/make-websocket-networking "/chsk"
                                       :push-handler push-handler
                                       :state-callback state-callback
                                       :global-error-callback (fn [& args]
                                                                (apply println "Network error " args)))}))
  (mount))
```

=== Network Errors

Normally a network error results in an immediate client error (triggering fallbacks, etc.).

If the `auto-retry?` option of `make-websocket-networking` on the client is set to true then it will detect
network disconnects and go into auto-reconnect and retry mode. This
means that you must ensure that your mutations are idempotent, as there is a small chance that a mutation could have
made it to the server, run, but not responded before the network problem. The retry support could therefore consider
it "failed" and run it again. On a flaky network with a slow server this could degrade into running
the mutation any number of times.

If you choose to use auto retry it is recommended that you block your UI when the networking is down. Technically (as long as you
don't need to read) you could allow the user to continue working and the pending remote mutations will all run
in sequence once the network returns. However, without more novel history management you might not be able to
respond to API errors in a way that makes sense to the user.

== Chat Demo

There is a full https://github.com/fulcrologic/websocket-demo[chat demo application] on github.

== Porting From Older Websockets

If you were using the older websockets support in Fulcro, then the following changes are necessary:

- Modify your server to set up websockets as shown in earlier sections.
- The `:cid` parameter in the *server* env was misnamed in the original support (it was really a user id, but the original support
defaulted the user id to the client id). The parameter is still there (but is undocumented), but it is now truly the client id, not the user id.
You should port to using the raw `sente-message` for this concern.
- The `:connected-cids` of the original had the same naming problem. The name has been corrected to `:connected-uids`.
- The client is simpler. Push notifications are *no longer* received by the built-in multimethod `push-received`.  If you
want that, then store your application in a top level atom (e.g. `app`) and use this as your new `push-method` parameter
when creating the networking: `(fn [m] (when @app (fulcro.websockets.networking/push-received @app m)))`.

= Internationalization

Fulcro combines together a few tools and libraries to give a consistent and easy-to-use method of internationalizing
your application. The approach includes the following features:

* A global setting for the *current* application locale.
* The ability to write UI strings in a default language/locale in the code. These are the defaults that are shown on
the UI if no translation is available.
* The ability to extract these UI strings for translation in POT files (GNU gettext-style)
** The translator can use tools like POEdit to generate translation files
* The ability to convert the translation files into Clojurescript
* The ability to code-split your locales so they can be dynamically loaded when the locale is changed (Clojurescript 1.9.905+ and Fulcro 1.0.0-beta9+).
* The ability to format messages (using Yahoo's formatJS library), including very configurable plural support

Fulcro leverages the GNU `xgettext` tool, and Yahoo's FormatJS library (which in turn leverages browser support
for locales) to do most of the heavy lifting.

The i18n support of Fulcro does *not* add overhead to your application if you do not use it.

== Polyfills

If you use the internationalization support of Fulcro then you must load 
Yahoo's FormatJS. Fulcro includes a version of this library so you can
just require it from at one of your namespaces:

```
(ns some-namespace
  (:require yahoo.intl-messageformat-with-locales))
```

You may also need additional polyfills (like https://github.com/andyearnshaw/Intl.js/[`Intl.js`]) to get full
internaltional API support on Safari or older browsers.

== Annotating Strings

Fulcro uses the real UI strings as internaltionalization keys. This has a number of advantages:

. You don't have to keep track of made-up keys
. If you're missing a translation, it is easy to fall back to the default language so at least *something* is on the UI
that is comprehensible.
. It makes generating the list of things to translate something we can script.
. The code itself remains easy to read and understand.

Plain strings need only be wrapped in the `tr` macro:

```
(ns boo
  (:require [fulcro.i18n :refer [tr]]))

...
(tr "This is a test")
...
```

By default (you have not created any translations) a call to `tr` will simply return the parameter unaltered.

The parameter to `tr` *must* be a literal string (or string extraction cannot work). There is a separate function
for dealing with variables.

== Translating Values in Variables

There are times when you have a fixed known set of strings that you need to choose from (e.g. for a drop-down). In this
case you need a way to format something that is in a variable. The `tr-unsafe` macro allows this. It is otherwise
identical to `tr`.

NOTE: The reason for the separate name and error checking is that string extraction cannot possibly figure out
the values that are passed to `tr-unsafe` in a variable, which means you will have to find those manually and
tell your translator to include translations for them, OR you could do a trick like this:

```
(defn unused-function []
  (tr "Option One")
  (tr "Option Two")
  (tr "Option Three"))

...

(tr-unsafe v) ; where v has "Option One" ...
```

The calls to `tr` are just there so that the  generated code includes the literal string that need translations so
that the extraction step can see them. If the code is made unreachable then advanced compilation will even remove them
in your production build (but the i18n build for extraction will leave them in).

== Resolving Ambiguity

It is quite common for a string to be ambiguous to the developer or translator. For example the abbreviation for 'male'
might be 'M' in English, but the letter itself doesn't provide enough information for a translator to know what they
are doing. A call to `trc` (translate with context) resolves this by including a context string as part of the
internal lookup key and as a comment to the translator:

```
(trc "Abbreviation for male" "M")
```

The translator will see this "contextual comment" when translating.

== Formatting

`trf` (translate with format) accepts a format string (see the Yahoo FormatJS library) and any additional arguments
that should be placed in the string. This function handles formatting of numbers, percentages, plurals, etc.

Any named parameter that you use in the format string must have a corresponding named parameter in the call (you
can also use a map for the parameters):

```
(trf "{a}, {b}, and {c}" :a 1 :b 2 :c 3) ; => 1, 2, and 3
; or
(trf "{a}, {b}, and {c}" {:a 1 :b 2 :c 3}) ; => 1, 2, and 3
```

If the input parameter is needs to be further localized you may include a variety of formatting types (which
are extensible):

```
(trf "N: {n, number} ({m, date, long})" :n 10229 :m (new js/Date))
```

See the formatJS documentation for further details.

== Changing the Locale

The locale of the current browser tab can be changed through the built-in mutation `fulcro.client.mutations/change-locale` with a `:lang`
parameter (which can use the ISO standard two-letter language with an optional country code, and can be
a string or keyword):

```
(prim/transact! reconciler '[(fulcro.client.mutations/change-locale {:lang :es})])
; or if you've aliased mutations to m:
(prim/transact! reconciler `[(m/change-locale {:lang :es})])
```

The rendering functions will search for a translation in that language and country, fall back to the language if
no country-specific entries exist, and will fall back to the default language (the one in the UI code) if no
translation is found at all.

== Manually Installing Translations (see automation below as well)

NOTE: This is *not* the recommended approach, but it allows you to understand the internals and
perhaps generate custom tools and process around it.

The format for translations is rather simple, so you can hand-code translations if you care to. The
format of a translation entry key is "context|msgkey". So, for example the key for a `(tr "Hi")`
is "|Hi" and the key for `(trc "male" "M")` is "male|M".

Installing a translation map can be done as:

```
(swap! fulcro.i18n/loaded-translations assoc "es" {"|This is a test" "Spanish for 'this is a test'"})
```

in other words there is a global atom that holds the currently-loaded translations as a map, keyed by locale. The
map entries are the above-mentioned translation entry keys and the desired translation.

NOTE: The internal translation map is keyed by the string version of the locale, not the keyword. You can
use either to change the locale, but the translation map is keyed by the string version.

=== A Small Demo

++++
<div class="example" id="basic-i18n"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.basic-i18n').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="basic-i18n source"]
----
include::src/book/book/basic_i18n.cljs[]
----

== How it Works

It is important to have a basic understanding of how this all works. When you call `tr`, it really just error
checks your input to ensure it is a literal string (that is why it is a macro), and calls an underlying function.
The underlying function looks in a translation map under the current locale key (a global dynamic variable) and
emits the value found. If no value is found, then it just returns the string it was passed.

When you change locales the entire UI must re-render. The mutation to change locales simply changes the global variable
that tracks locale and does a call to force a re-render of the root of your UI.

String extraction is done against compiled Javascript with whitespace optimizations. The optimizations cause it to become
a single file (but doesn't remove dead code). The GNU gettext `xgettext` program can read Javascript and extract the
strings! So, we don't have to maintain a separate utility!

The Gettext tool chain is leveraged for all of the external work (translator interactions).

=== Common Mistakes

I18n isn't magic: it's just key-based lookups in maps. Here are some mistakes that you might make that will cause
things to malfunction:

. Using `tr-unsafe` and forgetting to translate the values you pass to it
. Passing the output of a `tr` call to `tr`

Both of these sound obvious, but the first one is easy to forget and the second one is easy to accidentally do.

Here is an example:

```
; THIS IS WRONG!!! Do you see why?
(def options [(tr "A") (tr "B")])

(defn ui-dropdown [{:keys [value options]}]
  (dom/select {:value value}
    (map (fn [i] (dom/option {:value (tr-unsafe i)} (tr-unsafe i))) options)))

...
  (let [default-option (tr "A")
        current-selection (or v default-option)]
     (ui-dropdown {:value v :options options}))
```

There are a number of mistakes in this small example.

. The definition of options uses tr. If the locale is set, it causes options to contain *that* locale's values. They
won't update when the locale changes.
. A possibly *translated* value of the options are being passed through, and then be re-used as *keys* to `tr-unsafe`.
Lookups will fail.

The correct way to do translations in this kind of scenario is like this:

```
; create options that have a true data abstraction separate from the display value
(def options [{:key :a :value "A"} {:key :b :value "B"}])

(defn ui-dropdown [{:keys [value options]}]
  (dom/select {:value (:key value)}
    ; translations should *always* be done when an element *renders*, not on "data"
    (map (fn [i] (dom/option {:value (:key i)} (tr-unsafe (:value i)))) options)))

...
  (let [default-option (first options)
        current-selection (or v default-option)]
     (ui-dropdown {:value v :options options}))
```

The easiest rule to follow is this: Calls to translate values are a *rendering* concern. They should not be called
to generate *data* that you store somewhere.

== Using Tools to Generate Translation Files

=== Extracting Strings for Translation

String extraction is done via the following process:

* Install GNU gettext (e.g. with `brew`). Make sure `xgettext` and `msgmerge` are on the env PATH that your REPL will see. For example,
in IntelliJ `/usr/bin` or `/usr/local/bin` (it doesn't load your .profile).
* Add a cljs build to your project with `:whitespace` optimizations
* Build that CLJS build
* Start a CLJ REPL and `(require 'fulcro.gettext)`

The application is compiled using `:whitespace` optimization. This provides a single Javascript file. The GNU
utility `xgettext` can then be used to extract the strings.

```
xgettext --from-code=UTF-8 --debug -k -ktr:1 -ktrc:1c,2 -ktrf:1 -o messages.pot compiled.js
```

If you have existing translations, you'd then merge this POT file into them. If you needed to make a new locale, you'd
use the GNU `msginit` command.

Fulcro comes with a function to do both the extraction and merging from a REPL: `(fulcro.gettext { options })`.

```
$ lein run -m clojure.main
user=> (require 'fulcro.gettext)
user=> (fulcro.gettext/extract-strings {:js-path "i18n/i18n.js" :po "i18n"})
```

This should create an `i18n` folder containing a `messages.pot`. This is
your translation template. The `js-path` is the path to the whitespace-optimized js version of your app.
The `:po` option specifies your translation directory.

NOTE: This task will automatically merge the generated `.pot` file into any pre-existing `.po` files as a final step,
so updating translations will just involve sending a human translator the resulting locale-specific `.po` files.

=== Creating a new Locale

Use `msginit` from a command line:

```
$ cd i18n
$ lang=es
$ msginit --no-translator -l $lang --no-wrap -o ${lang}.po -i messages.pot
```

This will create a new `.po` file. Send this to your translator.

=== Translating Strings

Once you've extracted the strings to a POT file you may translate them as you would any other gettext app. We
recommend the GUI program POEdit. You should end up with a number of translations in files that you place
in files like `i18n/es.po`, where `es` is the locale of the translation.
Generally you'll check your `.po` files into source control in order to keep track of the translations you've already done,
since the overall process allows carrying over old translations to newly extracted files.

== Generating Clojure Versions of the Translations

A function is provided for you that can be run from the REPL:

```
(fulcro.gettext/deploy-translations {:src "src/main" :po "i18n" })
```

`src` is your target source folder, and `:po` is where
you keep your PO files. This step will generate one cljc file for each PO file. If you supply `:as-modules?` then
your translations will support being dynamically loaded by `cljs-loader`. See the <<DynamicLocale, dynamically loaded locale demo>> for
more information on modules.
Translations will be output to the `translations` namespace in namespaces that match the locale name.

=== Using the Generated Translation Code

If you are using static translations (that all get loaded at once), then your client startup should just require all
of the locales so they'll get loaded. That's it!

If you place each locale into a module in Clojurescript 1.9.0-905+ then you can use your locales as loadable modules. The
`change-locale` mutation will automatically trigger loads if needed.

== Update Translations

As your application evolves you'll need to update your translations.
Just repeat the `extract-strings` function. It will automatically call `msgmerge` on all
existing locales to both keep your old translations and put in the new ones. Then just
repeat the translation and deployment steps.

== Locales and Server-side Rendering

The UI will render whatever the current locale is set to. This is a global dynamic variable holding an atom that can
be set on the server. This makes server-side rendering a breeze:

```
(reset! fulcro.i18n/*current-locale* :es)
(dom/render-to-str (ui-root props))
```

= Dev Cards [[DevCards]]

Devcards is an external library by Bruce Hauman that is excellent for working up components,
active documentation, or even complete applications piece by piece. Fulcro comes with a macro
that makes embedding Fulcro Applications into a devcard trivial.

== The Project Setup

Simply include devcards in your dependencies:

```
[devcards "0.2.4"]
```

and follow the basic setup instructions from that project's documentation. Typically, a build
configuration like this when using Figwheel:

```
(defproject app "1.0.0"
  :cljsbuild {:builds
              [{:id           "cards"
                :figwheel     {:devcards true}
                :source-paths ["src/cards"]
                :compiler     {:main           app.cards-ui
                               :asset-path     "js/cards"
                               :devcards       true
                               :output-to      "resources/public/js/cards.js"
                               :output-dir     "resources/public/js/cards"}}]})
```

then run that build through figwheel.

== Developing Component UI

Developing simple components is done as described in the Devcard documentation. Fulcro encourages you to
use pure rendering, so that means it is quick and easy to make cards that display UI components in
all of their valid states. This is quite helpful when working out the data model and look of a component.
If you use component-local CSS this can be an extremely effective way to quickly build up
components for use in your application.

=== Visual Regression Testing

Developing components in cards allows you to also do a form of visual regression testing. The basic idea is
to render the valid UI states for components, then have an automated script snapshot each card into an
image that can be compared with later CI runs.

See https://medium.com/adstage-engineering/how-we-test-our-full-stack-clojure-app-b18d79ee9e00[AdStage's blog]
for a detailed example of this with the code necessary to make it work.

== Developing Active Screens

The `defcard-fulcro` macro can embed a Fulcro application in a card. It allows any client options
to be passed to the client, but generates the mount into the card internally. It looks like this:


```
(ns my-cards
  (:require
            [devcards.core :as dc :refer-macros [defcard defcard-doc]]
            [fulcro.client.cards :refer [defcard-fulcro]]))

(defcard-fulcro symbol-for-card
   AppRootUIComponent
   {}  ; initial state. Leave empty to use :initial-state from root component
   {:inspect-data false ; normal devcard options
    :fulcro { :started-callback (fn [app] ...)} ; fulcro client options
   })
```

=== Running Devcards Against a Real Server

Figwheel embeds the hot loading websocket code into the compiled Javascript. This means
that you can serve devcards *from your real application server* simply by making
sure the HTML and Javascript for it are accessible through your server.

This means that full-stack operations against your real application are trivial
from within cards.

=== Splitting Your Application

Hopefully you see that the ability to embed a full-stack Fulcro client inside
of a card is much more powerful than just embedding your *entire* application.

Remember, we have component *normalization*! The mutations and loads for any given part of
your application work independent of how your UI is nested. This means that you
can easily write your application in a way that allows you to factor it apart and embed just
portions into devcards for localized development and testing!

We think this can be quite revolutionary to development, since it allows you
to build up the application in completely dijoint steps and join them
together once they're ready!

```
(defsc ScreenOne [this props]
  {:ident (fn [] [:screens/by-id :screen1])}
  ...)

(defmutation do-screen-1-thing [params]
  (action [env]
    ; operations relative to ident of ScreenOne
    ...)

(defcard-fulcro screen-1
   ScreenOne
   {}
   {:fulcro {:started-callback
              (fn [app]
                 ; code to establish the context (preloads) that the real application would have done for this screen
                 )}})
```

Composition of the pieces can be as simple as dropping them into your UI router at the appropriate place!

== Using External CSS via IFrames [[IFrames]]

If you need to have the content of a devcard use external CSS, then you can use the `fulcro.client.elements/iframe`
to do so. This cool little tool creates an iframe, but then uses React to render into *from* the parent page. This
gives you the *isolation* of an iframe with the *convenience* of single-page reasoning!

Here's a quick function that can be used within a card to wrap UI that wants to use Bootstrap CSS:

```
(defn render-example [width height & children]
  (ele/ui-iframe {:frameBorder 0 :height height :width width}
    (apply dom/div #js {:key "example-frame-key"}
      (dom/link #js {:rel "stylesheet" :href "/css/bootstrap.min.css"})
      children)))
```

this function can then be used to put a pre-sized iframe into a component like so:

```
(defsc NavRoot [this props]
  { :query         [:boo]}
  (render-example "100%" "150px"
    (dom/div #js { :className "row" }
      (dom/div #js {:className "col-md-1"}
         ...))))
```

this can then be used within a devcard, keeping the external CSS from messing with
the card layout or other cards.

= Support Viewer

Fulcro automatically tracks the sequence of steps in the UI in history, including what transactions ran to move your
application from state to state. This enables you to do time travel for things like debugging and 
error handling, but also allows you to serialize the history and send it to your servers for debugging sessions against
real user interactions!

The viewer is already written for you, and is in the `fulcro.support-viewer` namespace. There are a few things you
have to do in order to make it work.

WARNING: You must be careful to follow the rule that "only data goes in the database". Things like anonymous functions
are not serializable, and therefore if you store them in app state you will break your ability to use history for
things like support viewer. See the documentation on https://github.com/cognitect/transit-format[Transit] for a
description of the default types that are serializable and
for some hints on how you can extend transit to support additional types.

== Sending a Support Request

There is a built-in mutation that can do this called `fulcro.client.mutations/send-history`. It can accept anything
as parameters, and will send the support request to `:remote`. All you have to do is run it via UI:

```
(transact! this `[(m/send-history {:support-id ~(prim/tempid)})])
```

== Storing the Support Request

Basically you just have to write something to handle the `fulcro.client.mutations/send-history` mutation, save the
data, and return a tempid remapping (optional, since the client itself won't care):

```
(server/defmutation fulcro.client.mutations/send-history [params]
  (action [env]
     ...save the history from params...
     ...send an email to a developer with the saved id?...))
```

== Using the Support Viewer

The support viewer is a simple UI that is pre-programmed in the `fulcro.support-viewer` namespace. When started, it
will issue a load in order to obtain the history you saved in the prior step. It will then run the application
(which you also have to point to) with that history in a DVR-style playback.

You can see how simple the
[client setup](https://github.com/fulcrologic/fulcro-todomvc/blob/master/src/main/fulcro_todomvc/support_viewer.cljs) is here, and
look at the defmutation for the `send-history` and query for `:support-request` in this file:
[Server API](https://github.com/fulcrologic/fulcro-todomvc/blob/master/src/main/fulcro_todomvc/api.clj)

== Compressible Transactions

The `compressible-transact!` function support compressing transactions that would be otherwise annoying to step through. It works
as follows:

1. Use `compressible-transact!` instead of `transact!`
2. If more than one adjacent transaction is marked compressible in history then only the *last* of them is kept.

The built-in mutations that set a value (e.g. m/set-value!) are meant to be used with user inputs and already mark their
transactions this way. This is quite useful when you don't want to pollute (or overflow) history with keystrokes that
are not interesting.

== Demo

See https://github.com/fulcrologic/fulcro-todomvc/tree/master/src/main/fulcro_todomvc[Fulcro TodoMVC] for an example.

= Code Splitting (modules)

Clojurescript 1.9.854+ has expanded support for code splitting (older versions do too, but require a bit more code). The
main things you need to do to accomplish code splitting are:

1. Make sure your main app doesn't accidentally refer to things in the module. Hard dependencies make it
impossible to split the code.
2. Define a mechanism whereby your loaded code can find and install itself into the application.

Since you're working with a data-driven application with components that have queries, this typically means that you're
going to need to have the newly loaded components somehow modify the main application's query to tie them in. Also,
since parents technically render children, you're going to need to have an extensible mechanism for that as well.

To demonstrate one technique we'll assume that what you load is a "section" of the application that can be routed to. The
main application knows to provide the link, but it does not yet have the rendering factory, class, or query.

== Dynamic Routing and Code Splitting

The `fulcro.client.routing` namespace includes a second kind of UIrouter that can be used with the routing tree: `DynamicRouter`.

A `DynamicRouter` uses a dynamic query to change routes instead of a union, and it can derive the details of the target
component at runtime, meaning that it can be used to route to screens that were not in the loaded application code base
at start-time.

Furthermore, the routing tree has been designed to trigger the proper dynamic module loads for your dynamically loaded
routes so that code splitting your application can be a fairly simple exercise. Here are the basic steps:

. Pick a keyword for the name of a given screen. Say `:main`
. Write the `defsc` for that screen, and design it so that the TYPE (first element) of the ident is the keyword from (1).
    ** The initial state must be defined, and it must have the name (1) under the key r/dynamic-route-key
    ** The bottom of the file that defines the target screen *must* include a `defmethod` that associates the keyword (1) with the component (2). This
      is how the dynamic router finds the initial state of the screen, and the query to route to.
    ** IMPORTANT: Your dynamically loaded screen *MUST* have a call to `(cljs.loader/set-loaded! KW)` at the bottom of the file (where KW is from (1)).
. Configure your cljs build to use modules. Place the screen from (2) into a module with the name from (1).
. Use a DynamicRouter for the router that will route to the screen (2). This means you won't have to explicitly refer to the class of the component.
    ** The Query that composes in the router must use the special `get-dynamic-router-query` to join in the DynamicRouter's query.
. Create your routing tree as usual. Remember that a routing tree is just routing instructions (keywords).

If you are routing through a DynamicRouter as part of your initial startup, then there are a few more steps. See Pre-loaded routes below.

Trigger routing via the `route-to` mutation. That's it! The module rooted at the screen will be automatically loaded
when needed.

The `defsc` and `defmethod` needed for step 2 look like this:

```
(prim/defsc Main [this {:keys [label]}]
  {:initial-state (fn [params] {r/dynamic-route-key :main :label "MAIN"})
   :ident (fn [] [:main :singleton])
   :query [r/dynamic-route-key :label]}
  (dom/div #js {:style #js {:backgroundColor "red"}}
        label))

(defmethod r/get-dynamic-router-target :main [k] Main)
(cljs.loader/set-loaded! :main)
```

=== Pre-loaded Routes

Screens used with DynamicRouter that are loaded at start-time are written identically to the dynamically loaded screen,
but you will have to make sure their state and multimethod are set up at load time. This can be done
via the mutation `r/install-route`. This mutation adds the screen's state *and* multimethod component dispatch.

The demo application includes two such pre-installed routes (`Login` and `NewUser`), and one dynamically loaded one (main).
The code called at application startup (via `:started-callback`) ensure the pre-loaded routes is:

```
(defn application-loaded! [{:keys [reconciler]}]
  ; Let the dynamic router know that two of the routes are already loaded.
  (prim/transact! reconciler `[(r/install-route {:target-kw :new-user :component ~NewUser})
                               (r/install-route {:target-kw :login :component ~Login})
                               (r/route-to {:handler :login})])
  (loader/set-loaded! :entry-point))

...
(new-fulcro-client Root :started-callback application-loaded!)
```

=== The Demo

Notice on initial load that the `[:main :singleton]` path in app state is not present. You could use the console to
verify that `cards.dynamic_ui_main.Main` is not present (via Javascript) either. Once you route to `Main`, both will be present. You should
see the network load of the code when you route as well. The `book` build configuration in `project.clj` has the module
definitions, and looks like this:

```
{:id           "book"
                :source-paths ["src/main" "src/book"]
                :compiler     {:output-dir     "resources/public/js/book"
                               :asset-path     "js/book"
                               :modules        {:entry-point {:output-to "resources/public/js/book/book.js"
                                                              :entries   #{book.main}}
                                                ; For the dynamic code splitting demo
                                                :main        {:output-to "resources/public/js/book/main-ui.js"
                                                              :entries   #{book.demos.dynamic-ui-main}}}}}
```

The HTML file to start this up must load the base CLJS module (`js/book/cljs_base.js`) and the entry point `book.js` file.
The other code will be in `main-ui.js` and will be loaded when you route to that screen.

The file `dynamic_ui_main.cljs` is the code that will be dynamically loaded. It looks like this:

[source,clojure]
----
include::src/book/book/demos/dynamic_ui_main.cljs[]
----

The main entry point code is in the code below the demo:

++++
<div class="example" id="dynamic-ui-routing"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.dynamic-ui-routing').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="dynamic-ui-routing source"]
----
include::src/book/book/demos/dynamic_ui_routing.cljs[]
----

== Code Splitting and Server-Side Rendering

WARNING: Server-side rendering with dynamically-loaded modules requires support for `r/route-to-impl!` on the server
to set the dynamic route in the app state that you want to render. At the time of this writing that function is not yet
capable of running in Clojure.

Splitting up your application affects server-side rendering as well. If you want to pre-render a page that is normally loaded as a
module then you must make sure it is loaded properly on the server. The basic steps are:

. Make sure the namespace of the dynamic screen is required so that the `defmethod` for `get-dynamic-router-target` has been installed.
. During the app state setup, use `r/route-to-impl!` to set the route on app state.
. Render the DOM to a string.

When the application loads on the client you'll have passed the generated app state, so the route will be correct from
a *data* standpoint, but you'll need your started callback to make sure the actual *code* gets loaded when it
detects a dynamic route (which you'll have to do by analyzing the app state or setting the current handler in
some easy-to-understand location. If you're using HTML5 history events then your URI will probably trigger the correct
dynamic route call which will result in the correct result.

= Hacking the Client Query Engine

Om Next pioneered the data-driven space, and Fulcro is based upon many of the original concepts defined there. One of those
was the client parser. Fulcro is implemeted interally with a client query parser that is identical to Om Next's. Fulcro
provides a default implementation of this parser, but allows you to hook into it to add your own code for interpreting
queries! Doing so allows you to interpret the
query of a component instead of pulling it from your database. This gives you an extreme amount of power, but at the
cost of some added complexity that is disconnected from your graph reasoning about the data graph itself.

This feature also allows you to leverage parameters on props and joins which are legal parts of the query syntax that
cannot be encoded in the database itself.

The mechansim is exactly as described for parsing on the server. The client-side notes are:

* The read is always called starting at root. If you want to handle something, you have to handle the path from root to
that item.

== Adding to `read-local`

TODO

== Demo – Writing a Pagination and Sort Routine

TODO

= Performance [[Performance]]

Fulcro and React behave in a very performant manner for most data-driven applications. There are ways, however,
in which you can negatively affect performance.

== Poor Query Performance

This is by far the most common source of performance issues. Evaluating the UI query is relatively fast, but *relative* is
the key word. The larger the query, the more work that has to be done to get the data for it. Remember that you compose all
component queries to the root. If you do this with *only* joins and props, then your root query will ask for *everything* that
your UI could ever show, on every frame! This will perform very badly as your application gets large.

The solution to this is to ensure that your query contains only the currently relevant things.
There are a number of possible solutions for this, but the two most common are to use union or dynamic queries.

The `fulcro.client.routing` namespace includes primitives for building UI routes using unions (the unions are written
for you). It has a number of features, including the ability to nicely integrate with HTML5 history events for full HTML5
routing in your application.

In the dynamic query approach you use `prim/set-query!` to actually change the query of a component at runtime in
response to user events.

It is also important to note that you need not normalize things that are really just big blobs of data that you don't
intend to mutate. An example of this is large reports where the data is read-only. You could write a big
nested bunch of components, normalize all of the parts, and write a query that joins it all back together; however,
that incurs a lot of overhead both in loading the data, and every time you render.

Instead, realize that a property query like `[:report-data]` can pull *any* kind of (serializable, if you want
support viewer support) value from the
application state. You can put a js/Date there. You can put a map there. Anything. Furthermore, this query is super-fast
since it just pulls that big blob of data from app state and adds it to the result tree. Structural sharing makes that
fast.

== Poor React Performance

In general Fulcro should be able to handle a pretty high frame-rate. In fact, the design is meant to facilitate
60FPS rendering. Remember, however, that there are a number of stages in rendering, and each of them has an overhead. Large
UIs can have negative performance impacts at both the query and DOM layers.

Since React does your rendering it is best to understand how to best optimize it using their suggestions and documentation. Note
that Fulcro already ensures that `shouldComponentUpdate` is defined to an optimal value that should prevent even a regen/diff of VDOM
when data hasn't changed.

Some general tips to start with in React are:

1. Make sure your components have a *stable* react key. If the key changes, React will ignore the diff and redo the DOM. This is *very* slow. So,
if you've generated keys using something like random numbers just to get warnings to go away, then you're asking for trouble.
2. You're generally better off changing classes than DOM structure. For example, having a `(when render? (dom/div ...))` will cause entire
sections to be inserted and removed from the DOM. Using a class is much more efficient: `(dom/div #js {:className (str "" (when-not render? " hidden"))} ...)`.
3. Large DOM. React is pretty good with eliminating unnecessary changes, but that is still no reason to try to render a table with 1000's of rows. Paginate.


= Testing

Fulcro has a companion library called Fulcro Spec. It is a BDD DSL that wraps Clojure(script) test, and provides you
with a number of helpful features:

* A browser-based UI that can
** Auto-refresh on code changes
** Focus in on the tests of concern (you can define what that means)
** Run client tests in any number of simultaneous browsers to detect browser differences
** Run server-side tests through the same browser-based UI
* A Mocking/expectation system
* Outline-based specifications
* All of the functions from `clojure.test` work inside of specifications (e.g. `is`, `are`, etc).
* It is easy to run specifications from CI systems. Try out the https://github.com/fulcrologic/fulcro-lein-template[Leiningen template]
  to get an application that is already set up to go.

== Specifications

A specification is just a helpful wrapper around `clojure.test/deftest`. It looks like this:

```
(specification "The thing you're testing"
   ...)
```

== Behaviors, Components, and Assertions

These macros assist you in organizing your specification. Behavior and component just add an outline
entry and increase nesting. The `assertions` macro can add descriptions for each assertion, and gives a nice
human-readable notation:

```
(specification "Math"
  (component "Addition"
    (assertions
      "Works with positive integers"
      (+ 1 1) => 2
      "Works with negative integers"
      (+ -2 -2) => -4)))
```

== Exceptions

It is common to want to test error handling code. The `assertions` macro supports checking for, and pattern-matching
against, exceptions:

```
...
   (assertions
      "Throws when arg is nil"
      (f nil) =throws=> (ExceptionInfo #"Regex match on message"))
```

== Functional Assertions

Often you don't need a data comparison as much as you need to run a predicate on the result of a function:

```
...
   (assertions
      "Returns odd numbers"
      (f) =fn=> odd?)
```

== Mocking and Spies

One of the most important features of sustainable testing is the ability to test things in isolation. Any kind of coupling
can result in cascading failures that make tests difficult to write/maintain/understand. Fulcro Spec has a mocking
system that is concise and allows you to do a number of advanced things. The basic syntax looks like this:

```
(defn f [v] ...)
(defn g [] (f 1) 33)

(specification "g"
  (let [real-f f] ; save f into a temporary binding
    (when-mocking
      (f arg) => (do ; rebinds `f` to this code
                   (real-f arg) ; spy! Call the real original f
                   (assertions
                     "calls f with 1"
                     arg => 1))

      (g))))
```

There's a lot going on here. The `when-mocking` macro looks for any number of arrow-separated triples (like `(f v) => 1`)
and re-binds the real function to an internally scripted one that captures the arguments and makes them available to the
code on the right-hand side of the triple (see `arg` above).

The form to the right of the `=>` is run instead of the original function, and it can make assertions on the args
or even invoke the original.

If you specify a mock and it isn't called, then the specification will fail. Thus, a check that `f` is actually called
is also implied by this test!

=== Specifying Call Count

It may be useful (or even necessary) to specify the number of times a function is called when mocking. The default is
"at least once". You can write a more complex scenario simply by adding a multiplier into the arrow!

```
(defn f [] 99)
(defn g [] (+ (f) (f))

(specification "g"
  (assertions
    "produces the sum of two calls to f (coupled to the real definition of f)"
    (g) => 198))
  (when-mocking
    (f arg) => 2

    (assertions
      "produces the sum of two calls to f (mocking returns same thing over and over)"
      (g) => 4))
  (when-mocking
    (f arg) =1x=> 2
    (f arg) =1x=> 4

    (assertions
      "produces the sum of two calls to f (called exactly twice is enforced, and different values returned)"
      (g) => 6)))
```

=== Checking Order

When call counts are specified they imply order, and that order is checked as well by the internals of mocking. For
example a `1x` mock of `f`, `g`, `f` will fail if `f` is called twice before `g`.

=== Limitations

Fulcro spec has some limitations that are inherent to the underlying programming language/VM.

. It cannot mock inline, protocols, or macros.
. You're always creating "partial mocks". Expanding a function will often invalidate the mocking around it.

== Visual Regression Testing [[VisualRegression]]

When you have immutable data, pure rendering, and devcards it isn't too hard to create an automated testing suite
that verifies your UI, without having to have ugly and hard-to-maintain browser drivers. The scheme is as follows:

* Treat your UI components as animations that have a specific list of valid "key frames"
** Each possible combination of input values results in a specific look
* Create a devcard that statically renders the component with that state
* Write a script that can drive a browser to jump from card to card, and screen shot the output
* Have a human look at them and approve their look
* Add the script to CI, and have it compare the "approved" images to the newly generated ones. If the image
comparison fails, your UI changed. Have a human check that specific item and approve the change.

See the section on <<DevCards, Dev Cards>> for more information.

= Logging

Fulcro's internal logging on the client and server are handled by a small set of logging functions. The
logging itself can be modified to use any logging system that you wish to integrate, or you could choose
to use the internal facility.

The internal facility is meant to be used for Fulcro and related libraries so that no external logging \
dependency is necessary.

You can plug in your own output function (which can format and send log messages however you wish).

The basic API is (assume cljc file):

```
(ns app
  (:require [fulcro.logging :as log]))

(log/set-level! :error) ; prevent any logging messages except :error and :fatal
(log/set-logger! (fn [source-location log-level & args] (apply println args))) ; change the function that outputs the messages

(log/fatal "PROBLEM!") ; log a fatal error.
(log/debug "Doing something." [1 2 3] #{1 2} 22 "Hello" (ex-info "error" {})) ; log a debug message with a bunch of data
```

WARNING: Fulcro includes a legacy namespace (`fulcro.client.logging`) that should not be used.

== Making Fulcro Log Through External Libraries

You can make this logging facility delegate to another via `set-logger!`. It's as simple as something like:

```
(ns startup
  (:require [taoensso.timbre :as timbre
             fulcro.logging :as log]))

(log/set-logger!
  (fn [{:keys [file line] :as location} level & args]
    (timbre/log! level :p [args] {:?ns-str file :?line line})))
```

Be sure you're using your loggers low-level logging function, and not the macros. The macros will typically try
to extract the location using compile-time info, and the compile-time info of your call to `set-logger!` is of
little use in your actual logs. The macros in Fulcro's internal logging will have already extract the relevant
information into the location argument.

== Eliding Logging Code

The `set-level!` function changes runtime behavior of logging statements in the code base; however, you may wish
to completely remove logging statements from your production code below certain levels like debug.

The logging library will remove logging statements from code if you specify the JVM argument `-Dfulcro.logging=<level>`,
where `<level>` is a level like `debug` or `error`. Logging *statements* below that level will not generate code
in the resulting compiled program.

Of course, if you've removed logging statements this way then `set-level!` cannot magically re-add them. Therefore
using `-Dfulcro.logging=error` and doing `(set-level! :debug)` at runtime is not going to suddenly re-add the debug
logging statements.

= Deploying to Heroku

As an example of sending a complete Fulcro application to the cloud we'll walk you through the steps
to put an application up on Heroku.

Here are the things you need to do:

- Set up server to pull the web port from the PORT environment variable (using EDN)
- Make sure `:min-lein-version` is in your project file
- Include a Procfile
- Use the clojure build pack (should be auto-detected)

== Setting PORT

Fulcro server's PORT can be configured from the environment as follows:

```
{ :port :env.edn/PORT }
```

place that in a file on your classpath, such as `src/config/prod.edn` (if `src` is your base source code directory). You
could also use `resources` (which is technically more correct).

== Minimum lein version

Heroku (at the time of this writing) defaults to lein version 1.7.x. This is almost certainly *not* what you want.

== Include a Profile

If you're building an uberjar from one of our template projects, using Fulcro Server, and you've set up a config
file as described above, then the following Procfile should work for you:

```
web: java $JVM_OPTS -Dconfig=config/prod.edn -jar target/uberjar-name.jar\n
```

== Use a Clojure Build Pack

Just follow the directions when adding a project. We've only used the git deployment method. Make sure you don't have
a generated `pom.xml` as well as a `project.clj` file, or your project might get built using Maven instead of Lein.

== Sample Project

The http://github.com/fulcrologic/fulcro-template[fulcro-template] is pre-configured for easy deployment to Heroku.

= Converting HTML to Fulcro

This chapter has a simple little live application that can convert valid HTML into the Clojure(script) you'd use
within a Fulcro component. Note that stray whitespace will be converted to (harmless) things like `" \n"` that can be easily
removed, and the output indentation isn't ideal; Still, it turns the task into one of simple formatting:

++++
<div class="example" id="html-converter"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.html-converter').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="html-converter source"]
----
include::src/book/book/html_converter.cljs[]
----

= Bootstrap (CSS Wrappers)

Fulcro include a set of CLJC wrappers for a good portion of Bootstrap 3. These should be considered of alpha quality,
but they are used in many demos and can be useful in getting started quickly. The primary improvements that are
needed would be easy contributions, and if you find them useful you can send a pull request to fix issues or
extend them.

NOTE: You must include version 3 of Bootstrap's CSS (and optionally theme), but *not* Javascript, in your HTML file.

The CSS affects many DOM elements, which means you'll see examples that use DOM functions, which
in turn require a JavaScript object as the first argument (for performance). The helper functions from the
`bootstrap` namespace need to modify the incoming arguments, so the first argument (if it takes DOM props) is
a cljs map instead.

```
; render a regular DOM element:
(dom/div #js { :className "a" })
; render a bootstrap element via one of these functions
(b/button { :className "b"} "Button label")
```

The javascript object verion with regular DOM elements avoid data conversion overhead at runtime. The bootstrap functions
in this library need to augment and manipulate the passed parameters, so they use cljs maps instead.

This documentation covers the passive elements that largely add in proper structure and classnames for bootstrap rendering. The
other sections on bootstrap cover active elements.

Fulcro also includes `fulcro.ui.html-entities` (which we alias to `ent` here). These just give symbol names
to HTML entities (e.g. `&times;` is `ent/times`) so they are easier to use in React.

The examples in this section all render within iframes to prevent the bootstrap CSS from interfering with
the book itself. Some of them intentionally go beyond their normal borders to show how they work on larger screens (even
though your screen might not be that large).

== Grids

The four iframes below represent the widths of a large, medium, small, and xsmall screen. The content being
rendered is:

```
(b/container-fluid {}
  (b/row {}
    (b/col {:xs 12 :md 8} "xs 12 md 8") (b/col {:xs 6 :md 4} "xs 6 md 4"))
  (b/row {}
    (b/col {:xs 6 :md 4} "xs 6 md 4")
    (b/col {:xs 6 :md 4} "xs 6 md 4")
    (b/col {:xs 6 :md 4} "xs 6 md 4"))
  (b/row {} (b/col {:xs 6 } "xs 6") (b/col {:xs 6 } "xs 6")))
```

See the Bootstrap documetation for more details.

++++
<div class="example" id="bootstrap-grid"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-grid').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-grid source"]
----
include::src/book/book/bootstrap/grid.cljs[]
----

== Typography

Various elements support modified typography.

++++
<div class="example" id="bootstrap-typography"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-typography').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-typography source"]
----
include::src/book/book/bootstrap/typography.cljs[]
----

== Formatting Code

++++
<div class="example" id="bootstrap-code"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-code').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-code source"]
----
include::src/book/book/bootstrap/code.cljs[]
----

== Tables

++++
<div class="example" id="bootstrap-tables"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-tables').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-tables source"]
----
include::src/book/book/bootstrap/tables.cljs[]
----

== Alerts

++++
<div class="example" id="bootstrap-alerts"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-alerts').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-alerts source"]
----
include::src/book/book/bootstrap/alerts.cljs[]
----

== Badges

An inline badge that can be placed on other elements.

++++
<div class="example" id="bootstrap-badges"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-badges').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-badges source"]
----
include::src/book/book/bootstrap/badges.cljs[]
----

== Breadcrumbs

++++
<div class="example" id="bootstrap-breadcrumbs"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-breadcrumbs').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-breadcrumbs source"]
----
include::src/book/book/bootstrap/breadcrumbs.cljs[]
----

== Buttons

++++
<div class="example" id="bootstrap-buttons"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-buttons').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-buttons source"]
----
include::src/book/book/bootstrap/buttons.cljs[]
----

== Button Groups

++++
<div class="example" id="bootstrap-button-groups"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-button-groups').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-button-groups source"]
----
include::src/book/book/bootstrap/button_groups.cljs[]
----

== Form Fields

++++
<div class="example" id="bootstrap-form-fields"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-form-fields').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-form-fields source"]
----
include::src/book/book/bootstrap/form_fields.cljs[]
----

== Icons

Glyphicon support through keyword names and the `b/glyphicon` function.
E.g. `(b/glyphicon {} :arrow-left)`.

++++
<div class="example" id="bootstrap-icons"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-icons').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-icons source"]
----
include::src/book/book/bootstrap/icons.cljs[]
----

== Images

++++
<div class="example" id="bootstrap-images"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-images').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-images source"]
----
include::src/book/book/bootstrap/images.cljs[]
----

== Jumbotron

A container that offsets the content. Note, this will not work if it isn't in the grid:

++++
<div class="example" id="bootstrap-jumbotron"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-jumbotron').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-jumbotron source"]
----
include::src/book/book/bootstrap/jumbotron.cljs[]
----

== Pagination

++++
<div class="example" id="bootstrap-pagination"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-pagination').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-pagination source"]
----
include::src/book/book/bootstrap/pagination.cljs[]
----

== Panels

Panels use sub-elements to identify portions of the panel:

```
  (b/panel nil
    (b/panel-heading nil "Heading without title")
    (b/panel-body nil "This is the body of the panel")
    (b/panel-footer nil "The footer"))
  (b/panel {:kind :danger}
    (b/panel-heading nil
      (b/panel-title nil "Panel Title of :danger panel"))
    (b/panel-body nil "This is the body of the panel"))))
```

NOTE: Tables can replace or follow the `panel-body`. They need not be placed within it.

```
(b/panel nil
  (b/panel-heading nil
    (b/panel-title nil "Panel with a table and no panel-body"))
  (b/table nil
    (dom/tbody nil
      (dom/tr  nil
        (dom/th nil "Name")
        (dom/th nil "Address")
        (dom/th nil "Phone"))
      (dom/tr  nil
        (dom/td nil "Sally")
        (dom/td nil "555 N Nowhere")
        (dom/td nil "555-1212")))))
```

++++
<div class="example" id="bootstrap-panels"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-panels').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-panels source"]
----
include::src/book/book/bootstrap/panels.cljs[]
----

== Popovers

Popovers are real React components (instead of just wrapper functions), thus the factory has a ui prefix.
They do not have state, so they are fed their orientation and current state via props. You can include a
single child (tree), and the popover will use that as its boundary for locating itself.

(Only the Toggle All is hooked up in this example)

++++
<div class="example" id="bootstrap-popover"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-popover').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-popover source"]
----
include::src/book/book/bootstrap/popover.cljs[]
----

== Progress Bars

++++
<div class="example" id="bootstrap-progress"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-progress').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-progress source"]
----
include::src/book/book/bootstrap/progress.cljs[]
----

== Thumbnails

++++
<div class="example" id="bootstrap-thumbnails"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-thumbnails').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-thumbnails source"]
----
include::src/book/book/bootstrap/thumbnails.cljs[]
----

== Wells

++++
<div class="example" id="bootstrap-well"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-well').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-well source"]
----
include::src/book/book/bootstrap/well.cljs[]
----

= Bootstrap (Components)

This chapter covers Fulcro implementations of some of the Bootstrap components. These have been re-implemented in
CLJC to support server-side rendering and easy inclusion in your Fulcro applications without having to depend on
external Javascript.

These components therefore define mutations that manipulate them, and must be composed in with queries and
such.

== Collapse

The collapse item is a stateful component that takes children. The children will be hidden/shown based on the
state of the collapse wrapper.

The built-in mutation `(b/toggle-collapse {:id ID-OF-COLLAPSE})` can be used to toggle a specific item, and
the mutation `(b/set-collapse {:id ID :open BOOLEAN})` can be used to set the specific state.

NOTE: Both of these mutations automatically do nothing if an animation is in progress.

An example with source is below:

++++
<div class="example" id="bootstrap-collapse"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-collapse').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-collapse source"]
----
include::src/book/book/bootstrap/components/collapse.cljs[]
----

== Accordian (group of collapse)

There is no default coordination among collapse items, but they have a well-known table in app state. Therefore it
is easy to provide a way to group them together into an accordian. The behavior is implemented with a single
additional mutation:

```
(b/toggle-collapse-group-item {:item-id ID :all-item-ids IDs)
```

This mutation toggles the specific item (by ID), and it understands the grouping because you also pass it
the IDs of all of the other items in the group. There's no real need for them to be any
more tightly coupled.

For example, say we choose to use a `panel-group` to lay out each item. Each item can be a
panel, so we define an extra `accordian-section` function (not part of the library) and
create the instances in app state and map over them with our helper.

Note that you can use the mutations defined for single Collapse elements (of course), but that will cause
strangeness in your accordian (e.g. two sections open at once). The `toggle-collapse-group-item` *does*
this correctly by closing all open sections except the one being opened.

++++
<div class="example" id="bootstrap-accordian"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-accordian').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-accordian source"]
----
include::src/book/book/bootstrap/components/accordian.cljs[]
----

== Dropdowns

Active dropdowns are components with state. They must be initialized in app state, and have simple
data constructor functions you can use for this purpose:

* `dropdown` : a function that creates a dropdown's state
* `dropdown-item` : a function that creates an items with a label
* `ui-dropdown` : renders the dropdown. It requires the dropdown's properties, and allows optional named arguments
** `:onSelect` : The callback for selection which receives an element's ID.
** `:kind` : Identical to the `button` `:kind` attribute.

All labels are run through `tr-unsafe`, so if a translation for the current locale exists it will be used.

The following mutations are are available:

Close (or open) a specific dropdown by ID:

```
(prim/transact! component `[(b/set-dropdown-open {:id :dropdown :open? false})]`)
```

Close dropdowns (globally). Useful for capturing clicks a the root to close dropdowns when the user clicks outside of
an open dropdown.

```
(prim/transact! component `[(b/close-all-dropdowns {})])
```

You can set highlighting on an item in the menu (to mark it as active) with:

```
(prim/transact! component `[(b/set-dropdown-item-active {:id :item-id :active? true})])
```

++++
<div class="example" id="bootstrap-dropdowns"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-dropdowns').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-dropdowns source"]
----
include::src/book/book/bootstrap/components/dropdowns.cljs[]
----

== Modals

Modals are stateful Fulcro components with app state and queries. They can, of course, be mixed with other
app state.

The basic usage is to define your modal in the root, with the various things it should render. If you need
more than one kind of modal, then you can use a UI router and embed them all in it, then embed the router
at the root.

The following demonstrates all of these techniques:

++++
<div class="example" id="bootstrap-modals"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-modals').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-modals source"]
----
include::src/book/book/bootstrap/components/modals.cljs[]
----

== Modal Variations

This section just demonstrates some non-active modals so you can see some of the different layout sizes and options.

NOTE: The iframe for some examples are forced larger than the container because large modals adapt down in size based on
available space.

++++
<div class="example" id="bootstrap-modal-variations"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-modal-variations').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-modal-variations source"]
----
include::src/book/book/bootstrap/components/modal_variations.cljs[]
----

== Nav

These are stateful components that act as tabs. A nav contains one or more `nav-link` or `dropdown`. It reports selections
through an `onSelect` callback (which will send the ID of the item selected).

The typical way to embed a nav is using the `nav` constructor in your initial state, adding `Nav`'s query to the query at
the same key, and rendering it with `ui-nav`.

In the demo below we define this mutation to call from the onSelect callback to display where the nav is currently
pointing:

```clojure
(m/defmutation nav-to [{:keys [page]}]
  (action [{:keys [state]}] (swap! state assoc :current-page page)))
```

Then the main component can display nav and also show the current 'page'.

++++
<div class="example" id="bootstrap-nav"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-nav').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-nav source"]
----
include::src/book/book/bootstrap/components/nav.cljs[]
----

== Nav and UI Routing

The Nav component does nothing more than manage the UI of the tabs. You are still responsible for rendering the
content of the application. You will likely wish to use the Fulcro routing system so that your UI performance stays
high, and HTML5 routing becomes simpler. To this end, you will likely want to combine Nav with routing.

=== Defining the UI Routing

First, we'll need some screens to show. We'll just make some placeholders. They'll need to know (and query) their
screen type:

Then we'll need to define an ident that follows the `[type id]` semantic. Since there isn't really an ID, we'll just
use the keyword `:singleton` for the ID.

```clojure
(ident [this props] [(:screen-type props) :singleton])
```

but this ident function goes with the UI router, which looks like this:

```clojure
(defrouter MainRouter :main-router
  (ident [this props] [(:screen-type props) :singleton])
  :home HomeScreen
  :other OtherScreen)
```

=== Composing the UI Elements

Composing the UI requires that you query for the correct router and nav subelements, compose in their initial state,
and render them both. Something like this will work:

=== Changing the Visible Screen

This is now a component that can display whichever screen is currently active. The `fulcro.client.routing` namespace
includes a helper functions called `set-route` that can be composed into a mutation to change the current screen of
a router:

```
(m/defmutation select-tab
  "Select the given tab"
  [{:keys [tab]}]
  (action [{:keys [state]}]
    (swap! state routing/set-route :main-router [tab :singleton])))
```

Of course, we could also be using the routing tree mechanisms, which would be similar (though you'd use the
`update-routing-links` helper then).

=== Ensuring the Correct Tab is Active

If you're using something like HTML5 routing, then you'll not only need to make sure the current screen is showing,
but you'll need to make sure the `Nav` knows which tab to show as active. The bootstrap namespace includes
an mutation for setting the current nav link `set-active-nav-link`, and a helper function `set-active-nav-link*`
that can be composed into mutations.

If you're careful to make the IDs of the tabs and screens the same, then you'll be able to ensure lock-step
updates with that same mutation:

```clojure
(m/defmutation select-tab
  "Select the given tab"
  [{:keys [tab]}]
  (action [{:keys [state]}]
    (swap! state (fn [s]
                   (-> s
                     (routing/set-route :main-router [tab :singleton])
                     (b/set-active-nav-link* :main-nav tab))))))
```

The overall technique works the same with routing trees, but in that case you'll need to know what nav links need
to be updated for a given page and compose those instructions with the `routing/update-routing-links` helper.

++++
<div class="example" id="bootstrap-nav-routing"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.bootstrap-nav-routing').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="bootstrap-nav-routing source"]
----
include::src/book/book/bootstrap/components/nav_routing.cljs[]
----

= Demos

This chapter includes some additional running demos with source that will give you insight on how to approach various problems. Remember
that the server latency can be set using the controls in the upper-right corner in the live HTML version, so you can
more easily watch state changes during server interactions.

== Autocomplete

A fairly common desire in user interfaces is to try to help the user complete an input by querying the server
or possible completions. Like many of the demos, the UI for this example is intentionally very bare-bones
so that we can primarily concentrate on the data-flow that you'll want to use to achieve the effect.

Typically you will want to trigger autocomplete on a time interval (e.g. using `goog.functions/debounce`)
or after some number of characters have been entered into the field. We're going to implement it in the
following way:

* The autocomplete query will trigger when the input has at least 2 characters of input.
* The server will be asked for 10 suggestions, and will update on a debounced interval.
* The autocomplete suggestion list will clear if length goes below 2
* The user must use the mouse to select the desired completion (we're not handling keyboard events)

=== Basic Operation

The basic idea is as follows:

* Make a component that has isolated state, so you can have more than one
* Decide when to trigger the server query
* Use load, but target it for a place that is not on the UI
** Allows the UI to continue displaying old list while new load is in progress
** Use a post-mutation to move the finished load into place

=== The Server Query

For our server we have a simple list of all of the airports in the world that have 3-letter codes. Our
server just grabs 10 that match your search string:

```
(defn airport-search [s]
  (->> airports
       (filter (fn [i] (str/includes? (str/lower-case i) (str/lower-case s))))
       (take 10)
       vec))

(defquery-root :autocomplete/airports
  (value [env {:keys [search]}] (airport-search search)))
```

=== The UI and Post Mutation

We create a helper function so we don't have to manually generate the ident for autocomplete wherever we need it:

```
(defn autocomplete-ident
  "Returns the ident for an autocomplete control. Can be passed a map of props, or a raw ID."
  [id-or-props]
  (if (map? id-or-props)
    [:autocomplete/by-id (:db/id id-or-props)]
    [:autocomplete/by-id id-or-props]))
```

We use Google Closure's debounce to generate a function that will not bash the server too hard. Load's will run at most
once every 500ms. Notice that the server query itself is for airport suggestions, and we use the `:target` option
to place the results in our autocomplete's field:

```
(def get-suggestions
  "A debounced function that will trigger a load of the server suggestions into a temporary locations and fire
   a post mutation when that is complete to move them into the main UI view."
  (letfn [(load-suggestions [component new-value id]
            (df/load component :autocomplete/airports nil
              {:params               {:search new-value}
               :marker               false
               :post-mutation        `populate-loaded-suggestions
               :post-mutation-params {:id id}
               :target               (conj (autocomplete-ident id) :autocomplete/loaded-suggestions)}))]
    (gf/debounce load-suggestions 500)))
```

Notice when we trigger the load it goes into the auto-complete widget's `:autocomplete/loaded-suggestions` field.
The UI renders the `:autocomplete/suggestions`. We do this so we can continue filtering the list as they type
independently of the load, but at the end of the load we need to update the suggestions. We do this by running a post
mutation (see the demo source).

The running demo (with source) is below:

++++
<div class="example" id="autocomplete-demo"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.autocomplete-demo').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="autocomplete-demo source"]
----
include::src/book/book/demos/autocomplete.cljs[]
----

== Using Unions to Switch out UI Elements

This demo is similar to the example in the section on <<Unions,unions>>. In fact, the two could be combined to make
this one polymorphic as well, but the primary interest in this demo is to show swapping between an editor
and a list (or table).

This example uses <<Forms,forms support>> with a custom submit and cancel mutation.
It is instructive to see how entities could be loaded (simulated in the started-callback) as pristine entities
and augmented with form support through mutations that have a nice clear meaning (to both front and back-end).

See the comments on the source for more details.

++++
<div class="example" id="union-example-2"></div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.union-example-2').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="union-example-2 source"]
----
include::src/book/book/queries/union_example_2.cljs[]
----

== Cascading Dropdowns

A common UI desire is to have dropdowns that cascade. I.e. a dropdown populates in response to a selection in
an earlier dropdown, like Make/Model for cars. This can be done quite easily.

The basic implementation is as follows:

. Define dropdowns that can display the items
. Don't initialize the extra ones with items
. When the first one is given a selection, load the next one

A couple of simple implementation details are needed:

. We're using bootstrap dropdowns, and we need to know where they normalize their data. Looking at the data inspector
for the card makes this easy to see. For example, we can see that items are stored in the
`:bootstrap.dropdown/by-id` table, in the `:fulcro.ui.bootstrap3/items` column.
. The IDs of the dropdowns (which we generate)

On the server, we define the query handler as follows (remember you can affect the server latency with the server
controls to watch things happen):

```
(defquery-root :models
  (value [env {:keys [make]}]
    (case make
      :ford [(bs/dropdown-item :escort "Escort")
             (bs/dropdown-item :F-150 "F-150")]
      :honda [(bs/dropdown-item :civic "Civic")
              (bs/dropdown-item :accort "Accord")])))
```

and we define a mutation for showing a "Loading..." item in the dropdown that is loading as:

```
(defmutation show-list-loading
  "Change the items of the dropdown with the given ID to a single item that indicates Loading..."
  [{:keys [id]}]
  (action [{:keys [state]}]
    (swap! state assoc-in
      [:bootstrap.dropdown/by-id id :fulcro.ui.bootstrap3/items]
      [(assoc (bs/dropdown-item :loading "Loading...") :fulcro.ui.bootstrap3/disabled? true)])))
```

The main action is in the `onSelect` of the first dropdown, which just issues the transact to set the loading
visualization, followed by the remote load.

++++
<div class="example" id="cascading-dropdowns"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.cascading-dropdowns').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="cascading-dropdowns source"]
----
include::src/book/book/demos/cascading_dropdowns.cljs[]
----

== Colocated CSS

The https://github.com/fulcrologic/fulcro-css[Fulcro CSS] library adds extensions that make it easy to co-locate and compose localized
component CSS with your UI! This leads to all sorts of wonderful and interesting
results:

* Your CSS is name-localized, so your component's CSS is effectively private
* You don't have to go find the CSS file to include it in your application. It's already in the code.
* Since it's code, you can use data manipualtion, variables, and more to create your CSS. It
is the ultimate in code reuse and generality.
* The composition facilities prevent duplication.
* It becomes much easier to allow themed components with additional tool chains! Variables can be
supplied that can simply be modified via code before CSS injection.
* Google Closure's minification can be applied to reduce the size of the resulting files during your
normal compilation!
* Server-side rendering can pre-inject CSS rules into the server-side rendered page! No more waiting for
your CSS to load for the UI to look right!

Basically components define local rules via [garden](https://github.com/noprompt/garden) syntax, and Fulcro
will localize the class names using the namespace and component name.
Parent components compose in the children via `include-children` for the components that it uses.
Just like initial state and queries. This causes all used components to compose to the root. Actually,
you can stop at any time and extract CSS from any component, so you need not compose it to the root if
you don't want/need to.

Two support functions then give you easy access to the generated CSS and generated names.

To access the localized names for a component, just use:

```
(let [{:keys [simple-name]} (css/get-classnames Child)] ...)
```

This function returns a map from the *simple* name you used in defining a rule with the value
of the *localized* name that is in the CSS. This allows you to be unaware of the localization rules!

At some point in your code (e.g. startup) you will want to inject the CSS into the DOM. Typically, with:

```
(css/upsert-css "dom-id" Component)
```

Any number of those can be done, at whatever ID you care to invent (it will replace or insert a style element
as necessary).

The card below upserts the co-located CSS from the code itself, but these code rules  also
bases the color on the value in an atom (think theme color). At any time you can change your various
embedded data on colocated CSS and re-upsert the generated result!

The complete commented code and example is below. See the library documentation for more details.

++++
<div class="example" id="component-localized-css"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.component-localized-css').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="component-localized-css source"]
----
include::src/book/book/demos/component_localized_css.cljs[]
----

== Dynamically Loaded Locales [[DynamicLocale]]

NOTE: Figwheel support for code splitting started in 0.5.15. There are a few tweaks to get it to work with earlier versions.

The i18n support allows for auto-generated locale code that can be configured into modules. This allows you to
dynamically load locale-specific strings for your UI at runtime.

The book's build is configured for this, and the following steps were required:

. Code something that uses i18n.
. Build the code with `:whitespace` optimizations and WITHOUT MODULES (so all code ends up in the generated js).
. Use the normal extraction `fulcro.gettext/extract-strings` and translation steps.
. Deploy the CLJC translation files to your source using: `(fulcro.gettext/deploy-translations {:src "src/demos" :po "resources/demos/i18n" :as-modules? true})`
. Add the languages as modules to the project's build (see the `book` build in Fulcro's `project.clj`).

The build (at the time of this writing) look like this:

```
{:id           "book"
 :source-paths ["src/main" "src/book"]
 :compiler     {:output-dir     "resources/public/js/book"
                :asset-path     "js/book"
                :modules        {:entry-point {:output-to "resources/public/js/book/book.js"
                                               :entries   #{book.main}}
                                 ; For the dynamic i18n loading demo
                                 :de          {:output-to "resources/public/js/book/de.js"
                                               :entries   #{translations.de}}
                                 :es-MX       {:output-to "resources/public/js/book/es-MX.js"
                                               :entries   #{translations.es-MX}}
                                 ; For the dynamic code splitting demo
                                 :main        {:output-to "resources/public/js/book/main-ui.js"
                                               :entries   #{book.demos.dynamic-ui-main}}}}}
```

As with the other code splitting demos you must also load `cljs_base.js` in your HTML, since the common code is
placed in it.

On startup of any module program you must tell the loader which modules have been pre-loaded by
their ID:

```
(new-fulcro-client Root :started-callback (fn [] (cljs.loader/set-loaded! :entry-point)))
```

The demo below is the live example that uses modules for the German and Spanish translations (open your
browser's network tab to see them load)

++++
<div class="example" id="dynamic-i18n"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.dynamic-i18n').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="dynamic-i18n source"]
----
include::src/book/book/demos/dynamic_i18n.cljs[]
----

[source,clojure,role="dynamic-i18n source"]
----
include::src/book/translations/de.cljc[]
----

[source,clojure,role="dynamic-i18n source"]
----
include::src/book/translations/es_MX.cljc[]
----

== Loading due to a UI Event

Tabbed interfaces typically use a UI Router (which can be further integrated into HTML5 routing as a routing tree). See
https://youtu.be/j-_itpXEo6w?list=PLVi9lDx-4C_T_gsmBQ_2gztvk6h_Usw6R[this YouTube video] for more details.

This example not only shows the basic construction of an interface that allows content (and query) to be switched, it
also demonstrates how one goes about triggering loads of data that some screen might need.

If you look at the source for the root component you'll see two buttons with transactions on their click handlers.

```
(defsc Root [this {:keys [ui/react-key current-tab] :as props}]
  ; Construction MUST compose to root, just like the query. The resulting tree will automatically be normalized into the
  ; app state graph database.
  {:initial-state (fn [params] {:ui/react-key "initial" :current-tab (prim/get-initial-state UITabs nil)})
   :query         [:ui/react-key {:current-tab (prim/get-query UITabs)}]}
  (dom/div #js {:key react-key}
    ; The selection of tabs can be rendered in a child, but the transact! must be done from the parent (to
    ; ensure proper re-render of the tab body). See prim/computed for passing callbacks.
    (dom/button #js {:onClick #(prim/transact! this `[(choose-tab {:tab :main})])} "Main")
    (dom/button #js {:onClick #(prim/transact! this `[(choose-tab {:tab :settings})
                                                      ; extra mutation: sample of what you would do to lazy load the tab content
                                                      (lazy-load-tab {:tab :settings})])} "Settings")
    (ui-tabs current-tab)))
```

The first is simple enough: run a mutation that chooses which tab to show. The routing library includes a helper function
for building that, so the mutation just looks like this:

```
(m/defmutation choose-tab [{:keys [tab]}]
  (action [{:keys [state]}] (swap! state r/set-route :ui-router [tab :tab])))
```

The transaction to go to the settings tab is more interesting. It switches tabs but also runs another mutation to
load data needed for that screen. The intention is to just load it if it is missing. That mutation looks like this:

```
(defn missing-tab? [state tab] (empty? (-> @state :settings :tab :settings)))

(m/defmutation lazy-load-tab [{:keys [tab]}]
  (action [{:keys [state] :as env}]
    (when (missing-tab? state tab)
      (df/load-action state :all-settings SomeSetting
        {:target  [:settings :tab :settings]
         :refresh [:settings]})))
  (remote [{:keys [state] :as env}]
    (when (missing-tab? state tab) (df/remote-load env))))
```

Fairly standard fare at this point: Look at the database to see if it has what you want, and if not trigger a load
with `df/load-action` (on the action side) and `df/remote-load` on the remote.

++++
<div class="example" id="loading-in-response-to-UI-routing"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.loading-in-response-to-UI-routing').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="loading-in-response-to-UI-routing source"]
----
include::src/book/book/demos/loading_in_response_to_UI_routing.cljs[]
----

== Paginating Large Lists

This demo is showing a (dynamically generated) list of items. The server can generate any number of them, so you
can page ahead as many times as you like. Each page is dynamically loaded if and only if the browser does not already
have it. The demo also ensures you cannot run out of browser memory by removing items and pages that are more than 4 steps away
from your current position. You can demostrate this by moving ahead by more than 4 pages, then page back 5. You should
see a reload of that early page when you go back to it.

The UI of this example is a great example of how a complex application behavior remains very very simple at the UI
layer with Fulcro.

We represent the list items as you might expect:

```
(defsc ListItem [this {:keys [item/id]}]
  {:query [:item/id :ui/fetch-state]
   :ident [:items/by-id :item/id]}
  (dom/li nil (str "Item " id)))
```

We then generate a component to represent a page of them. This allows us to associate the items on a page with
a particular component, which makes tracking the page number and items on that page much simpler:

```
(defsc ListPage [this {:keys [page/number page/items]}]
  {:initial-state {:page/number 1 :page/items []}
   :query         [:page/number {:page/items (prim/get-query ListItem)}]
   :ident         [:page/by-number :page/number]}
  (dom/div nil
    (dom/p nil "Page number " number)
    (df/lazily-loaded #(dom/ul nil (mapv ui-list-item %)) items)))
```

Next we build a component named `LargeList` to control which page we're on. This component does nothing more than
show the current page, and transact mutations that ask for the specific page. Not that we could easily add a control
to jump to any page, since the mutation itself is `goto-page`.

```
(defsc LargeList [this {:keys [list/current-page]}]
  {:initial-state (fn [params] {:list/current-page (prim/get-initial-state ListPage {})})
   :query         [{:list/current-page (prim/get-query ListPage)}]
   :ident         (fn [] [:list/by-id 1])}
  (let [{:keys [page/number]} current-page]
    (dom/div nil
      (dom/button #js {:disabled (= 1 number)
        :onClick #(prim/transact! this `[(goto-page {:page-number ~(dec number)})])} "Prior Page")
      (dom/button #js {:onClick #(prim/transact! this `[(goto-page {:page-number ~(inc number)})])}
        "Next Page")
      (ui-list-page current-page))))
```

=== The goto-page Mutation

So you can infer that all of the complexity of this application is hidden behind a single mutation: `goto-page`. This
mutation is a complete abstraction to the UI, and the UI designer would need to very little about it.

We've decided that this mutation will:

* Ensure the given page exists in app state (with its page number)
* Check to see if the page has items
** If not: it will trigger a server-side query for those items
* Update the `LargeList`'s current page to point to the correct page
* Garbage collect pages/items in the app database that are 5 or more pages away from the current position.

The mutation itself looks like this:

```
(m/defmutation goto-page [{:keys [page-number]}]
  (action [{:keys [state] :as env}]
    (load-if-missing env page-number)
    (swap! state (fn [s]
                   (-> s
                     (init-page page-number)
                     (set-current-page page-number)
                     (gc-distant-pages page-number)))))
  (remote [{:keys [state] :as env}]
    (when (not (page-exists? @state page-number))
      (df/remote-load env)))) ; trigger load queue processing
```

Let's break this down.

==== The Action

The `load-if-missing` function is composed of the following bits:

```
(defn page-exists? [state-map page-number]
  (let [page-items (get-in state-map [:page/by-number page-number :page/items])]
    (boolean (seq page-items))))

(defn load-if-missing [{:keys [reconciler state] :as env} page-number]
  (when-not (page-exists? @state page-number)
    (let [start (inc (* 10 (dec page-number)))
          end   (+ start 9)]
      (df/load reconciler :paginate/items ListItem {:params {:start start :end end}
                                                    :target [:page/by-number page-number :page/items]}))))
```

and you can see that it just detects if the page is missing its items. If the items are missing, it loads them.

=== The Server-Side Code

The server in this example is trivial. It is just a query that generates items on the fly:

```
(defmethod api/server-read :paginate/items [env k {:keys [start end]}]
  (when (> 1000 (- end start)) ; ensure the server doesn't die if the client does something like use NaN for end
    {:value (vec (for [id (range start end)]
                   {:item/id id}))}))
```


++++
<div class="example" id="paginating-large-lists-from-server"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.paginating-large-lists-from-server').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="paginating-large-lists-from-server source"]
----
include::src/book/book/demos/paginating_large_lists_from_server.cljs[]
----

== UI Query Security

If you examine any UI query it will have a tree form. That is the nature of Fulcro's query and Datomic pull syntax. It
is also the nature of UI's. For any such query, you can imagine it as a graph walk:

Take this query:

```
[:a {:join1 [:b {:join2 [:c :d]}]}]
```

If you think about how this looks in the server: each join walks from one table (or entity) to another through
some kind of (forward or reverse) reference.

----
   QUERY PART                            IMPLIED DATABASE graph
[:a {:join1                           { :a 6 :join1 [:tableX id1] }
                                                      \
                                                       \
                                                        \
        [:b {:join2                       :tableX { id1 { :id id1 :join2 [:tableY id2]
                                                                            /
                                                                           /
                                                                         /
              [:c :d]}]}]                :tableY { id2 { :id id2 :c 4 :d 5 }}
----

One idea that works pretty well for us is based on this realization: There is a starting point of this walk (e.g. I
want to load a person), and the top-level detail *must* be specified (or implied at least) by the incoming query
(load person 5, load all persons in my account, etc.).

A tradition logic check always needs to be run on
this object to see if it is OK for the user to *start* reading the database there.

The problem that remains is that there is a graph query that could conceivably walk to things in the database that
should not be readable. So, to ensure security we need to verify that the user:

. is allowed to read the specific *data* at the node of the graph (e.g. :a, :c, and :d)
. is allowed to *walk* across a given *reference* at that node of the graph.

However, since both of those cases are essentially the same in practice (can the user read the given property), one
possible algorithm simplifies to:

* Create a whitelist of keywords that are allowed to be read by the query in question. This can be a one-time
declarative configuration, or something dynamic based on user rights.
* Verify the user is allowed to read the "top" object. If not, disallow the query.
* Recursively gather up all keywords from the query as a set
* Find the set difference of the whitelist and the query keywords.
* If the difference is not empty, refuse to run the query

=== The Server Hooks

This is one of the few examples that would add extra code to the server itself (we're still simulating it for this
book). This example's auth mechanisms would be set up as components and a parser injection there. The relevant
code is:

```
(defrecord Authentication [handler]
  c/Lifecycle
  (start [this]
    (log/info "Hooking into pre-processing to add user info")
    (let [old-pre-hook (h/get-pre-hook handler)
          new-hook     (fn [ring-handler] (fn [req] ((old-pre-hook ring-handler) (assoc req :user {:username "Tony"}))))]
      (h/set-pre-hook! handler new-hook))
    this)
  (stop [this] this))

(defn make-authentication []
  (c/using (map->Authentication {}) [:handler]))

(defprotocol Auth
  (can-access-entity? [this user key entityid] "Check if the given user is allowed to access the entity designated by the given key and entity id")
  (authorized-query? [this user top-key query] "Check if the given user is allowed to access all of the data in the query that starts at the given join key"))

(defrecord Authorizer []
  c/Lifecycle
  (start [this] this)
  (stop [this] this)
  Auth
  (can-access-entity? [this user key entityid] (authorized-root-entity? user key entityid))
  (authorized-query? [this user top-key query] (is-authorized-query? query top-key)))

(defn make-authorizer [] (map->Authorizer {}))

(defn make-system []
  (core/make-fulcro-server
    :config-path "config/demos.edn"
    :parser (prim/parser {:read logging-query :mutate logging-mutate})
    :parser-injections #{:authentication}
    :components {
                 ; Server security demo: This puts itself into the Ring pipeline to add user info to the request
                 :auth-hook      (server-security/make-authentication)
                 ; This is here as a component so it can be injected into the parser env for processing security
                 :authentication (server-security/make-authorizer)}))
```

This logic is basically hacked in to the live example to give you an idea of how
it looks.

++++
<div class="example" id="server-query-security"> </div>
<a class="source-toggle" href="javascript:void(0)" onClick="$('.server-query-security').toggle()">Show/Hide Source</a>
++++

[source,clojure,role="server-query-security source"]
----
include::src/book/book/demos/server_query_security.cljs[]
----

== Fulcro with SQL

The Fulcro SQL library is capable of running many Fulcro graph queries directly
against an SQL database. It also comes with testing utilities and a component for
setting up connection pooling (via http://brettwooldridge.github.io/HikariCP[HikariCP])
and migrations (via https://flywaydb.org/[Flyway]).

Since our demos run in the browser only for this document, we cannot show you a live demo,
but here are some basics to whet your appetite.

Assume you have a PostgreSQL database. We could create a project with
migrations in `src/main/config/migrations/V1__account_schema.sql`. See
Flyway documentation for naming conventions. For our example here,
let's say our initial schema is:

```
CREATE TABLE settings (
  id                 SERIAL PRIMARY KEY,
  auto_open          BOOLEAN NOT NULL DEFAULT FALSE,
  keyboard_shortcuts BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE account (
  id             SERIAL PRIMARY KEY,
  name           TEXT,
  last_edited_by INTEGER,
  settings_id    INTEGER REFERENCES settings (id),
  created_on     TIMESTAMP NOT NULL DEFAULT now()
);

CREATE TABLE member (
  id         SERIAL PRIMARY KEY,
  name       TEXT,
  account_id INTEGER NOT NULL REFERENCES account (id)
);
ALTER TABLE account
  ADD CONSTRAINT account_last_edit_by_fkey FOREIGN KEY (last_edited_by) REFERENCES member (id);

-- Some seed data for the demo
INSERT INTO settings (id, auto_open, keyboard_shortcuts) VALUES (1, true, false);
INSERT INTO settings (id, auto_open, keyboard_shortcuts) VALUES (2, false, false);
INSERT INTO account (id, name, settings_id) values (1, 'Sally', 1);
INSERT INTO account (id, name, settings_id) values (2, 'Bob', 2);
INSERT INTO member (id, name, account_id) values (1, 'Billy', 1);
INSERT INTO member (id, name, account_id) values (2, 'Tom', 1);
INSERT INTO member (id, name, account_id) values (3, 'Tori', 1);
INSERT INTO member (id, name, account_id) values (4, 'Cory', 2);
INSERT INTO member (id, name, account_id) values (5, 'Kady', 2);
```

The connection pooling needs to be configured as well, and Fulcro SQL allows this to
also be on the classpath. Assume we have `src/main/config/accountpool.props` with
(see HikariCP documentation):

```
dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
dataSource.user=test
dataSource.password=
dataSource.databaseName=accounts
dataSource.portNumber=5432
dataSource.serverName=localhost
```

Then with some simple UI components like

```
(defsc Settings [this {:keys [db/id settings/auto-open? settings/keyboard-shortcuts?]}]
  {:query [:db/id :settings/auto-open? :settings/keyboard-shortcuts?]
  ...

(defsc Member [this {:keys [db/id member/name]}]
  {:query [:db/id :member/name]
  ...

(defsc Account [this {:keys [db/id account/name account/members account/settings]}]
  {:query [:db/id :account/name {:account/members (prim/get-query Member)} {:account/settings (prim/get-query Settings)}]
```

we might want to issue a load like this:

```
(df/load app :graph-demo/accounts Account {:target [:accounts]})
```

In this example, we've been careful to align the UI with the schema of the database. All
Fulcro SQL needs is a bit of configuration to tell it how to map the UI graph to the
schema:

```
(def schema
 {:fulcro-sql.core/graph->sql {:settings/auto-open?          :settings/auto_open
                               :settings/keyboard-shortcuts? :settings/keyboard_shortcuts}
  :fulcro-sql.core/joins      {:account/members  (sql/to-many [:account/id :member/account_id])
                               :account/settings (sql/to-one [:account/settings_id :settings/id])
                               :member/account   (sql/to-one [:member/account_id :account/id])}
  :fulcro-sql.core/pks        {}})
```

The relations (defined with `to-one` and `to-many`) assume you've chosen keyword namespaces that match your table names,
and keyword names that match column names (e.g. keyword `:account/id` -> SQL `ACCOUNT.ID`). The joins are
then simply defined in the direction desired (you can see `:account/members` and `:member/account`
trafersing the same SQL "edge"). If that isn't try, then you can remap them in the `graph->sql` section.

The database configuration (in our config EDN file) is:

```
{:port   8081
 :sqldbm {:accounts {:hikaricp-config "config/accountpool.props"
                     :auto-migrate?   true
                     :create-drop?    true
                     :migrations      ["classpath:config/migrations"]}}}
```

and we inject the Fulcro SQL component into our parsing environment via:

```
(core/make-fulcro-server
  ...
  :parser-injections #{:sqldb}
  :components {:sqldb (component/using (sql/build-db-manager {}) [:config])})
```

The server code to handle the query is then quite small:

```
(server/defquery-root :graph-demo/accounts
 (value [{:keys [sqldb query]} params] ; get the injected database manager
   (let [db              (sql/get-dbspec sqldb :accounts) ; get the database from the db manager
         ; Find the IDs of the account(s) of interest (all accounts)
         all-account-ids (jdbc/query db ["select id from account"] {:row-fn :id :result-set-fn set})]
     (if (seq all-account-ids)
       (sql/run-query db schema :account/id query all-account-ids) ; run the graph query
       []))))
```

The complete source for this demo is:

[source, clojure]
----
(ns book.demos.server-SQL-graph-queries
  (:require
    #?@(:clj [[fulcro-sql.core :as sql]
              [clojure.java.jdbc :as jdbc]
              [taoensso.timbre :as timbre]])
              [com.stuartsierra.component :as component]
              [fulcro.client.dom :as dom]
              [fulcro.easy_server :refer [make-fulcro-server]]
              [fulcro.server :as server :refer [defquery-root server-read server-mutate]]
              [fulcro.client.data-fetch :as df]
              [fulcro.logging :as log]
              [fulcro.client :as fc]
              [fulcro.ui.bootstrap3 :as b]
              [fulcro.client.primitives :as prim :refer [defsc]]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SERVER:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#?(:clj
   (def schema
     {:fulcro-sql.core/graph->sql {:settings/auto-open?          :settings/auto_open
                                   :settings/keyboard-shortcuts? :settings/keyboard_shortcuts}
      :fulcro-sql.core/joins      {:account/members  (sql/to-many [:account/id :member/account_id])
                                   :account/settings (sql/to-one [:account/settings_id :settings/id])
                                   :member/account   (sql/to-one [:member/account_id :account/id])}
      :fulcro-sql.core/pks        {}}))

; This is the only thing we wrote for the server...just return some value so we can
; see it really talked to the server for this query.
#?(:clj
   (server/defquery-root :graph-demo/accounts
     (value [{:keys [sqldb query]} params]
       (let [db              (sql/get-dbspec sqldb :accounts)
             all-account-ids (jdbc/query db ["select id from account"] {:row-fn :id :result-set-fn set})]
         (timbre/info all-account-ids)
         (if (seq all-account-ids)
           (sql/run-query db schema :account/id query all-account-ids)
           [])))))

(defn make-system []
  (let [include-postgres? (boolean (System/getProperty "postgres"))]
    (make-fulcro-server
      :config-path "config/demos.edn"
      :parser-injections (cond-> #{:authorization}
                           include-postgres? (conj :sqldb))
      :components {:sqldb (component/using
                            (sql/build-db-manager {})
                            [:config])})))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLIENT:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsc Settings [this {:keys [db/id settings/auto-open? settings/keyboard-shortcuts?]}]
  {:query [:db/id :settings/auto-open? :settings/keyboard-shortcuts?]
   :ident [:settings/by-id :db/id]}
  (dom/ul nil
    (dom/li nil (str "Auto open? " auto-open?))
    (dom/li nil (str "Enable Keyboard Shortcuts? " keyboard-shortcuts?))))

(def ui-settings (prim/factory Settings {:keyfn :db/id}))

(defsc Member [this {:keys [db/id member/name]}]
  {:query [:db/id :member/name]
   :ident [:member/by-id :db/id]}
  (dom/div nil
    "Member: " name))

(def ui-member (prim/factory Member {:keyfn :db/id}))

(defsc Account [this {:keys [db/id account/name account/members account/settings]}]
  {:query [:db/id :account/name {:account/members (prim/get-query Member)} {:account/settings (prim/get-query Settings)}]
   :ident [:account/by-id :db/id]}
  (dom/div nil
    (dom/h3 nil (str "Account for " name))
    (dom/ul nil
      (when (seq settings)
        (dom/li nil
          (dom/h3 nil "Settings")
          (ui-settings settings)))
      (dom/li nil
        (dom/h3 nil "Members in the account")
        (map ui-member members)))))

(def ui-account (prim/factory Account {:keyfn :db/id}))

(defsc Root [this {:keys [ui/react-key accounts]}]
  {:query [:ui/react-key {:accounts (prim/get-query Account)}]}
  (dom/div #js {:key react-key}
    (dom/h3 nil "Accounts with settings and users")
    (map ui-account accounts)))

#?(:cljs (defonce app (atom (fc/new-fulcro-client :started-callback
                              (fn [app]
                                (df/load app :graph-demo/accounts Account {:target [:accounts]})))))) `#?(:cljs (swap! app fc/mount Root "app"))
----



++++
<style>
@media screen {
  .source-toggle {padding-bottom: 1em;}
  .source {display: none;
  margin-left: 2em;}
}
@media print {
  .source-toggle {display:none;}
  .source {display: block;
           margin-left: 2em;
          }
}
.example {width: "100vw";
          height: "100vh";
          background-color: lightgray;
          border: 3px groove white;
          border-radius: 10px;
          padding: 0;
          margin: 0;}
.example-title {
}
.com-rigsomelight-rendered-edn .keyval > .keyword {
 color: rgb(196,33,0);
 padding-right: 10px;
}

.com-rigsomelight-rendered-edn .collection {
  position: relative;
}

.com-rigsomelight-rendered-edn .vector,
.com-rigsomelight-rendered-edn .set,
.com-rigsomelight-rendered-edn .seq  {
  padding-left: 0.9em;
  padding-right: 0.9em;
}

.com-rigsomelight-rendered-edn .set {
  padding-left: 1.2em;
}


.com-rigsomelight-rendered-edn .collection.map {
  padding-left: 0.8em;
  display: inline-block;
  vertical-align: top;
}

.com-rigsomelight-rendered-edn .vector,
.com-rigsomelight-rendered-edn .set,
.com-rigsomelight-rendered-edn .seq {
  display: inline-block;
  vertical-align: top;
}

.com-rigsomelight-rendered-edn .vector > .contents {
  background-color: rgba(0,0,0,0.01);
}

.com-rigsomelight-rendered-edn .keyval {
  display: inline-block;
}

.com-rigsomelight-rendered-edn .collection.map > .contents > .separator  {
padding-right: 10px;
}

.com-rigsomelight-rendered-edn .collection .collection > .contents {
/*  background-color: rgba(0,0,0,0.02); */
}

.com-rigsomelight-rendered-edn .collection .contents > .collection:nth-child(even) {
background-color: rgba(0,0,0,0.04);
}

.com-rigsomelight-rendered-edn .contents {
  display: inline-block;
}

.com-rigsomelight-rendered-edn .opener,
.com-rigsomelight-rendered-edn .closer {
 color: #999;
}

.com-rigsomelight-rendered-edn .collection.map > .opener,
.com-rigsomelight-rendered-edn .collection.vector > .opener,
.com-rigsomelight-rendered-edn .collection.seq > .opener,
.com-rigsomelight-rendered-edn .collection.set > .opener {
 position: absolute;
 top: 0px;
 left: 3px;
}
.com-rigsomelight-rendered-edn .collection.map > .closer {
 bottom: 0px;
 right: 0px;
 display: block;
}

.com-rigsomelight-rendered-edn .collection.vector > .closer,
.com-rigsomelight-rendered-edn .collection.seq > .closer,
.com-rigsomelight-rendered-edn .collection.set > .closer {
 position: absolute;
 bottom: 0px;
 right: 0px;
 display: block;
}
</style>

<!-- The book demos -->
<script src="js/book/cljs_base.js"></script>
<script src="js/book.js"></script>
<script src="js/main.js"></script>

<!-- quick convenient way to toggle the source within asciidoc, since
     it is super-easy to include it via asciidoc include -->
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-107376541-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-107376541-3');
</script>
++++


